cuBLAS Release 12.3 NVIDIA Nov 14, 2023 Contents 1 Data Layout 3 2 New and Legacy cuBLAS API 5 3 Example Code 7 4 Using the cuBLAS API 11 4.1 General Description 11 4.1.1 Error Status 11 4.1.2 cuBLAS Context 11 4.1.3 Thread Safety 12 4.1.4 Results Reproducibility 12 4.1.5 Scalar Parameters 12 4.1.6 Parallelism with Streams 13 4.1.7 Batching Kernels 13 4.1.8 Cache Configuration 14 4.1.9 Static Library Support 14 4.1.10 GEMM Algorithms Numerical Behavior 15 4.1.11 Tensor Core Usage 15 4.1.12 CUDA Graphs Support 16 4.1.13 64-bit Integer Interface 16 4.2 cuBLAS Datatypes Reference 17 4.2.1 cublasHandle_t 17 4.2.2 cublasStatus_t 17 4.2.3 cublasOperation_t 19 4.2.4 cublasFillMode_t 19 4.2.5 cublasDiagType_t 19 4.2.6 cublasSideMode_t 20 4.2.7 cublasPointerMode_t 20 4.2.8 cublasAtomicsMode_t 20 4.2.9 cublasGemmAlgo_t 20 4.2.10 cublasMath_t 21 4.2.11 cublasComputeType_t 22 4.3 CUDA Datatypes Reference 23 4.3.1 cudaDataType_t 23 4.3.2 libraryPropertyType_t 24 4.4 cuBLAS Helper Function Reference 24 4.4.1 cublasCreate() 24 4.4.2 cublasDestroy() 25 4.4.3 cublasGetVersion() 25 4.4.4 cublasGetProperty() 25 4.4.5 cublasGetStatusName() 26 4.4.6 cublasGetStatusString() 26 i 4.4.7 cublasSetStream() 26 4.4.8 cublasSetWorkspace() 27 4.4.9 cublasGetStream() 27 4.4.10 cublasGetPointerMode() 28 4.4.11 cublasSetPointerMode() 28 4.4.12 cublasSetVector() 28 4.4.13 cublasGetVector() 29 4.4.14 cublasSetMatrix() 29 4.4.15 cublasGetMatrix() 30 4.4.16 cublasSetVectorAsync() 30 4.4.17 cublasGetVectorAsync() 31 4.4.18 cublasSetMatrixAsync() 31 4.4.19 cublasGetMatrixAsync() 31 4.4.20 cublasSetAtomicsMode() 32 4.4.21 cublasGetAtomicsMode() 32 4.4.22 cublasSetMathMode() 33 4.4.23 cublasGetMathMode() 33 4.4.24 cublasSetSmCountTarget() 33 4.4.25 cublasGetSmCountTarget() 34 4.4.26 cublasLoggerConfigure() 34 4.4.27 cublasGetLoggerCallback() 35 4.4.28 cublasSetLoggerCallback() 35 4.5 cuBLAS Level-1 Function Reference 35 4.5.1 cublasI<t>amax() 36 4.5.2 cublasI<t>amin() 37 4.5.3 cublas<t>asum() 38 4.5.4 cublas<t>axpy() 39 4.5.5 cublas<t>copy() 40 4.5.6 cublas<t>dot() 41 4.5.7 cublas<t>nrm2() 42 4.5.8 cublas<t>rot() 43 4.5.9 cublas<t>rotg() 44 4.5.10 cublas<t>rotm() 45 4.5.11 cublas<t>rotmg() 47 4.5.12 cublas<t>scal() 48 4.5.13 cublas<t>swap() 49 4.6 cuBLAS Level-2 Function Reference 49 4.6.1 cublas<t>gbmv() 50 4.6.2 cublas<t>gemv() 52 4.6.3 cublas<t>ger() 54 4.6.4 cublas<t>sbmv() 55 4.6.5 cublas<t>spmv() 57 4.6.6 cublas<t>spr() 59 4.6.7 cublas<t>spr2() 60 4.6.8 cublas<t>symv() 62 4.6.9 cublas<t>syr() 64 4.6.10 cublas<t>syr2() 65 4.6.11 cublas<t>tbmv() 67 4.6.12 cublas<t>tbsv() 69 4.6.13 cublas<t>tpmv() 71 4.6.14 cublas<t>tpsv() 73 4.6.15 cublas<t>trmv() 75 4.6.16 cublas<t>trsv() 77 4.6.17 cublas<t>hemv() 79 ii 4.6.18 cublas<t>hbmv() 81 4.6.19 cublas<t>hpmv() 83 4.6.20 cublas<t>her() 85 4.6.21 cublas<t>her2() 86 4.6.22 cublas<t>hpr() 88 4.6.23 cublas<t>hpr2() 89 4.6.24 cublas<t>gemvBatched() 91 4.6.25 cublas<t>gemvStridedBatched() 94 4.7 cuBLAS Level-3 Function Reference 98 4.7.1 cublas<t>gemm() 98 4.7.2 cublas<t>gemm3m() 101 4.7.3 cublas<t>gemmBatched() 103 4.7.4 cublas<t>gemmStridedBatched() 106 4.7.5 cublas<t>symm() 110 4.7.6 cublas<t>syrk() 112 4.7.7 cublas<t>syr2k() 114 4.7.8 cublas<t>syrkx() 116 4.7.9 cublas<t>trmm() 119 4.7.10 cublas<t>trsm() 122 4.7.11 cublas<t>trsmBatched() 124 4.7.12 cublas<t>hemm() 127 4.7.13 cublas<t>herk() 129 4.7.14 cublas<t>her2k() 131 4.7.15 cublas<t>herkx() 133 4.8 BLAS-like Extension 135 4.8.1 cublas<t>geam() 135 4.8.2 cublas<t>dgmm() 138 4.8.3 cublas<t>getrfBatched() 140 4.8.4 cublas<t>getrsBatched() 142 4.8.5 cublas<t>getriBatched() 145 4.8.6 cublas<t>matinvBatched() 147 4.8.7 cublas<t>geqrfBatched() 149 4.8.8 cublas<t>gelsBatched() 151 4.8.9 cublas<t>tpttr() 153 4.8.10 cublas<t>trttp() 154 4.8.11 cublas<t>gemmEx() 156 4.8.12 cublasGemmEx() 159 4.8.13 cublasGemmBatchedEx() 163 4.8.14 cublasGemmStridedBatchedEx() 168 4.8.15 cublasCsyrkEx() 173 4.8.16 cublasCsyrk3mEx() 175 4.8.17 cublasCherkEx() 177 4.8.18 cublasCherk3mEx() 179 4.8.19 cublasNrm2Ex() 182 4.8.20 cublasAxpyEx() 184 4.8.21 cublasDotEx() 185 4.8.22 cublasRotEx() 187 4.8.23 cublasScalEx() 189 5 Using the cuBLASLt API 191 5.1 General Description 191 5.1.1 Problem Size Limitations 191 5.1.2 Heuristics Cache 192 5.1.3 cuBLASLt Logging 192 iii 5.1.4 8-bit Floating Point Data Types (FP8) Usage 193 5.1.5 Disabling CPU Instructions 194 5.2 cuBLASLt Code Examples 194 5.3 cuBLASLt Datatypes Reference 194 5.3.1 cublasLtClusterShape_t 194 5.3.2 cublasLtEpilogue_t 196 5.3.3 cublasLtHandle_t 198 5.3.4 cublasLtLoggerCallback_t 198 5.3.5 cublasLtMatmulAlgo_t 198 5.3.6 cublasLtMatmulAlgoCapAttributes_t 198 5.3.7 cublasLtMatmulAlgoConfigAttributes_t 200 5.3.8 cublasLtMatmulDesc_t 200 5.3.9 cublasLtMatmulDescAttributes_t 201 5.3.10 cublasLtMatmulHeuristicResult_t 203 5.3.11 cublasLtMatmulInnerShape_t 203 5.3.12 cublasLtMatmulPreference_t 203 5.3.13 cublasLtMatmulPreferenceAttributes_t 204 5.3.14 cublasLtMatmulSearch_t 205 5.3.15 cublasLtMatmulTile_t 205 5.3.16 cublasLtMatmulStages_t 206 5.3.17 cublasLtNumericalImplFlags_t 207 5.3.18 cublasLtMatrixLayout_t 209 5.3.19 cublasLtMatrixLayoutAttribute_t 209 5.3.20 cublasLtMatrixTransformDesc_t 211 5.3.21 cublasLtMatrixTransformDescAttributes_t 211 5.3.22 cublasLtOrder_t 212 5.3.23 cublasLtPointerMode_t 212 5.3.24 cublasLtPointerModeMask_t 213 5.3.25 cublasLtReductionScheme_t 213 5.4 cuBLASLt API Reference 214 5.4.1 cublasLtCreate() 214 5.4.2 cublasLtDestroy() 215 5.4.3 cublasLtDisableCpuInstructionsSetMask() 215 5.4.4 cublasLtGetCudartVersion() 216 5.4.5 cublasLtGetProperty() 216 5.4.6 cublasLtGetStatusName() 217 5.4.7 cublasLtGetStatusString() 217 5.4.8 cublasLtHeuristicsCacheGetCapacity() 217 5.4.9 cublasLtHeuristicsCacheSetCapacity() 217 5.4.10 cublasLtGetVersion() 218 5.4.11 cublasLtLoggerSetCallback() 218 5.4.12 cublasLtLoggerSetFile() 219 5.4.13 cublasLtLoggerOpenFile() 219 5.4.14 cublasLtLoggerSetLevel() 220 5.4.15 cublasLtLoggerSetMask() 220 5.4.16 cublasLtLoggerForceDisable() 221 5.4.17 cublasLtMatmul() 221 5.4.18 cublasLtMatmulAlgoCapGetAttribute() 226 5.4.19 cublasLtMatmulAlgoCheck() 227 5.4.20 cublasLtMatmulAlgoConfigGetAttribute() 229 5.4.21 cublasLtMatmulAlgoConfigSetAttribute() 230 5.4.22 cublasLtMatmulAlgoGetHeuristic() 230 5.4.23 cublasLtMatmulAlgoGetIds() 231 5.4.24 cublasLtMatmulAlgoInit() 233 iv 5.4.25 cublasLtMatmulDescCreate() 234 5.4.26 cublasLtMatmulDescInit() 234 5.4.27 cublasLtMatmulDescDestroy() 235 5.4.28 cublasLtMatmulDescGetAttribute() 236 5.4.29 cublasLtMatmulDescSetAttribute() 237 5.4.30 cublasLtMatmulPreferenceCreate() 237 5.4.31 cublasLtMatmulPreferenceInit() 238 5.4.32 cublasLtMatmulPreferenceDestroy() 239 5.4.33 cublasLtMatmulPreferenceGetAttribute() 239 5.4.34 cublasLtMatmulPreferenceSetAttribute() 240 5.4.35 cublasLtMatrixLayoutCreate() 241 5.4.36 cublasLtMatrixLayoutInit() 242 5.4.37 cublasLtMatrixLayoutDestroy() 243 5.4.38 cublasLtMatrixLayoutGetAttribute() 244 5.4.39 cublasLtMatrixLayoutSetAttribute() 245 5.4.40 cublasLtMatrixTransform() 245 5.4.41 cublasLtMatrixTransformDescCreate() 247 5.4.42 cublasLtMatrixTransformDescInit() 247 5.4.43 cublasLtMatrixTransformDescDestroy() 248 5.4.44 cublasLtMatrixTransformDescGetAttribute() 248 5.4.45 cublasLtMatrixTransformDescSetAttribute() 249 6 Using the cuBLASXt API 251 6.1 General description 251 6.1.1 Tiling design approach 251 6.1.2 Hybrid CPU-GPU computation 253 6.1.3 Results reproducibility 253 6.2 cuBLASXt API Datatypes Reference 253 6.2.1 cublasXtHandle_t 253 6.2.2 cublasXtOpType_t 254 6.2.3 cublasXtBlasOp_t 254 6.2.4 cublasXtPinningMemMode_t 255 6.3 cuBLASXt API Helper Function Reference 255 6.3.1 cublasXtCreate() 255 6.3.2 cublasXtDestroy() 255 6.3.3 cublasXtDeviceSelect() 256 6.3.4 cublasXtSetBlockDim() 256 6.3.5 cublasXtGetBlockDim() 256 6.3.6 cublasXtSetCpuRoutine() 257 6.3.7 cublasXtSetCpuRatio() 257 6.3.8 cublasXtSetPinningMemMode() 257 6.3.9 cublasXtGetPinningMemMode() 258 6.4 cuBLASXt API Math Functions Reference 258 6.4.1 cublasXt<t>gemm() 259 6.4.2 cublasXt<t>hemm() 261 6.4.3 cublasXt<t>symm() 263 6.4.4 cublasXt<t>syrk() 265 6.4.5 cublasXt<t>syr2k() 267 6.4.6 cublasXt<t>syrkx() 269 6.4.7 cublasXt<t>herk() 271 6.4.8 cublasXt<t>her2k() 273 6.4.9 cublasXt<t>herkx() 275 6.4.10 cublasXt<t>trsm() 277 6.4.11 cublasXt<t>trmm() 279 v 6.4.12 cublasXt<t>spmm() 281 7 Using the cuBLAS Legacy API 285 7.1 Error Status 285 7.2 Initialization and Shutdown 286 7.3 Thread Safety 286 7.4 Memory Management 286 7.5 Scalar Parameters 286 7.6 Helper Functions 287 7.7 Level-1,2,3 Functions 287 7.8 Converting Legacy to the cuBLAS API 287 7.9 Examples 288 8 cuBLAS Fortran Bindings 293 9 Interaction with Other Libraries and Tools 297 9.1 nvprune 297 10 Acknowledgements 299 11 Notices 301 11.1 Notice 301 11.2 OpenCL 302 11.3 Trademarks 302 vi cuBLAS, Release 12.3 cuBLAS The API Reference guide for cuBLAS, the CUDA Basic Linear Algebra Subroutine library. The cuBLAS library is an implementation of BLAS (Basic Linear Algebra Subprograms) on top of the NVIDIA®CUDA™ runtime. It allows the user to access the computational resources of NVIDIA Graphics Processing Unit (GPU). The cuBLAS Library exposes three sets of API: ? The cuBLAS API, which is simply called cuBLAS API in this document (starting with CUDA 6.0), ? The cuBLASXt API (starting with CUDA 6.0), and ? The cuBLASLt API (starting with CUDA 10.1) To use the cuBLAS API, the application must allocate the required matrices and vectors in the GPU memory space, fill them with data, call the sequence of desired cuBLAS functions, and then upload the results from the GPU memory space back to the host. The cuBLAS API also provides helper functions for writing and retrieving data from the GPU. To use the cuBLASXt API, the application may have the data on the Host or any of the devices involved in the computation, and the Library will take care of dispatching the operation to, and transferring the data to, one or multiple GPUs present in the system, depending on the user request. The cuBLASLt is a lightweight library dedicated to GEneral Matrix-to-matrix Multiply (GEMM) opera- tions with a new flexible API. This library adds flexibility in matrix data layouts, input types, compute types, and also in choosing the algorithmic implementations and heuristics through parameter pro- grammability. After a set of options for the intended GEMM operation are identified by the user, these options can be used repeatedly for different inputs. This is analogous to how cuFFT and FFTW first create a plan and reuse for same size and type FFTs with different input data. Contents 1 cuBLAS, Release 12.3 2 Contents Chapter 1. Data Layout For maximum compatibility with existing Fortran environments, the cuBLAS library uses column-major storage, and 1-based indexing. Since C and C++ use row-major storage, applications written in these languages can not use the native array semantics for two-dimensional arrays. Instead, macros or inline functions should be defined to implement matrices on top of one-dimensional arrays. For Fortran code ported to C in mechanical fashion, one may chose to retain 1-based indexing to avoid the need to transform loops. In this case, the array index of a matrix element in row “i” and column “j” can be computed via the following macro #define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1)) Here, ld refers to the leading dimension of the matrix, which in the case of column-major storage is the number of rows of the allocated matrix (even if only a submatrix of it is being used). For natively written C and C++ code, one would most likely choose 0-based indexing, in which case the array index of a matrix element in row “i” and column “j” can be computed via the following macro #define IDX2C(i,j,ld) (((j)*(ld))+(i)) 3 cuBLAS, Release 12.3 4 Chapter 1. Data Layout Chapter 2. New and Legacy cuBLAS API Starting with version 4.0, the cuBLAS Library provides a new API, in addition to the existing legacy API. This section discusses why a new API is provided, the advantages of using it, and the differences with the existing legacy API. Warning: The legacy cuBLAS API is deprecated and will be removed in future release. The new cuBLAS library API can be used by including the header file cublas_v2.h. It has the following features that the legacy cuBLAS API does not have: ? The handle to the cuBLAS library context is initialized using the function and is explicitly passed to every subsequent library function call. This allows the user to have more control over the library setup when using multiple host threads and multiple GPUs. This also allows the cuBLAS APIs to be reentrant. ? The scalars ? and ? can be passed by reference on the host or the device, instead of only be- ing allowed to be passed by value on the host. This change allows library functions to execute asynchronously using streams even when ? and ? are generated by a previous kernel. ? When a library routine returns a scalar result, it can be returned by reference on the host or the device, instead of only being allowed to be returned by value only on the host. This change allows library routines to be called asynchronously when the scalar result is generated and returned by reference on the device resulting in maximum parallelism. ? The error status cublasStatus_t is returned by all cuBLAS library function calls. This change facilitates debugging and simplifies software development. Note that cublasStatus was re- named cublasStatus_t to be more consistent with other types in the cuBLAS library. ? The cublasAlloc() and cublasFree() functions have been deprecated. This change removes these unnecessary wrappers around cudaMalloc() and cudaFree(), respectively. ? The function cublasSetKernelStream() was renamed cublasSetStream() to be more con- sistent with the other CUDA libraries. The legacy cuBLAS API, explained in more detail in Using the cuBLAS Legacy API, can be used by in- cluding the header file cublas.h. Since the legacy API is identical to the previously released cuBLAS library API, existing applications will work out of the box and automatically use this legacy API without any source code changes. The current and the legacy cuBLAS APIs cannot be used simultaneously in a single translation unit: including both cublas.h and cublas_v2.h header files will lead to compilation errors due to incom- patible symbol redeclarations. In general, new applications should not use the legacy cuBLAS API, and existing applications should convert to using the new API if it requires sophisticated and optimal stream parallelism, or if it calls 5 cuBLAS, Release 12.3 cuBLAS routines concurrently from multiple threads. For the rest of the document, the new cuBLAS Library API will simply be referred to as the cuBLAS Library API. As mentioned earlier the interfaces to the legacy and the cuBLAS library APIs are the header file cublas.h and cublas_v2.h, respectively. In addition, applications using the cuBLAS library need to link against: ? The DSO cublas.so for Linux, ? The DLL cublas.dll for Windows, or ? The dynamic library cublas.dylib for Mac OS X. Note: The same dynamic library implements both the new and legacy cuBLAS APIs. 6 Chapter 2. New and Legacy cuBLAS API Chapter 3. Example Code For sample code references please see the two examples below. They show an application written in C using the cuBLAS library API with two indexing styles (Example 1. “Application Using C and cuBLAS: 1-based indexing” and Example 2. “Application Using C and cuBLAS: 0-based Indexing”). ??Example 1. Application Using C and cuBLAS: 1-based indexing ??----------------------------------------------------------- #include <stdio.h> #include <stdlib.h> #include <math.h> #include <cuda_runtime.h> #include "cublas_v2.h" #define M 6 #define N 5 #define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1)) static inline void modify (cublasHandle_t ‹> int q, float alpha, float beta){ handle, float *m, int ldm, int n, int p, cublasSscal (handle, n-q+1, &alpha, &m[IDX2F(p,q,ldm)], ldm); cublasSscal (handle, ldm-p+1, &beta, &m[IDX2F(p,q,ldm)], 1); } int main (void){ cudaError_t cudaStat; cublasStatus_t stat; cublasHandle_t handle; int i, j; float* devPtrA; float* a = 0; a = (float *)malloc (M * N * sizeof (*a)); if (!a) { printf ("host memory allocation failed"); return EXIT_FAILURE; } for (j = 1; j <= N; j++) { for (i = 1; i <= M; i++) { a[IDX2F(i,j,M)] = (float)((i-1) * N + j); } } cudaStat = cudaMalloc ((void**)&devPtrA, M*N*sizeof(*a)); if (cudaStat != cudaSuccess) { printf ("device memory allocation failed"); return EXIT_FAILURE; } stat = cublasCreate(&handle); (continues on next page) 7 cuBLAS, Release 12.3 (continued from previous page) if (stat != CUBLAS_STATUS_SUCCESS) { printf ("CUBLAS initialization failed\n"); return EXIT_FAILURE; } stat = cublasSetMatrix (M, N, sizeof(*a), a, M, devPtrA, M); if (stat != CUBLAS_STATUS_SUCCESS) { printf ("data download failed"); cudaFree (devPtrA); cublasDestroy(handle); return EXIT_FAILURE; } modify (handle, devPtrA, M, N, 2, 3, 16.0f, 12.0f); stat = cublasGetMatrix (M, N, sizeof(*a), devPtrA, M, a, M); if (stat != CUBLAS_STATUS_SUCCESS) { printf ("data upload failed"); cudaFree (devPtrA); cublasDestroy(handle); return EXIT_FAILURE; } cudaFree (devPtrA); cublasDestroy(handle); for (j = 1; j <= N; j++) { for (i = 1; i <= M; i++) { printf ("%7.0f", a[IDX2F(i,j,M)]); } printf ("\n"); } free(a); return EXIT_SUCCESS; } ??Example 2. Application Using C and cuBLAS: 0-based indexing ??----------------------------------------------------------- #include <stdio.h> #include <stdlib.h> #include <math.h> #include <cuda_runtime.h> #include "cublas_v2.h" #define M 6 #define N 5 #define IDX2C(i,j,ld) (((j)*(ld))+(i)) static inline void modify (cublasHandle_t ‹> int q, float alpha, float beta){ handle, float *m, int ldm, int n, int p, cublasSscal (handle, n-q, &alpha, &m[IDX2C(p,q,ldm)], ldm); cublasSscal (handle, ldm-p, &beta, &m[IDX2C(p,q,ldm)], 1); } int main (void){ cudaError_t cudaStat; cublasStatus_t stat; cublasHandle_t handle; int i, j; float* devPtrA; float* a = 0; (continues on next page) 8 Chapter 3. Example Code cuBLAS, Release 12.3 (continued from previous page) a = (float *)malloc (M * N * sizeof (*a)); if (!a) { printf ("host memory allocation failed"); return EXIT_FAILURE; } for (j = 0; j < N; j++) { for (i = 0; i < M; i++) { a[IDX2C(i,j,M)] = (float)(i * N + j + 1); } } cudaStat = cudaMalloc ((void**)&devPtrA, M*N*sizeof(*a)); if (cudaStat != cudaSuccess) { printf ("device memory allocation failed"); return EXIT_FAILURE; } stat = cublasCreate(&handle); if (stat != CUBLAS_STATUS_SUCCESS) { printf ("CUBLAS initialization failed\n"); return EXIT_FAILURE; } stat = cublasSetMatrix (M, N, sizeof(*a), a, M, devPtrA, M); if (stat != CUBLAS_STATUS_SUCCESS) { printf ("data download failed"); cudaFree (devPtrA); cublasDestroy(handle); return EXIT_FAILURE; } modify (handle, devPtrA, M, N, 1, 2, 16.0f, 12.0f); stat = cublasGetMatrix (M, N, sizeof(*a), devPtrA, M, a, M); if (stat != CUBLAS_STATUS_SUCCESS) { printf ("data upload failed"); cudaFree (devPtrA); cublasDestroy(handle); return EXIT_FAILURE; } cudaFree (devPtrA); cublasDestroy(handle); for (j = 0; j < N; j++) { for (i = 0; i < M; i++) { printf ("%7.0f", a[IDX2C(i,j,M)]); } printf ("\n"); } free(a); return EXIT_SUCCESS; } 9 cuBLAS, Release 12.3 10 Chapter 3. Example Code Chapter 4. Using the cuBLAS API 4.1. General Description This section describes how to use the cuBLAS library API. 4.1.1. Error Status All cuBLAS library function calls return the error status cublasStatus_t. 4.1.2. cuBLAS Context The application must initialize a handle to the cuBLAS library context by calling the cublasCreate() function. Then, the handle is explicitly passed to every subsequent library function call. Once the application finishes using the library, it must call the function cublasDestroy() to release the resources associated with the cuBLAS library context. This approach allows the user to explicitly control the library setup when using multiple host threads and multiple GPUs. For example, the application can use cudaSetDevice() to associate different devices with different host threads and in each of those host threads it can initialize a unique handle to the cuBLAS library context, which will use the particular device associated with that host thread. Then, the cuBLAS library function calls made with different handles will automatically dispatch the computation to different devices. The device associated with a particular cuBLAS context is assumed to remain unchanged between the corresponding cublasCreate() and cublasDestroy() calls. In order for the cuBLAS library to use a different device in the same host thread, the application must set the new device to be used by calling cudaSetDevice() and then create another cuBLAS context, which will be associated with the new device, by calling cublasCreate(). A cuBLAS library context is tightly coupled with the CUDA context that is current at the time of the cublasCreate() call. An application that uses multiple CUDA contexts is required to create a cuBLAS context per CUDA context and make sure the former never outlives the latter. 11 cuBLAS, Release 12.3 4.1.3. Thread Safety The library is thread safe and its functions can be called from multiple host threads, even with the same handle. When multiple threads share the same handle, extreme care needs to be taken when the handle configuration is changed because that change will affect potentially subsequent cuBLAS calls in all threads. It is even more true for the destruction of the handle. So it is not recommended that multiple thread share the same cuBLAS handle. 4.1.4. Results Reproducibility By design, all cuBLAS API routines from a given toolkit version, generate the same bit-wise results at every run when executed on GPUs with the same architecture and the same number of SMs. However, bit-wise reproducibility is not guaranteed across toolkit versions because the implementation might differ due to some implementation changes. This guarantee holds when a single CUDA stream is active only. If multiple concurrent streams are active, the library may optimize total performance by picking different internal implementations. Note: The non-deterministic behavior of multi-stream execution is due to library optimizations in selecting internal workspace for the routines running in parallel streams. To avoid this effect user can either: ? provide a separate workspace for each used stream using the cublasSetWorkspace() function, or ? have one cuBLAS handle per stream, or ? use cublasLtMatmul() instead of GEMM-family of functions and provide user owned workspace, or ? set a debug environment variable CUBLAS_WORKSPACE_CONFIG to :16:8 (may limit overall per- formance) or :4096:8 (will increase library footprint in GPU memory by approximately 24MiB). Any of those settings will allow for deterministic behavior even with multiple concurrent streams shar- ing a single cuBLAS handle. This behavior is expected to change in a future release. For some routines such as cublas<t>symv and cublas<t>hemv, an alternate significantly faster routine can be chosen using the routine cublasSetAtomicsMode(). In that case, the results are not guaranteed to be bit-wise reproducible because atomics are used for the computation. 4.1.5. Scalar Parameters There are two categories of the functions that use scalar parameters : ? Functions that take alpha and/or beta parameters by reference on the host or the device as scaling factors, such as gemm. ? Functions that return a scalar result on the host or the device such as amax(), amin, asum(), rotg(), rotmg(), dot() and nrm2(). 12 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 For the functions of the first category, when the pointer mode is set to CUBLAS_POINTER_MODE_HOST, the scalar parameters alpha and/or beta can be on the stack or allocated on the heap, shouldn’t be placed in managed memory. Underneath, the CUDA kernels related to those functions will be launched with the value of alpha and/or beta. Therefore if they were allocated on the heap, they can be freed just after the return of the call even though the kernel launch is asynchronous. When the pointer mode is set to CUBLAS_POINTER_MODE_DEVICE, alpha and/or beta must be accessible on the device and their values should not be modified until the kernel is done. Note that since cudaFree() does an implicit cudaDeviceSynchronize(), cudaFree() can still be called on alpha and/or beta just after the call but it would defeat the purpose of using this pointer mode in that case. For the functions of the second category, when the pointer mode is set to CUBLAS_POINTER_MODE_HOST, these functions block the CPU, until the GPU has completed its computation and the results have been copied back to the Host. When the pointer mode is set to CUBLAS_POINTER_MODE_DEVICE, these functions return immediately. In this case, similar to matrix and vector results, the scalar result is ready only when execution of the routine on the GPU has completed. This requires proper synchronization in order to read the result from the host. In either case, the pointer mode CUBLAS_POINTER_MODE_DEVICE allows the library functions to ex- ecute completely asynchronously from the Host even when alpha and/or beta are generated by a previous kernel. For example, this situation can arise when iterative methods for solution of linear systems and eigenvalue problems are implemented using the cuBLAS library. 4.1.6. Parallelism with Streams If the application uses the results computed by multiple independent tasks, CUDA™ streams can be used to overlap the computation performed in these tasks. The application can conceptually associate each stream with each task. In order to achieve the over- lap of computation between the tasks, the user should create CUDA™ streams using the function cudaStreamCreate() and set the stream to be used by each individual cuBLAS library routine by calling cublasSetStream() just before calling the actual cuBLAS routine. Note that cublasSetStream() resets the user-provided workspace to the default workspace pool; see cublasSetWorkspace(). Then, the computation performed in separate streams would be overlapped automatically when possible on the GPU. This approach is especially useful when the computation performed by a single task is relatively small and is not enough to fill the GPU with work. We recommend using the new cuBLAS API with scalar parameters and results passed by reference in the device memory to achieve maximum overlap of the computation when using streams. A particular application of streams, batching of multiple small kernels, is described in the following section. 4.1.7. Batching Kernels In this section, we explain how to use streams to batch the execution of small kernels. For instance, suppose that we have an application where we need to make many small independent matrix-matrix multiplications with dense matrices. It is clear that even with millions of small independent matrices we will not be able to achieve the same GFLOPS rate as with a one large matrix. For example, a single n ? n large matrix-matrix multiplication performs n? operations for n? input size, while 1024 ? ? n small matrix-matrix multiplications perform 1024 ( n )3 = ?3 operations for the same input size. However, it is also clear that we can achieve a 4.1. General Description 13 cuBLAS, Release 12.3 significantly better performance with many small independent matrices compared with a single small matrix. The architecture family of GPUs allows us to execute multiple kernels simultaneously. Hence, in or- der to batch the execution of independent kernels, we can run each of them in a separate stream. In particular, in the above example we could create 1024 CUDA™ streams using the function cud- aStreamCreate(), then preface each call to cublas<t>gemm() with a call to cublasSetStream() with a different stream for each of the matrix-matrix multiplications (note that cublasSetStream() resets user-provided workspace to the default workspace pool, see cublasSetWorkspace()). This will ensure that when possible the different computations will be executed concurrently. Although the user can create many streams, in practice it is not possible to have more than 32 concurrent kernels executing at the same time. 4.1.8. Cache Configuration On some devices, L1 cache and shared memory use the same hardware resources. The cache config- uration can be set directly with the CUDA Runtime function cudaDeviceSetCacheConfig. The cache configuration can also be set specifically for some functions using the routine cudaFuncSetCacheCon- fig. Please refer to the CUDA Runtime API documentation for details about the cache configuration settings. Because switching from one configuration to another can affect kernels concurrency, the cuBLAS Library does not set any cache configuration preference and relies on the current setting. However, some cuBLAS routines, especially Level-3 routines, rely heavily on shared memory. Thus the cache preference setting might affect adversely their performance. 4.1.9. Static Library Support The cuBLAS Library is also delivered in a static form as libcublas_static.a on Linux. The static cuBLAS library and all other static math libraries depend on a common thread abstraction layer library called libculibos.a. For example, on Linux, to compile a small application using cuBLAS, against the dynamic library, the following command can be used: nvcc myCublasApp.c -lcublas -o myCublasApp Whereas to compile against the static cuBLAS library, the following command must be used: nvcc myCublasApp.c -lcublas_static -lculibos -o myCublasApp It is also possible to use the native Host C++ compiler. Depending on the Host operating system, some additional libraries like pthread or dl might be needed on the linking line. The following command on Linux is suggested : g++ myCublasApp.c -lcublas_static -lculibos -lcudart_static -lpthread -ldl -I ‹><cuda-toolkit-path>?include -L <cuda-toolkit-path>?lib64 -o myCublasApp Note that in the latter case, the library cuda is not needed. The CUDA Runtime will try to open explicitly the cuda library if needed. In the case of a system which does not have the CUDA driver installed, this allows the application to gracefully manage this issue and potentially run if a CPU-only path is available. 14 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Starting with release 11.2, using the typed functions instead of the extension functions (cublas**Ex()) helps in reducing the binary size when linking to static cuBLAS Library. 4.1.10. GEMM Algorithms Numerical Behavior Some GEMM algorithms split the computation along the dimension K to increase the GPU occupancy, especially when the dimension K is large compared to dimensions M and N. When this type of algo- rithm is chosen by the cuBLAS heuristics or explicitly by the user, the results of each split is summed deterministically into the resulting matrix to get the final result. For the routines cublas<t>gemmEx and cublasGemmEx(), when the compute type is greater than the output type, the sum of the split chunks can potentially lead to some intermediate overflows thus producing a final resulting matrix with some overflows. Those overflows might not have occurred if all the dot products had been accumulated in the compute type before being converted at the end in the output type. This computation side-effect can be easily exposed when the computeType is CUDA_R_32F and Atype, Btype and Ctype are in CUDA_R_16F. This behavior can be controlled us- ing the compute precision mode CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION with cublasSetMathMode() 4.1.11. Tensor Core Usage Tensor cores were first introduced with Volta GPUs (compute capability 7.0 and above) and significantly accelerate matrix multiplications. Starting with cuBLAS version 11.0.0, the library will automatically make use of Tensor Core capabilities wherever possible, unless they are explicitly disabled by selecting pedantic compute modes in cuBLAS (see cublasSetMathMode(), cublasMath_t). It should be noted that the library will pick a Tensor Core enabled implementation wherever it deter- mines that it would provide the best performance. Starting with cuBLAS version 11.0.0 there are no longer any restriction on matrix dimensions and memory alignments to use Tensor Cores. However, the best performance when using Tensor Cores can be achieved when the matrix dimensions and pointers meet certain memory alignment requirements. Specifically, all of the following conditions must be satisfied to get the most performance out of Tensor Cores: ? m % 8 == 0 ? k % 8 == 0 ? op_B == CUBLAS_OP_N || n%8 == 0 ? intptr_t(A) % 16 == 0 ? intptr_t(B) % 16 == 0 ? intptr_t(C) % 16 == 0 ? intptr_t(A+lda) % 16 == 0 ? intptr_t(B+ldb) % 16 == 0 ? intptr_t(C+ldc) % 16 == 0 4.1. General Description 15 cuBLAS, Release 12.3 4.1.12. CUDA Graphs Support cuBLAS routines can be captured in CUDA Graph stream capture without restrictions in most situa- tions. The exception are routines that output results into host buffers (e.g. cublas<t>dot while pointer mode CUBLAS_POINTER_MODE_HOST is configured), as it enforces synchronization. For input coefficients (such as alpha, beta) behavior depends on the pointer mode setting: ? In the case of CUBLAS(LT)_POINTER_MODE_HOST, coefficient values are captured in the graph. ? In the case of pointer modes with device pointers, coefficient value is accessed using the device pointer at the time of graph execution. Note: Every time cuBLAS routines are captured in a new CUDA Graph, cuBLAS will allocate workspace memory on the device. This memory is only freed when the cuBLAS handle used during capture is deleted. To avoid this, use the cublasSetWorkspace() function to provide user-owned workspace mem- ory. 4.1.13. 64-bit Integer Interface cuBLAS version 12 introduced 64-bit integer capable functions. Each 64-bit integer function is equiv- alent to a 32-bit integer function with the following changes: ? The function name has _64 suffix. ? The dimension (problem size) data type changed from int to int64_t. Examples of dimension: m, n, and k. ? The leading dimension data type changed from int to int64_t. Examples of leading dimension: lda, ldb, and ldc. ? The vector increment data type changed from int to int64_t. Examples of vector increment: incx and incy. For example, consider the following 32-bit integer functions: cublasStatus_t cublasSetMatrix(int rows, int cols, int elemSize, const void *A, int ‹>lda, void *B, int ldb); cublasStatus_t cublasIsamax(cublasHandle_t handle, int n, const float *x, int incx, ‹>int *result); cublasStatus_t cublasSsyr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const ‹>float *alpha, const float *x, int incx, float *A, int lda); The equivalent 64-bit integer functions are: cublasStatus_t cublasSetMatrix_64(int64_t rows, int64_t cols, int64_t elemSize, const ‹>void *A, int64_t lda, void *B, int64_t ldb); cublasStatus_t cublasIsamax_64(cublasHandle_t handle, int64_t n, const float *x, ‹>int64_t incx, int64_t *result); cublasStatus_t cublasSsyr_64(cublasHandle_t handle, cublasFillMode_t uplo, int64_t n, ‹>const float *alpha, const float *x, int64_t incx, float *A, int64_t lda); 16 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Not every function has a 64-bit integer equivalent. For instance, cublasSetMathMode() doesn’t have any arguments that could meaningfully be int64_t. For documentation brevity, the 64-bit integer APIs are not explicitly listed, but only mentioned that they exist for the relevant functions. 4.2. cuBLAS Datatypes Reference 4.2.1. cublasHandle_t The cublasHandle_t type is a pointer type to an opaque structure holding the cuBLAS library context. The cuBLAS library context must be initialized using cublasCreate() and the returned handle must be passed to all subsequent library function calls. The context should be destroyed at the end using cublasDestroy(). 4.2.2. cublasStatus_t The type is used for function status returns. All cuBLAS library functions return their status, which can have the following values. 4.2. cuBLAS Datatypes Reference 17 cuBLAS, Release 12.3 Value Meaning CUBLAS_STTAhTeUSo_pSeUraCtCioEnSScompleted successfully. CUBLAS_STTAhTeUSc_uNBOLTA_SINliIbTraIrAyLwIZaEsDnot initialized. This is usually caused by the lack of a prior cublasCreate() call, an error in the CUDA Runtime API called by the cuBLAS routine, or an error in the hardware setup. To correct: call cublasCreate() before the function call; and check that the hardware, an appropriate version of the driver, and the cuBLAS library are correctly installed. CUBLAS_STRAeTsUoSu_rAcLeLaOllCo_cFaAtiIoLnEfDailed inside the cuBLAS library. This is usually caused by a cud- aMalloc() failure. To correct: prior to the function call, deallocate previously allocated memory as much as possible. CUBLAS_STAATnUuSn_sIuNpVpAoLrtIeDd_vVaAlLuUeEor parameter was passed to the function (a negative vector size, for example). To correct: ensure that all the parameters being passed have valid values. CUBLAS_STTAhTeUSfu_nAcRtCioHn_MrIeqSuMiAreTsCHa feature absent from the device architecture; usually caused by compute capability lower than 5.0. To correct: compile and run the application on a device with appropriate compute capa- bility. CUBLAS_STAATnUaSc_cMeAsPsPtIoNGGP_UERmROeRmory space failed, which is usually caused by a failure to bind a texture. To correct: before the function call, unbind any previously bound textures. CUBLAS_STTAhTeUSG_PEUXpErCoUgTrIaOmNf_aFilAeIdLtEoDexecute. This is often caused by a launch failure of the kernel on the GPU, which can be caused by multiple reasons. To correct: check that the hardware, an appropriate version of the driver, and the cuBLAS library are correctly installed. CUBLAS_STAATnUiSn_teIrNnTaEl RcNuABLL_AESRRoOpReration failed. This error is usually caused by a cudaMem- cpyAsync() failure. To correct: check that the hardware, an appropriate version of the driver, and the cuBLAS library are correctly installed. Also, check that the memory passed as a parameter to the routine is not being deallocated prior to the routine’s completion. CUBLAS_STTAhTeUSfu_nNcOtTio_nSaUlPitPyOrReTqEuDested is not supported. CUBLAS_STTAhTeUSfu_nLcItCioEnNaSlEit_yErReRqOuRested requires some license and an error was detected when try- ing to check the current licensing. This error can happen if the license is not present or is expired or if the environment variable NVIDIA_LICENSE_FILE is not set properly. 18 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.2.3. cublasOperation_t The cublasOperation_t type indicates which operation needs to be performed with the dense matrix. Its values correspond to Fortran characters ‘N’ or ‘n’ (non-transpose), ‘T’ or ‘t’ (transpose) and ‘C’ or ‘c’ (conjugate transpose) that are often used as parameters to legacy BLAS implementations. Value CUBLAS_OP_N CUBLAS_OP_T CUBLAS_OP_C Meaning The non-transpose operation is selected. The transpose operation is selected. The conjugate transpose operation is selected. 4.2.4. cublasFillMode_t The type indicates which part (lower or upper) of the dense matrix was filled and consequently should be used by the function. Its values correspond to Fortran characters L or l (lower) and U or u (upper) that are often used as parameters to legacy BLAS implementations. Value CUBLAS_FILL_MODE_LOWER CUBLAS_FILL_MODE_UPPER CUBLAS_FILL_MODE_FULL Meaning The lower part of the matrix is filled. The upper part of the matrix is filled. The full matrix is filled. 4.2.5. cublasDiagType_t The type indicates whether the main diagonal of the dense matrix is unity and consequently should not be touched or modified by the function. Its values correspond to Fortran characters ‘N’ or ‘n’ (non-unit) and ‘U’ or ‘u’ (unit) that are often used as parameters to legacy BLAS implementations. Value CUBLAS_DIAG_NON_UNIT CUBLAS_DIAG_UNIT Meaning The matrix diagonal has non-unit elements. The matrix diagonal has unit elements. 4.2. cuBLAS Datatypes Reference 19 cuBLAS, Release 12.3 4.2.6. cublasSideMode_t The type indicates whether the dense matrix is on the left or right side in the matrix equation solved by a particular function. Its values correspond to Fortran characters ‘L’ or ‘l’ (left) and ‘R’ or ‘r’ (right) that are often used as parameters to legacy BLAS implementations. Value CUBLAS_SIDE_LEFT CUBLAS_SIDE_RIGHT Meaning The matrix is on the left side in the equation. The matrix is on the right side in the equation. 4.2.7. cublasPointerMode_t The cublasPointerMode_t type indicates whether the scalar values are passed by reference on the host or device. It is important to point out that if several scalar values are present in the function call, all of them must conform to the same single pointer mode. The pointer mode can be set and retrieved using cublasSetPointerMode() and cublasGetPointerMode() routines, respectively. Value CUBLAS_POINTER_MODE_HOST CUBLAS_POINTER_MODE_DEVICE Meaning The scalars are passed by reference on the host. The scalars are passed by reference on the device. 4.2.8. cublasAtomicsMode_t The type indicates whether cuBLAS routines which has an alternate implementation using atomics can be used. The atomics mode can be set and queried using cublasSetAtomicsMode() and cublasGe- tAtomicsMode() and routines, respectively. Value CUBLAS_ATOMICS_NOT_ALLOWED CUBLAS_ATOMICS_ALLOWED Meaning The usage of atomics is not allowed. The usage of atomics is allowed. 4.2.9. cublasGemmAlgo_t cublasGemmAlgo_t type is an enumerant to specify the algorithm for matrix-matrix multiplication on GPU architectures up to sm_75. On sm_80 and newer GPU architectures, this enumarant has no effect. cuBLAS has the following algorithm options: 20 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Value Meaning CUBLAS_GEMM_DEFAULTApply Heuristics to select the GEMM algorithm CUBLAS_GEMM_ALGO0 to CUBLAS_GEMM_ALGO23 Explicitly choose an Algorithm [0,23]. Note: Doesn’t have effect on NVIDIA Ampere architecture GPUs and newer. CUBLAS_GEMM_DEFAULTT_hTiEsNmSOoRd_eOiPs[dDeEpPrReEcaCtAeTdEDan] d will be removed in a future release. Apply Heuristics to select the GEMM algorithm, while allowing use of reduced pre- cision CUBLAS_COMPUTE_32F_FAST_16F kernels (for backward compati- bility). CUBLAS_GEMM_ALGO0_TTEhNoSsOeRv_aOluPes are deprecated and will be removed in a future release. Explic- to itly choose a Tensor core GEMM Algorithm [0,15]. Allows use of reduced CUBLAS_GEMM_ALGO15_pTrEeNcSisOioRn_OCPU[DBLEAPSR_ECOATMEPDU]TE_32F_FAST_16F kernels (for backward com- patibility). Note: Doesn’t have effect on NVIDIA Ampere architecture GPUs and newer. 4.2.10. cublasMath_t cublasMath_t enumerate type is used in cublasSetMathMode() to choose compute precision modes as defined in the following table. Since this setting does not directly control the use of Tensor Cores, the mode CUBLAS_TENSOR_OP_MATH is being deprecated, and will be removed in a future release. Value Meaning CUBLAS_DEFAULTT_hMiAsTisHthe default and highest-performance mode that uses compute and inter- mediate storage precisions with at least the same number of mantissa and expo- nent bits as requested. Tensor Cores will be used whenever possible. CUBLAS_PEDANTITCh_iMsAmTHode uses the prescribed precision and standardized arithmetic for all phases of calculations and is primarily intended for numerical robustness stud- ies, testing, and debugging. This mode might not be as performant as the other modes. CUBLAS_TF32_TEENnSaObRle_OaPc_cMelAeTraHtion of single-precision routines using TF32 tensor cores. CUBLAS_MATH_DIFSoArLcLesOWa_nRyErDeUdCuEctDi_onPsREdCuIriSnIgOmN_aRtrEixDUmCuTlItiOpNlications to use the accumulator type (that is, compute type) and not the output type in case of mixed precision routines where output type precision is less than the compute type precision. This is a flag that can be set (using a bitwise or operation) alongside any of the other values. CUBLAS_TENSOR_TOhPi_sMmAoTdHe is deprecated and will be removed in a future release. Allows the library [DEPRECATED] to use Tensor Core operations whenever possible. For single precision GEMM rou- tines cuBLAS will use the CUBLAS_COMPUTE_32F_FAST_16F compute type. 4.2. cuBLAS Datatypes Reference 21 cuBLAS, Release 12.3 4.2.11. cublasComputeType_t cublasComputeType_t enumerate type is used in cublasGemmEx() and cublasLtMatmul() (including all batched and strided batched variants) to choose compute precision modes as defined below. Value Meaning CUBLAS_COMPTUhTisEi_s1t6hFe default and highest-performance mode for 16-bit half precision floating point and all compute and intermediate storage precisions with at least 16-bit half precision. Tensor Cores will be used whenever possible. CUBLAS_COMPTUhTisE_m1o6dFe_PuEsDeAsN1T6I-Cbit half precision floating point standardized arithmetic for all phases of calculations and is primarily intended for numerical robustness studies, test- ing, and debugging. This mode might not be as performant as the other modes since it disables use of tensor cores. CUBLAS_COMPTUhTisEi_s3t2hFe default 32-bit single precision floating point and uses compute and inter- mediate storage precisions of at least 32-bits. CUBLAS_COMPUUsTeEs_3322-Fb_itPsEinDgAlNeTpIrCecision floatin point arithmetic for all phases of calculations and also disables algorithmic optimizations such as Gaussian complexity reduction (3M). CUBLAS_COMPAUllToEw_s3t2hFe_liFbAraSrTy_t1o6uFse Tensor Cores with automatic down-conversion and 16-bit half- precision compute for 32-bit input and output matrices. CUBLAS_COMPAUllToEw_s3t2hFe_lFibArSaTry_1t6oBuFse Tensor Cores with automatic down-convesion and bfloat16 compute for 32-bit input and output matrices. See Alternate Floating Point section for more details on bfloat16. CUBLAS_COMPAUllToEw_s3t2hFe_lFibArSarTy_tToF3u2se Tensor Cores with TF32 compute for 32-bit input and output matrices. See Alternate Floating Point section for more details on TF32 compute. CUBLAS_COMPTUhTisEi_s6t4hFe default 64-bit double precision floating point and uses compute and inter- mediate storage precisions of at least 64-bits. CUBLAS_COMPUUsTeEs_6644-bFi_tPdEoDuAbNleTIpCrecision floatin point arithmetic for all phases of calculations and also disables algorithmic optimizations such as Gaussian complexity reduction (3M). CUBLAS_COMPTUhTisEi_s3t2hIe default 32-bit integer mode and uses compute and intermediate storage precisions of at least 32-bits. CUBLAS_COMPUUsTeEs_3322-bIi_tPinEtDeAgNeTrIaCrithmetic for all phases of calculations. Note: Setting the environment variable NVIDIA_TF32_OVERRIDE = 0 will override any defaults or programmatic configuration of NVIDIA libraries, and consequently, cuBLAS will not accelerate FP32 computations with TF32 tensor cores. 22 Chapter 4. Using the cuBLAS API 4.3. CUDA Datatypes Reference cuBLAS, Release 12.3 The chapter describes types shared by multiple CUDA Libraries and defined in the header file library_types.h. 4.3.1. cudaDataType_t The cudaDataType_t type is an enumerant to specify the data precision. It is used when the data reference does not carry the type itself (e.g void *) For example, it is used in the routine cublasSgemmEx(). Value CUDA_R_16F CUDA_C_16F Meaning the data type is a 16-bit real half precision floating-point the data type is a 32-bit structure comprised of two half precision floating-points representing a complex number. CUDA_R_16BF the data type is a 16-bit real bfloat16 floating-point CUDA_C_16BF the data type is a 32-bit structure comprised of two bfloat16 floating-points repre- senting a complex number. CUDA_R_32F CUDA_C_32F CUDA_R_64F CUDA_C_64F CUDA_R_8I CUDA_C_8I CUDA_R_8U CUDA_C_8U CUDA_R_32I CUDA_C_32I the data type is a 32-bit real single precision floating-point the data type is a 64-bit structure comprised of two single precision floating-points representing a complex number. the data type is a 64-bit real double precision floating-point the data type is a 128-bit structure comprised of two double precision floating-points representing a complex number. the data type is a 8-bit real signed integer the data type is a 16-bit structure comprised of two 8-bit signed integers represent- ing a complex number. the data type is a 8-bit real unsigned integer the data type is a 16-bit structure comprised of two 8-bit unsigned integers repre- senting a complex number. the data type is a 32-bit real signed integer the data type is a 64-bit structure comprised of two 32-bit signed integers repre- senting a complex number. CUDA_R_8F_E4tMh3e data type is an 8-bit real floating point in E4M3 format CUDA_R_8F_E5tMh2e data type is an 8-bit real floating point in E5M2 format 4.3. CUDA Datatypes Reference 23 cuBLAS, Release 12.3 4.3.2. libraryPropertyType_t The libraryPropertyType_t is used as a parameter to specify which property is requested when using the routine cublasGetProperty() Value MAJOR_VERSION MINOR_VERSION PATCH_LEVEL Meaning enumerant to query the major version enumerant to query the minor version number to identify the patch level 4.4. cuBLAS Helper Function Reference 4.4.1. cublasCreate() cublasStatus_t cublasCreate(cublasHandle_t *handle) This function initializes the cuBLAS library and creates a handle to an opaque structure holding the cuBLAS library context. It allocates hardware resources on the host and device and must be called prior to making any other cuBLAS library calls. The cuBLAS library context is tied to the current CUDA device. To use the library on multiple devices, one cuBLAS handle needs to be created for each device. Furthermore, for a given device, multiple cuBLAS handles with different configurations can be created. Because cublasCreate() allocates some internal resources and the release of those resources by calling cublasDestroy() will implicitly call cudaDeviceSynchronize(), it is recommended to minimize the number of times these functions are called. For multi-threaded applications that use the same device from different threads, the recommended programming model is to create one cuBLAS handle per thread and use that cuBLAS handle for the entire life of the thread. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_INVALID_VALUE Meaning the initialization succeeded the CUDA™ Runtime initialization failed the resources could not be allocated handle == NULL 24 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.4.2. cublasDestroy() cublasStatus_t cublasDestroy(cublasHandle_t handle) This function releases hardware resources used by the cuBLAS library. This function is usually the last call with a particular handle to the cuBLAS library. Because cublasCreate() allocates some internal resources and the release of those resources by calling cublasDestroy() will implicitly call cudaDe- viceSynchronize(), it is recommended to minimize the number of times these functions are called. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED Meaning the shut down succeeded the library was not initialized 4.4.3. cublasGetVersion() cublasStatus_t cublasGetVersion(cublasHandle_t handle, int *version) This function returns the version number of the cuBLAS library. Return Value CUBLAS_STATUS_SUCCESS Meaning the operation completed successfully CUBLAS_STATUS_INVALID_VALUEthe provided storage for library version number is not initialized (NULL) Note: This function can be safely called with the handle set to NULL. This allows users to get the version of the library without a handle. Another way to do this is with cublasGetProperty(). 4.4.4. cublasGetProperty() cublasStatus_t cublasGetProperty(libraryPropertyType type, int *value) This function returns the value of the requested property in memory pointed to by value. Refer to libraryPropertyType for supported types. 4.4. cuBLAS Helper Function Reference 25 cuBLAS, Release 12.3 Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully Invalid type value ? If invalid type value or ? value == NULL 4.4.5. cublasGetStatusName() const char* cublasGetStatusName(cublasStatus_t status) This function returns the string representation of a given status. Return Value Meaning NULL-terminated string The string representation of the status 4.4.6. cublasGetStatusString() const char* cublasGetStatusString(cublasStatus_t status) This function returns the description string for a given status. Return Value Meaning NULL-terminated string The description of the status 4.4.7. cublasSetStream() cublasStatus_t cublasSetStream(cublasHandle_t handle, cudaStream_t streamId) This function sets the cuBLAS library stream, which will be used to execute all subsequent calls to the cuBLAS library functions. If the cuBLAS library stream is not set, all kernels use the default NULL stream. In particular, this routine can be used to change the stream between kernel launches and then to reset the cuBLAS library stream back to NULL. Additionally this function unconditionally resets the cuBLAS library workspace back to the default workspace pool (see cublasSetWorkspace()). Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED Meaning the stream was set successfully the library was not initialized 26 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.4.8. cublasSetWorkspace() cublasStatus_t cublasSetWorkspace(cublasHandle_t handle, void *workspace, size_t ‹>workspaceSizeInBytes) This function sets the cuBLAS library workspace to a user-owned device buffer, which will be used to execute all subsequent calls to the cuBLAS library functions (on the currently set stream). If the cuBLAS library workspace is not set, all kernels will use the default workspace pool allocated during the cuBLAS context creation. In particular, this routine can be used to change the workspace be- tween kernel launches. The workspace pointer has to be aligned to at least 256 bytes, otherwise CUBLAS_STATUS_INVALID_VALUE error is returned. The cublasSetStream() function unconditionally resets the cuBLAS library workspace back to the default workspace pool. Too small workspace- SizeInBytes may cause some routines to fail with CUBLAS_STATUS_ALLOC_FAILED error returned or cause large regressions in performance. Workspace size equal to or larger than 16KiB is enough to prevent CUBLAS_STATUS_ALLOC_FAILED error, while a larger workspace can provide performance benefits for some routines. The table below shows the recommended size of user-provided workspace. This is based on the cuBLAS default workspace pool size which is GPU architecture dependent. GPU Architecture NVIDIA Hopper Architecture Other Recommended workspace size 32 MiB 4 MiB The possible error values returned by this function and their meanings are listed below. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the stream was set successfully the library was not initialized the workspace pointer wasn’t aligned to at least 256 bytes 4.4.9. cublasGetStream() cublasStatus_t cublasGetStream(cublasHandle_t handle, cudaStream_t *streamId) This function gets the cuBLAS library stream, which is being used to execute all calls to the cuBLAS library functions. If the cuBLAS library stream is not set, all kernels use the default NULL stream. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the stream was returned successfully the library was not initialized streamId == NULL 4.4. cuBLAS Helper Function Reference 27 cuBLAS, Release 12.3 4.4.10. cublasGetPointerMode() cublasStatus_t cublasGetPointerMode(cublasHandle_t handle, cublasPointerMode_t *mode) This function obtains the pointer mode used by the cuBLAS library. Please see the section on the cublasPointerMode_t type for more details. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the pointer mode was obtained successfully the library was not initialized mode == NULL 4.4.11. cublasSetPointerMode() cublasStatus_t cublasSetPointerMode(cublasHandle_t handle, cublasPointerMode_t mode) This function sets the pointer mode used by the cuBLAS library. The default is for the values to be passed by reference on the host. Please see the section on the cublasPointerMode_t type for more details. Return Value CUBLAS_STATUS_SUCCESS Meaning the pointer mode was set successfully CUBLAS_STATUS_NOT_INITIALItZhEeDlibrary was not initialized CUBLAS_STATUS_INVALID_VALUmEode is not CUBLAS_POINTER_MODE_HOST or CUBLAS_POINTER_MODE_DEVICE 4.4.12. cublasSetVector() cublasStatus_t cublasSetVector(int n, int elemSize, const void *x, int incx, void *y, int incy) This function supports the 64-bit Integer Interface. This function copies n elements from a vector x in host memory space to a vector y in GPU memory space. Elements in both vectors are assumed to have a size of elemSize bytes. The storage spacing between consecutive elements is given by incx for the source vector x and by incy for the destination vector y. Since column-major format for two-dimensional matrices is assumed, if a vector is part of a matrix, a vector increment equal to 1 accesses a (partial) column of that matrix. Similarly, using an increment equal to the leading dimension of the matrix results in accesses to a (partial) row of that matrix. 28 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters incx, incy, elemSize<=0 there was an error accessing GPU memory 4.4.13. cublasGetVector() cublasStatus_t cublasGetVector(int n, int elemSize, const void *x, int incx, void *y, int incy) This function supports the 64-bit Integer Interface. This function copies n elements from a vector x in GPU memory space to a vector y in host memory space. Elements in both vectors are assumed to have a size of elemSize bytes. The storage spacing between consecutive elements is given by incx for the source vector and incy for the destination vector y. Since column-major format for two-dimensional matrices is assumed, if a vector is part of a matrix, a vector increment equal to 1 accesses a (partial) column of that matrix. Similarly, using an increment equal to the leading dimension of the matrix results in accesses to a (partial) row of that matrix. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters incx, incy, elemSize<=0 there was an error accessing GPU memory 4.4.14. cublasSetMatrix() cublasStatus_t cublasSetMatrix(int rows, int cols, int elemSize, const void *A, int lda, void *B, int ldb) This function supports the 64-bit Integer Interface. This function copies a tile of rows x cols elements from a matrix A in host memory space to a matrix B in GPU memory space. It is assumed that each element requires storage of elemSize bytes and that both matrices are stored in column-major format, with the leading dimension of the source matrix A and destination matrix B given in lda and ldb, respectively. The leading dimension indicates the number of rows of the allocated matrix, even if only a submatrix of it is being used. 4.4. cuBLAS Helper Function Reference 29 cuBLAS, Release 12.3 Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters rows, cols<0 or elemSize, lda, ldb<=0 there was an error accessing GPU memory 4.4.15. cublasGetMatrix() cublasStatus_t cublasGetMatrix(int rows, int cols, int elemSize, const void *A, int lda, void *B, int ldb) This function supports the 64-bit Integer Interface. This function copies a tile of rows x cols elements from a matrix A in GPU memory space to a matrix B in host memory space. It is assumed that each element requires storage of elemSize bytes and that both matrices are stored in column-major format, with the leading dimension of the source matrix A and destination matrix B given in lda and ldb, respectively. The leading dimension indicates the number of rows of the allocated matrix, even if only a submatrix of it is being used. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters rows, cols<0 or elemSize, lda, ldb<=0 there was an error accessing GPU memory 4.4.16. cublasSetVectorAsync() cublasStatus_t cublasSetVectorAsync(int n, int elemSize, const void *hostPtr, int incx, void *devicePtr, int incy, cudaStream_t stream) This function supports the 64-bit Integer Interface. This function has the same functionality as cublasSetVector(), with the exception that the data transfer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters incx, incy, elemSize<=0 there was an error accessing GPU memory 30 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.4.17. cublasGetVectorAsync() cublasStatus_t cublasGetVectorAsync(int n, int elemSize, const void *devicePtr, int incx, void *hostPtr, int incy, cudaStream_t stream) This function supports the 64-bit Integer Interface. This function has the same functionality as cublasGetVector(), with the exception that the data trans- fer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters incx, incy, elemSize<=0 there was an error accessing GPU memory 4.4.18. cublasSetMatrixAsync() cublasStatus_t cublasSetMatrixAsync(int rows, int cols, int elemSize, const void *A, int lda, void *B, int ldb, cudaStream_t stream) This function supports the 64-bit Integer Interface. This function has the same functionality as cublasSetMatrix(), with the exception that the data transfer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters rows, cols<0 or elemSize, lda, ldb<=0 there was an error accessing GPU memory 4.4.19. cublasGetMatrixAsync() cublasStatus_t cublasGetMatrixAsync(int rows, int cols, int elemSize, const void *A, int lda, void *B, int ldb, cudaStream_t stream) This function supports the 64-bit Integer Interface. This function has the same functionality as cublasGetMatrix(), with the exception that the data trans- fer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter. 4.4. cuBLAS Helper Function Reference 31 cuBLAS, Release 12.3 Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_MAPPING_ERROR Meaning the operation completed successfully the parameters rows, cols<0 or elemSize, lda, ldb<=0 there was an error accessing GPU memory 4.4.20. cublasSetAtomicsMode() cublasStatus_t cublasSetAtomicsMode(cublasHandlet handle, cublasAtomicsMode_t mode) Some routines like cublas<t>symv and cublas<t>hemv have an alternate implementation that use atomics to cumulate results. This implementation is generally significantly faster but can generate results that are not strictly identical from one run to the others. Mathematically, those different re- sults are not significant but when debugging those differences can be prejudicial. This function allows or disallows the usage of atomics in the cuBLAS library for all routines which have an alternate implementation. When not explicitly specified in the documentation of any cuBLAS routine, it means that this routine does not have an alternate implementation that use atomics. When atomics mode is disabled, each cuBLAS routine should produce the same results from one run to the other when called with identical parameters on the same Hardware. The default atomics mode of default initialized cublasHandle_t object is CUBLAS_ATOMICS_NOT_ALLOWED. Please see the section on the type for more details. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED Meaning the atomics mode was set successfully the library was not initialized 4.4.21. cublasGetAtomicsMode() cublasStatus_t cublasGetAtomicsMode(cublasHandle_t handle, cublasAtomicsMode_t *mode) This function queries the atomic mode of a specific cuBLAS context. The default atomics mode of default initialized cublasHandle_t object is CUBLAS_ATOMICS_NOT_ALLOWED. Please see the section on the type for more details. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the atomics mode was queried successfully the library was not initialized the argument mode is a NULL pointer 32 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.4.22. cublasSetMathMode() cublasStatus_t cublasSetMathMode(cublasHandle_t handle, cublasMath_t mode) The cublasSetMathMode() function enables you to choose the compute precision modes as defined by cublasMath_t. Users are allowed to set the compute precision mode as a logical combination of them (except the deprecated CUBLAS_TENSOR_OP_MATH). For example, cublasSetMathMode(handle, CUBLAS_DEFAULT_MATH | CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION). Please note that the default math mode is CUBLAS_DEFAULT_MATH. For matrix and compute precisions allowed for cublasGemmEx() and cublasLtMatmul() APIs and their strided variants please refer to: cublasGemmEx() , cublasGemmBatchedEx(), cublasGemmStrided- BatchedEx(), and cublasLtMatmul(). Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_INITIALIZED Meaning the math mode was set successfully. an invalid value for mode was specified. the library was not initialized. 4.4.23. cublasGetMathMode() cublasStatus_t cublasGetMathMode(cublasHandle_t handle, cublasMath_t *mode) This function returns the math mode used by the library routines. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_INITIALIZED Meaning the math type was returned successfully. if mode is NULL. the library was not initialized. 4.4.24. cublasSetSmCountTarget() cublasStatus_t cublasSetSmCountTarget(cublasHandle_t handle, int smCountTarget) The cublasSetSmCountTarget() function allows overriding the number of multiprocessors available to the library during kernels execution. This option can be used to improve the library performance when cuBLAS routines are known to run concurrently with other work on different CUDA streams. E.g. a NVIDIA A100 GPU has 108 SM and there is a concurrent kenrel running with grid size of 8, one can use cublasSetSmCountTarget() with value 100 to override the library heuristics to optimize for running on 100 multiprocessors. When set to 0 the library returns to its default behavior. The input value should not exceed the device’s multiprocessor count, which can be obtained using cudaDeviceGetAttribute. Negative values are not accepted. 4.4. cuBLAS Helper Function Reference 33 cuBLAS, Release 12.3 The user must ensure thread safety when modifying the library handle with this routine similar to when using cublasSetStream(), etc. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_INITIALIZED Meaning SM count target was set successfully. the value of smCountTarget outside of the allowed range. the library was not initialized. 4.4.25. cublasGetSmCountTarget() cublasStatus_t cublasGetSmCountTarget(cublasHandle_t handle, int *smCountTarget) This function obtains the value previously programmed to the library handle. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_INITIALIZED Meaning SM count target was set successfully. smCountTarget is NULL. the library was not initialized. 4.4.26. cublasLoggerConfigure() cublasStatus_t cublasLoggerConfigure( int logIsOn, int logToStdOut, int logToStdErr, const char* logFileName) This function configures logging during runtime. Besides this type of configuration, it is possible to configure logging with special environment variables which will be checked by libcublas: ? CUBLAS_LOGINFO_DBG - Setup env. variable to “1” means turn on logging (by default logging is off). ? CUBLAS_LOGDEST_DBG - Setup env. variable encodes how to log. “stdout”, “stderr” means to output log messages to stdout or stderr, respectively. In the other case, its specifies “filename” of file. Parameters logIsOn Input. Turn on/off logging completely. By default is off, but is turned on by calling cublasSet- LoggerCallback() to user defined callback function. logToStdOut Input. Turn on/off logging to standard output I/O stream. By default is off. logToStdErr Input. Turn on/off logging to standard error I/O stream. By default is off. 34 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 logFileName Input. Turn on/off logging to file in filesystem specified by it’s name. cublasLoggerConfig- ure() copies the content of logFileName. You should provide null pointer if you are not interested in this type of logging. Returns CUBLAS_STATUS_SUCCESS Success. 4.4.27. cublasGetLoggerCallback() cublasStatus_t cublasGetLoggerCallback( cublasLogCallback* userCallback) This function retrieves function pointer to previously installed custom user defined callback function via cublasSetLoggerCallback() or zero otherwise. Parameters userCallback Output. Pointer to user defined callback function. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully userCallback is NULL 4.4.28. cublasSetLoggerCallback() cublasStatus_t cublasSetLoggerCallback( cublasLogCallback userCallback) This function installs a custom user defined callback function via cublas C public API. Parameters userCallback Input. Pointer to user defined callback function. Returns CUBLAS_STATUS_SUCCESS Success. 4.5. cuBLAS Level-1 Function Reference In this chapter we describe the Level-1 Basic Linear Algebra Subprograms (BLAS1) functions that per- form scalar and vector based operations. We will use abbreviations <type> for type and <t> for the corresponding short type to make a more concise and clear presentation of the implemented func- tions. Unless otherwise specified <type> and <t> have the following meanings: 4.5. cuBLAS Level-1 Function Reference 35 cuBLAS, Release 12.3 <type> float double cuComplex cuDoubleComplex <t> ‘s’ or ‘S’ ‘d’ or ‘D’ ‘c’ or ‘C’ ‘z’ or ‘Z’ Meaning real single-precision real double-precision complex single-precision complex double-precision When the parameters and returned values of the function differ, which sometimes happens for com- plex input, the <t> can also have the following meanings Sc, Cs, Dz and Zd. The abbreviation Re( ) and Im( ) will stand for the real and imaginary part of a number, respectively. Since imaginary part of a real number does not exist, we will consider it to be zero and can usually simply discard it from the equation where it is being used. Also, the ?? will denote the complex conjugate of ? . In general throughout the documentation, the lower case Greek symbols ? and ? will denote scalars, lower case English letters in bold type x and y will denote vectors and capital English letters A , B and C will denote matrices. 4.5.1. cublasI<t>amax() cublasStatus_t cublasIsamax(cublasHandle_t handle, int n, const float *x, int incx, int *result) cublasStatus_t cublasIdamax(cublasHandle_t handle, int n, const double *x, int incx, int *result) cublasStatus_t cublasIcamax(cublasHandle_t handle, int n, const cuComplex *x, int incx, int *result) cublasStatus_t cublasIzamax(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, int *result) This function supports the 64-bit Integer Interface. This function finds the (smallest) index of the element of the maximum magnitude. Hence, the result is the first i such that Im (x[j]) + Re (x[j]) is maximum for i = 1, . . . , n and j = 1 +(i 1) incx . Notice that the last equation reflects 1-based indexing used for compatibility with Fortran. Param. handle n x incx result Memory device host or device In/out input input input input output Meaning handle to the cuBLAS library context. number of elements in the vector x. <type> vector with elements. stride between consecutive elements of x. the resulting index, which is 0 if n,incx<=0. The possible error values returned by this function and their meanings are listed below. 36 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized the reduction buffer could not be allocated the function failed to launch on the GPU result is NULL For references please refer to: isamax, idamax, icamax, izamax 4.5.2. cublasI<t>amin() cublasStatus_t cublasIsamin(cublasHandle_t handle, int n, const float *x, int incx, int *result) cublasStatus_t cublasIdamin(cublasHandle_t handle, int n, const double *x, int incx, int *result) cublasStatus_t cublasIcamin(cublasHandle_t handle, int n, const cuComplex *x, int incx, int *result) cublasStatus_t cublasIzamin(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, int *result) This function supports the 64-bit Integer Interface. This function finds the (smallest) index of the element of the minimum magnitude. Hence, the result is the first i such that Im (x[j]) + Re (x[j]) is minimum for i = 1, . . . , n and j = 1 + (i 1) incx Notice that the last equation reflects 1-based indexing used for compatibility with Fortran. Param. handle n x incx result Memory device host or device In/out input input input input output Meaning handle to the cuBLAS library context. number of elements in the vector x. <type> vector with elements. stride between consecutive elements of x. the resulting index, which is 0 if n,incx<=0. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized the reduction buffer could not be allocated the function failed to launch on the GPU result is NULL 4.5. cuBLAS Level-1 Function Reference 37 cuBLAS, Release 12.3 For references please refer to: isamin 4.5.3. cublas<t>asum() cublasStatus_t cublasSasum(cublasHandle_t handle, int n, const float *x, int incx, float *result) cublasStatus_t cublasDasum(cublasHandle_t handle, int n, const double *x, int incx, double *result) cublasStatus_t cublasScasum(cublasHandle_t handle, int n, const cuComplex *x, int incx, float *result) cublasStatus_t cublasDzasum(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, double *result) This function supports the 64-bit Integer Interface. This function computes the sum of the absolute values of the elements of vector x. Hence, the result n i=1 |Im (x[j])|+|Re (x[j])| where j = 1 +(i ? 1) ? incx . Notice that the last equation reflects 1-based indexing used for compatibility with Fortran. Param. handle n x incx result Memory device host or device In/out input input input input output Meaning handle to the cuBLAS library context. number of elements in the vector x. <type> vector with elements. stride between consecutive elements of x. the resulting index, which is 0.0 if n,incx<=0. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized the reduction buffer could not be allocated the function failed to launch on the GPU result is NULL For references please refer to: sasum, dasum, scasum, dzasum 38 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.5.4. cublas<t>axpy() cublasStatus_t cublasSaxpy(cublasHandle_t handle, int n, const float *alpha, const float *x, int incx, float *y, int incy) cublasStatus_t cublasDaxpy(cublasHandle_t handle, int n, const double *alpha, const double *x, int incx, double *y, int incy) cublasStatus_t cublasCaxpy(cublasHandle_t handle, int n, const cuComplex *alpha, const cuComplex *x, int incx, cuComplex *y, int incy) cublasStatus_t cublasZaxpy(cublasHandle_t handle, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function multiplies the vector x by the scalar ? and adds it to the vector y overwriting the latest vector with the result. Hence, the performed operation is y[j] = ? x[k] + y[j] for i = 1, . . . , n , k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle alpha n x incx y incy Memory host or device device device In/out input input input input input in/out input Meaning handle to the cuBLAS library context. <type> scalar used for multiplication. number of elements in the vector x and y. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: saxpy, daxpy, caxpy, zaxpy 4.5. cuBLAS Level-1 Function Reference 39 cuBLAS, Release 12.3 4.5.5. cublas<t>copy() cublasStatus_t cublasScopy(cublasHandle_t handle, int n, const float *x, int incx, float *y, int incy) cublasStatus_t cublasDcopy(cublasHandle_t handle, int n, const double *x, int incx, double *y, int incy) cublasStatus_t cublasCcopy(cublasHandle_t handle, int n, const cuComplex *x, int incx, cuComplex *y, int incy) cublasStatus_t cublasZcopy(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy) This function copies the vector x into the vector y. Hence, the performed operation is y[j] = x[k] for i = 1, . . . , n , k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle n x incx y incy Memory device device In/out input input input input output input Meaning handle to the cuBLAS library context. number of elements in the vector x and y. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: scopy, dcopy, ccopy, zcopy 40 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.5.6. cublas<t>dot() cublasStatus_t cublasSdot (cublasHandle_t handle, int n, const float *x, int incx, const float *y, int incy, float *result) cublasStatus_t cublasDdot (cublasHandle_t handle, int n, const double *x, int incx, const double *y, int incy, double *result) cublasStatus_t cublasCdotu(cublasHandle_t handle, int n, const cuComplex *x, int incx, const cuComplex *y, int incy, cuComplex *result) cublasStatus_t cublasCdotc(cublasHandle_t handle, int n, const cuComplex *x, int incx, const cuComplex *y, int incy, cuComplex *result) cublasStatus_t cublasZdotu(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, const cuDoubleComplex *y, int incy, cuDoubleComplex *result) cublasStatus_t cublasZdotc(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, const cuDoubleComplex *y, int incy, cuDoubleComplex *result) This function supports the 64-bit Integer Interface. This function computes the dot product of vectors x and y. Hence, the result is ?n (x[k] ? y[j]) where k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that in the first equation the conjugate of the element of vector x should be used if the function name ends in character ‘c’ and that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle n x incx y incy result Memory device device host or device In/out input input input input input input output Meaning handle to the cuBLAS library context. number of elements in the vectors x and y. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. the resulting dot product, which is 0.0 if n<=0. The possible error values returned by this function and their meanings are listed below. 4.5. cuBLAS Level-1 Function Reference 41 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the reduction buffer could not be allocated the function failed to launch on the GPU For references please refer to: sdot, ddot, cdotu, cdotc, zdotu, zdotc 4.5.7. cublas<t>nrm2() cublasStatus_t cublasSnrm2(cublasHandle_t handle, int n, const float *x, int incx, float *result) cublasStatus_t cublasDnrm2(cublasHandle_t handle, int n, const double *x, int incx, double *result) cublasStatus_t cublasScnrm2(cublasHandle_t handle, int n, const cuComplex *x, int incx, float *result) cublasStatus_t cublasDznrm2(cublasHandle_t handle, int n, const cuDoubleComplex *x, int incx, double *result) This function computes the Euclidean norm of the vector x. The code uses a multiphase model of accumulation to avoid intermediate underflow and overflow, with the result being equivalent to n i=1 (x[j] ? x[j]) where j = 1 + (i ? 1) ? incx in exact arithmetic. Notice that the last equation re- flects 1-based indexing used for compatibility with Fortran. Param. handle n x incx result Memory device host or device In/out input input input input output Meaning handle to the cuBLAS library context. number of elements in the vector x. <type> vector with n elements. stride between consecutive elements of x. the resulting norm, which is 0.0 if n,incx<=0. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized the reduction buffer could not be allocated the function failed to launch on the GPU result is NULL 42 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 For references please refer to: snrm2, dnrm2, scnrm2, dznrm2 4.5.8. cublas<t>rot() cublasStatus_t cublasSrot(cublasHandle_t handle, int n, float *x, int incx, float *y, int incy, const float *c, const float *s) cublasStatus_t cublasDrot(cublasHandle_t handle, int n, double *x, int incx, double *y, int incy, const double *c, const double *s) cublasStatus_t cublasCrot(cublasHandle_t handle, int n, cuComplex *x, int incx, cuComplex *y, int incy, const float *c, const cuComplex *s) cublasStatus_t cublasCsrot(cublasHandle_t handle, int n, cuComplex *x, int incx, cuComplex *y, int incy, const float *c, const float *s) cublasStatus_t cublasZrot(cublasHandle_t handle, int n, cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy, const double *c, const cuDoubleComplex *s) cublasStatus_t cublasZdrot(cublasHandle_t handle, int n, cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy, const double *c, const double *s) This function supports the 64-bit Integer Interface. This function applies Givens rotation matrix (i.e., rotation in the x,y plane counter-clockwise by angle defined by cos(alpha)=c, sin(alpha)=s): G = ? c s? ? to vectors x and y. Hence, the result is x[k] = c x[k] + s y[j] and y[j] = s x[k] + c y[j] where k = 1 + (i 1) incx and j = 1 +(i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. 4.5. cuBLAS Level-1 Function Reference 43 cuBLAS, Release 12.3 Param. handle n x incx y incy c s Memory device device host or device host or device In/out input input in/out input in/out input input input Meaning handle to the cuBLAS library context. number of elements in the vectors x and y. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. cosine element of the rotation matrix. sine element of the rotation matrix. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: srot, drot, crot, csrot, zrot, zdrot 4.5.9. cublas<t>rotg() cublasStatus_t cublasSrotg(cublasHandle_t handle, float *a, float *b, float *c, float *s) cublasStatus_t cublasDrotg(cublasHandle_t handle, double *a, double *b, double *c, double *s) cublasStatus_t cublasCrotg(cublasHandle_t handle, cuComplex *a, cuComplex *b, float *c, cuComplex *s) cublasStatus_t cublasZrotg(cublasHandle_t handle, cuDoubleComplex *a, cuDoubleComplex *b, double *c, cuDoubleComplex *s) This function supports the 64-bit Integer Interface. This function constructs the Givens rotation matrix c s ??s c? that zeros out the second entry of a 2 ? 1 vector (a, b)T . Then, for real numbers we can write 44 Chapter 4. Using the cuBLAS API ? c s? ?a? = ?r? cuBLAS, Release 12.3 ??s c? ?b? ?0? where c? + s? = 1 and r = a? + b? . The parameters a and b are overwritten with r and z , respectively. The value of z is such that c and s may be recovered using the following rules: (c, s) = (0.0, 1.0) if z = 1 ??(1/z, v1 ? z2) if |z|> 1 For complex numbers we can write ? c s? ?a? = ?r? ??s? c? ?b? ?0? where c? + (s? ? s) = 1 and r = ? ? (a, b)T ? with (a, b)T ?= |a|2+|b|2 for a ?= 0 and r = b for a = 0 . Finally, the parameter a is overwritten with r on exit. Param. handle a b c s Memory host or device host or device host or device host or device In/out input in/out in/out output output Meaning handle to the cuBLAS library context. <type> scalar that is overwritten with r . <type> scalar that is overwritten with z . cosine element of the rotation matrix. sine element of the rotation matrix. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: srotg, drotg, crotg, zrotg 4.5.10. cublas<t>rotm() cublasStatus_t cublasSrotm(cublasHandle_t handle, int n, float *x, int incx, float *y, int incy, const float* param) cublasStatus_t cublasDrotm(cublasHandle_t handle, int n, double *x, int incx, double *y, int incy, const double* param) This function applies the modified Givens transformation 4.5. cuBLAS Level-1 Function Reference 45 cuBLAS, Release 12.3 H = h11 h12 h21 h22 to vectors x and y. Hence, the result is x[k] = h?? x[k] + h?? y[j] and y[j] = h?? x[k] + h?? y[j] where k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. The elements , , and of matrix H are stored in param[1], param[2], param[3] and param[4], respec- tively. The flag=param[0] defines the following predefined values for the matrix H entries flag=-1.0 ?h11 h12? 21 22 flag= 0.0 1.0 h?? h?? 1.0 flag= 1.0 ? h?? 1.0? ?1.0 h?? flag=-2.0 1.0 0.0 ?0.0 1.0? Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param. Param. Memory In/out Meaning han- dle n in- put in- put handle to the cuBLAS library context. number of elements in the vectors x and y. x device in/out <type> vector with n elements. incx in- put stride between consecutive elements of x. y device in/out <type> vector with n elements. incy param host or device in- put in- put stride between consecutive elements of y. <type> vector of 5 elements, where param[0] and param[1-4] contain the flag and matrix H . The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: srotm, drotm 46 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.5.11. cublas<t>rotmg() cublasStatus_t cublasSrotmg(cublasHandle_t handle, float *d1, float *d2, float *x1, const float *y1, float *param) cublasStatus_t cublasDrotmg(cublasHandle_t handle, double *d1, double *d2, double *x1, const double *y1, double *param) This function supports the 64-bit Integer Interface. This function constructs the modified Givens transformation H = h11 h12 h21 h22 that zeros out the second entry of a 2 ? 1 vector vd1 ? x1, vd2 ? y1 T . The flag=param[0] defines the following predefined values for the matrix H entries flag=-1.0 ?h11 h12? 21 22 flag= 0.0 1.0 h?? h?? 1.0 flag= 1.0 ? h?? 1.0? ?1.0 h?? flag=-2.0 1.0 0.0 ?0.0 1.0? Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param. Param. Memory In/out Meaning han- dle d1 d2 x1 y1 param host or device host or device host or device host or device host or device in- put in/out in/out in/out in- put out- put handle to the cuBLAS library context. <type> scalar that is overwritten on exit. <type> scalar that is overwritten on exit. <type> scalar that is overwritten on exit. <type> scalar. <type> vector of 5 elements, where param[0] and param[1-4] contain the flag and matrix H . The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU 4.5. cuBLAS Level-1 Function Reference 47 cuBLAS, Release 12.3 For references please refer to: srotmg, drotmg 4.5.12. cublas<t>scal() cublasStatus_t cublasSscal(cublasHandle_t handle, int n, const float *alpha, float *x, int incx) cublasStatus_t cublasDscal(cublasHandle_t handle, int n, const double *alpha, double *x, int incx) cublasStatus_t cublasCscal(cublasHandle_t handle, int n, const cuComplex *alpha, cuComplex *x, int incx) cublasStatus_t cublasCsscal(cublasHandle_t handle, int n, const float *alpha, cuComplex *x, int incx) cublasStatus_t cublasZscal(cublasHandle_t handle, int n, const cuDoubleComplex *alpha, cuDoubleComplex *x, int incx) cublasStatus_t cublasZdscal(cublasHandle_t handle, int n, const double *alpha, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function scales the vector x by the scalar ? and overwrites it with the result. Hence, the performed operation is x[j] = ? x[j] for i = 1, . . . , n and j = 1 + (i 1) incx . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle alpha n x incx Memory host or device device In/out input input input in/out input Meaning handle to the cuBLAS library context. <type> scalar used for multiplication. number of elements in the vector x. <type> vector with n elements. stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value Table 1: :class: table-no-stripes Meaning CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: sscal, dscal, csscal, cscal, zdscal, zscal 48 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.5.13. cublas<t>swap() cublasStatus_t cublasSswap(cublasHandle_t handle, int n, float *x, int incx, float *y, int incy) cublasStatus_t cublasDswap(cublasHandle_t handle, int n, double *x, int incx, double *y, int incy) cublasStatus_t cublasCswap(cublasHandle_t handle, int n, cuComplex *x, int incx, cuComplex *y, int incy) cublasStatus_t cublasZswap(cublasHandle_t handle, int n, cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function interchanges the elements of vector x and y. Hence, the performed operation is y[j] x[k] for i = 1, . . . , n , k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle n x incx y incy Memory device device In/out input input in/out input in/out input Meaning handle to the cuBLAS library context. number of elements in the vector x and y. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: sswap, dswap, cswap, zswap 4.6. cuBLAS Level-2 Function Reference In this chapter we describe the Level-2 Basic Linear Algebra Subprograms (BLAS2) functions that per- form matrix-vector operations. 4.6. cuBLAS Level-2 Function Reference 49 cuBLAS, Release 12.3 4.6.1. cublas<t>gbmv() cublasStatus_t cublasSgbmv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const float *alpha, const float *A, int lda, const float *x, int incx, const float *beta, float *y, int incy) cublasStatus_t cublasDgbmv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const double *alpha, const double *A, int lda, const double *x, int incx, const double *beta, double *y, int incy) cublasStatus_t cublasCgbmv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *x, int incx, const cuComplex *beta, cuComplex *y, int incy) cublasStatus_t cublasZgbmv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, const cuDoubleComplex *beta, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function performs the banded matrix-vector multiplication y = ? op(A)x + ?y where A is a banded matrix with kl subdiagonals and ku superdiagonals, x and y are vectors, and ? and ? are scalars. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ??AH if transa == CUBLAS_OP_C The banded matrix A is stored column by column, with the main diagonal stored in row ku + 1 (starting in first position), the first superdiagonal stored in row ku (starting in second position), the first sub- diagonal stored in row ku + 2 (starting in first position), etc. So that in general, the element A (i, j) is stored in the memory location A(ku+1+i-j,j) for j = 1, . . . , n and i [max (1, j ku) , min (m, j + kl)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the top left ku ? ku and bottom right kl ? kl triangles) are not referenced. 50 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Param. Memory In/out Meaning han- dle trans m n kl ku alpha A lda x incx beta y incy host or de- vice device device host or de- vice device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in/out in- put handle to the cuBLAS library context. operation op(A) that is non- or (conj.) transpose. number of rows of matrix A. number of columns of matrix A. number of subdiagonals of matrix A. number of superdiagonals of matrix A. <type> scalar used for multiplication. <type> array of dimension lda x n with lda>=kl+ku+1. leading dimension of two-dimensional array used to store matrix A. <type> vector with n elements if transa == CUBLAS_OP_N and m ele- ments otherwise. stride between consecutive elements of x. <type> scalar used for multiplication, if beta == 0 then y does not have to be a valid input. <type> vector with m elements if transa == CUBLAS_OP_N and n ele- ments otherwise. stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. 4.6. cuBLAS Level-2 Function Reference 51 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m, n, kl, ku < 0 or ? if lda < (kl+ku+1) or ? if incx, incy == 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_T, CUBLAS_OP_C or ? alpha, beta == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sgbmv, dgbmv, cgbmv, zgbmv 4.6.2. cublas<t>gemv() cublasStatus_t cublasSgemv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const float *A, int lda, const float *x, int incx, const float *beta, float *y, int incy) cublasStatus_t cublasDgemv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double *alpha, const double *A, int lda, const double *x, int incx, const double *beta, double *y, int incy) cublasStatus_t cublasCgemv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *x, int incx, const cuComplex *beta, cuComplex *y, int incy) cublasStatus_t cublasZgemv(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, const cuDoubleComplex *beta, cuDoubleComplex *y, int incy) This function performs the matrix-vector multiplication y = ? op(A)x + ?y 52 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 where A is a m n matrix stored in column-major format, x and y are vectors, and ? and ? are scalars. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ??AH if transa == CUBLAS_OP_C ParamM. em- ory In/outMeaning han- dle trans m n al- pha A lda x incx beta host or de- vice de- vice de- vice host or de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. operation op(A) that is non- or (conj.) transpose. number of rows of matrix A. number of columns of matrix A. <type> scalar used for multiplication. <type> array of dimension lda x n with lda >= max(1,m). Before entry, the leading m by n part of the array A must contain the matrix of coefficients. Unchanged on exit. leading dimension of two-dimensional array used to store matrix A. lda must be at least max(1,m). <type> vector at least (1+(n-1)*abs(incx)) elements if transa==CUBLAS_OP_N and at least (1+(m-1)*abs(incx)) elements otherwise. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then y does not have to be a valid input. y de- vice in/out<type> vector at least (1+(m-1)*abs(incy)) elements if transa==CUBLAS_OP_N and at least (1+(n-1)*abs(incy)) elements otherwise. incy in- put stride between consecutive elements of y The possible error values returned by this function and their meanings are listed below. 4.6. cuBLAS Level-2 Function Reference 53 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n<0 or incx,incy=0 the function failed to launch on the GPU For references please refer to: sgemv, dgemv, cgemv, zgemv 4.6.3. cublas<t>ger() cublasStatus_t cublasSger(cublasHandle_t handle, int m, int n, const float *alpha, const float *x, int incx, const float *y, int incy, float *A, int lda) cublasStatus_t cublasDger(cublasHandle_t handle, int m, int n, const double *alpha, const double *x, int incx, const double *y, int incy, double *A, int lda) cublasStatus_t cublasCgeru(cublasHandle_t handle, int m, int n, const cuComplex *alpha, const cuComplex *x, int incx, const cuComplex *y, int incy, cuComplex *A, int lda) cublasStatus_t cublasCgerc(cublasHandle_t handle, int m, int n, const cuComplex *alpha, const cuComplex *x, int incx, const cuComplex *y, int incy, cuComplex *A, int lda) cublasStatus_t cublasZgeru(cublasHandle_t handle, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, int incx, const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda) cublasStatus_t cublasZgerc(cublasHandle_t handle, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, int incx, const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda) This function supports the 64-bit Integer Interface. This function performs the rank-1 update {?xyT + A if ger(),geru() is called where A is a m ? n matrix stored in column-major format, x and y are vectors, and ? is a scalar. 54 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Param. handle m n alpha x incx y incy A lda Memory host or de- vice device device device In/out input input input input input input input input in/out input Meaning handle to the cuBLAS library context. number of rows of matrix A. number of columns of matrix A. <type> scalar used for multiplication. <type> vector with m elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. <type> array of dimension lda x n with lda >= max(1,m). leading dimension of two-dimensional array used to store matrix A. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 ? if incx = 0 or incy = 0 or ? if alpha == NULL or ? lda < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sger, dger, cgeru, cgerc, zgeru, zgerc 4.6.4. cublas<t>sbmv() cublasStatus_t cublasSsbmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const float *alpha, const float *A, int lda, const float *x, int incx, const float *beta, float *y, int incy) cublasStatus_t cublasDsbmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const double *alpha, const double *A, int lda, const double *x, int incx, const double *beta, double *y, int incy) 4.6. cuBLAS Level-2 Function Reference 55 cuBLAS, Release 12.3 This function supports the 64-bit Integer Interface. This function performs the symmetric banded matrix-vector multiplication y = ?Ax + ?y where A is a n n symmetric banded matrix with k subdiagonals and superdiagonals, x and y are vectors, and ? and ? are scalars. If uplo == CUBLAS_FILL_MODE_LOWER then the symmetric banded matrix A is stored column by column, with the main diagonal of the matrix stored in row 1, the first subdiagonal in row 2 (starting at first position), the second subdiagonal in row 3 (starting at first position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+i-j,j) for j = 1, . . . , n and i [j, min(m, j + k)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the bottom right k ? k triangle) are not referenced. If uplo == CUBLAS_FILL_MODE_UPPER then the symmetric banded matrix A is stored column by column, with the main diagonal of the matrix stored in row k+1, the first superdiagonal in row k (start- ing at second position), the second superdiagonal in row k-1 (starting at third position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+k+i-j,j) for j = 1, . . . , n and i ? [max(1, j ? k), j] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the top left k ? k triangle) are not referenced. ParamM. em- In/outMeaning han- dle uplo n k al- pha A lda x incx beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. number of sub- and super-diagonals of matrix A. <type> scalar used for multiplication. <type> array of dimension lda x n with \lda >= k+1. leading dimension of two-dimensional array used to store matrix A. <type> vector with n elements. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then y does not have to be a valid input. y device in/out<type> vector with n elements. incy in- put stride between consecutive elements of y. 56 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if alpha == NULL or beta == NULL or ? lda < (1 + k) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssbmv, dsbmv 4.6.5. cublas<t>spmv() cublasStatus_t cublasSspmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const float *AP, const float *x, int incx, const float *beta, float *y, int incy) cublasStatus_t cublasDspmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const double *AP, const double *x, int incx, const double *beta, double *y, int incy) This function supports the 64-bit Integer Interface. This function performs the symmetric packed matrix-vector multiplication y = ?Ax + ?y where A is a n n symmetric matrix stored in packed format, x and y are vectors, and ? and ? are scalars. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. 4.6. cuBLAS Level-2 Function Reference 57 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha AP x incx beta y incy ory host or device device device host or device device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A . <type> scalar used for multiplication. <type> array with A stored in packed format. <type> vector with n elements. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then y does not have to be a valid input. <type> vector with n elements. stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? alpha == NULL or beta == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sspmv, dspmv 58 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.6. cublas<t>spr() cublasStatus_t cublasSspr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const float *x, int incx, float *AP) cublasStatus_t cublasDspr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const double *x, int incx, double *AP) This function supports the 64-bit Integer Interface. This function performs the packed symmetric rank-1 update A = ?xxT + A where A is a n ? n symmetric matrix stored in packed format, x is a vector, and ? is a scalar. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. ParamM. em- In/outMeaning han- dle uplo n al- pha x incx ory host or device device in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A . <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. AP device in/out<type> array with A stored in packed format. The possible error values returned by this function and their meanings are listed below. 4.6. cuBLAS Level-2 Function Reference 59 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sspr, dspr 4.6.7. cublas<t>spr2() cublasStatus_t cublasSspr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const float *x, int incx, const float *y, int incy, float *AP) cublasStatus_t cublasDspr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const double *x, int incx, const double *y, int incy, double *AP) This function supports the 64-bit Integer Interface. This function performs the packed symmetric rank-2 update A = ? xyT + yxT + A where A is a n ? n symmetric matrix stored in packed format, x is a vector, and ? is a scalar. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. 60 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha x incx y incy ory host or device device device in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A . <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. AP device in/out<type> array with A stored in packed format. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sspr2, dspr2 4.6. cuBLAS Level-2 Function Reference 61 cuBLAS, Release 12.3 4.6.8. cublas<t>symv() cublasStatus_t cublasSsymv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const float *A, int lda, const float *x, int incx, const float ‹>*beta, float *y, int incy) cublasStatus_t cublasDsymv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const double *A, int lda, const double *x, int incx, const double ‹>*beta, double *y, int incy) cublasStatus_t cublasCsymv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, ?* host or device ‹>pointer *? ‹>*beta, const cuComplex *A, int lda, const cuComplex *x, int incx, const cuComplex cuComplex *y, int incy) cublasStatus_t cublasZsymv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, const cuDoubleComplex ‹>*beta, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function performs the symmetric matrix-vector multiplication. y = ?Ax + ?y where A is a n n symmetric matrix stored in lower or upper mode, x and y are vectors, and ? and ? are scalars. This function has an alternate faster implementation using atomics that can be enabled with cublas- SetAtomicsMode(). Please see the section on the function cublasSetAtomicsMode() for more details about the usage of atomics. 62 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha A lda x incx beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> array of dimension lda x n with lda>=max(1,n). leading dimension of two-dimensional array used to store matrix A. <type> vector with n elements. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then y does not have to be a valid input. y device in/out<type> vector with n elements. incy in- put stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? lda < n CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssymv, dsymv 4.6. cuBLAS Level-2 Function Reference 63 cuBLAS, Release 12.3 4.6.9. cublas<t>syr() cublasStatus_t cublasSsyr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const float *x, int incx, float *A, int ‹>lda) cublasStatus_t cublasDsyr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const double *x, int incx, double *A, int ‹>lda) cublasStatus_t cublasCsyr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, const cuComplex *x, int incx, cuComplex *A, int ‹>lda) cublasStatus_t cublasZsyr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, int incx, cuDoubleComplex *A, int ‹>lda) This function supports the 64-bit Integer Interface. This function performs the symmetric rank-1 update A = ?xxT + A where A is a n ? n symmetric matrix stored in column-major format, x is a vector, and ? is a scalar. ParamM. em- In/outMeaning han- dle uplo n al- pha x incx ory host or device device in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. A device in/out<type> array of dimensions lda x n, with lda>=max(1,n). lda in- put leading dimension of two-dimensional array used to store matrix A. The possible error values returned by this function and their meanings are listed below. 64 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssyr, dsyr 4.6.10. cublas<t>syr2() cublasStatus_t cublasSsyr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const float *x, ‹>int incx, ‹>int lda const float *y, int incy, float *A, cublasStatus_t cublasDsyr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const double *x, ‹>int incx, ‹>int lda const double *y, int incy, double *A, cublasStatus_t cublasCsyr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, const cuComplex *x, ‹>int incx, ‹>int lda const cuComplex *y, int incy, cuComplex *A, cublasStatus_t cublasZsyr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, ‹>int incx, ‹>int lda const cuDoubleComplex *y, int incy, cuDoubleComplex *A, This function supports the 64-bit Integer Interface. This function performs the symmetric rank-2 update A = ? xyT + yxT + A where A is a n n symmetric matrix stored in column-major format, x and y are vectors, and ? is a scalar. 4.6. cuBLAS Level-2 Function Reference 65 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha x incx y incy ory host or device device device in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. A device in/out<type> array of dimensions lda x n, with lda>=max(1,n). lda in- put leading dimension of two-dimensional array used to store matrix A. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if alpha == NULL or ? lda < max(1, n) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssyr2, dsyr2 66 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.11. cublas<t>tbmv() cublasStatus_t cublasStbmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float *A, int lda, float *x, int incx) cublasStatus_t cublasDtbmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double *A, int lda, double *x, int incx) cublasStatus_t cublasCtbmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex *A, int lda, cuComplex *x, int incx) cublasStatus_t cublasZtbmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex *A, int lda, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function performs the triangular banded matrix-vector multiplication x = op(A)x where A is a triangular banded matrix, and x is a vector. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C If uplo == CUBLAS_FILL_MODE_LOWER then the triangular banded matrix A is stored column by column, with the main diagonal of the matrix stored in row 1, the first subdiagonal in row 2 (starting at first position), the second subdiagonal in row 3 (starting at first position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+i-j,j) for j = 1, . . . , n and i [j, min(m, j + k)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the bottom right k ? k triangle) are not referenced. If uplo == CUBLAS_FILL_MODE_UPPER then the triangular banded matrix A is stored column by column, with the main diagonal of the matrix stored in row k+1, the first superdiagonal in row k (start- ing at second position), the second superdiagonal in row k-1 (starting at third position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+k+i-j,j) for j = 1, . . . , n and i ? [max(1, j ? k, j)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the top left k ? k triangle) are not referenced. 4.6. cuBLAS Level-2 Function Reference 67 cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle uplo trans diag n k A lda de- vice in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows and columns of matrix A. number of sub- and super-diagonals of matrix . <type> array of dimension lda x n, with lda>=k+1. leading dimension of two-dimensional array used to store matrix A. x de- vice in/out<type> vector with n elements. incx in- put stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if incx = 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if diag != CUBLAS_DIAG_UNIT, CUBLAS_DIAG_NON_UNIT or ? lda < (1 + k) CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED the allocation of internal scratch memory failed the function failed to launch on the GPU For references please refer to: stbmv, dtbmv, ctbmv, ztbmv 68 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.12. cublas<t>tbsv() cublasStatus_t cublasStbsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float *A, int lda, float *x, int incx) cublasStatus_t cublasDtbsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double *A, int lda, double *x, int incx) cublasStatus_t cublasCtbsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex *A, int lda, cuComplex *x, int incx) cublasStatus_t cublasZtbsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex *A, int lda, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function solves the triangular banded linear system with a single right-hand-side op(A)x = b where A is a triangular banded matrix, and x and b are vectors. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C The solution x overwrites the right-hand-sides b on exit. No test for singularity or near-singularity is included in this function. If uplo == CUBLAS_FILL_MODE_LOWER then the triangular banded matrix A is stored column by column, with the main diagonal of the matrix stored in row 1, the first subdiagonal in row 2 (starting at first position), the second subdiagonal in row 3 (starting at first position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+i-j,j) for j = 1, . . . , n and i [j, min(m, j + k)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the bottom right k ? k triangle) are not referenced. If uplo == CUBLAS_FILL_MODE_UPPER then the triangular banded matrix A is stored column by column, with the main diagonal of the matrix stored in row k+1, the first superdiagonal in row k (start- ing at second position), the second superdiagonal in row k-1 (starting at third position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+k+i-j,j) for j = 1, . . . , n and i ? [max(1, j ? k, j)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the top left k ? k triangle) are not referenced. 4.6. cuBLAS Level-2 Function Reference 69 cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle uplo trans diag n k A lda de- vice in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows and columns of matrix A. number of sub- and super-diagonals of matrix A. <type> array of dimension lda x n, with lda >= k+1. leading dimension of two-dimensional array used to store matrix A. x de- vice in/out<type> vector with n elements. incx in- put stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if incx = 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if diag != CUBLAS_DIAG_UNIT, CUBLAS_DIAG_NON_UNIT or ? lda < (1 + k) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: stbsv, dtbsv, ctbsv, ztbsv 70 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.13. cublas<t>tpmv() cublasStatus_t cublasStpmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float *AP, float *x, int incx) cublasStatus_t cublasDtpmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double *AP, double *x, int incx) cublasStatus_t cublasCtpmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex *AP, cuComplex *x, int incx) cublasStatus_t cublasZtpmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex *AP, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function performs the triangular packed matrix-vector multiplication x = op(A)x where A is a triangular matrix stored in packed format, and x is a vector. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the tri- angular matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the triangu- lar matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for A(i, j) and i ? j . Consequently, the packed format requires only ?????? elements for storage. 4.6. cuBLAS Level-2 Function Reference 71 cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle uplo trans diag n AP de- vice in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows and columns of matrix A. <type> array with A stored in packed format. x de- vice in/out<type> vector with n elements. incx in- put stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx == 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if trans != CUBLAS_OP_N, CUBLAS_OP_T, CUBLAS_OP_C or ? diag != CUBLAS_DIAG_UNIT, CUBLAS_DIAG_NON_UNIT CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED the allocation of internal scratch memory failed the function failed to launch on the GPU For references please refer to: stpmv, dtpmv, ctpmv, ztpmv 72 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.14. cublas<t>tpsv() cublasStatus_t cublasStpsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float *AP, float *x, int incx) cublasStatus_t cublasDtpsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double *AP, double *x, int incx) cublasStatus_t cublasCtpsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex *AP, cuComplex *x, int incx) cublasStatus_t cublasZtpsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex *AP, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function solves the packed triangular linear system with a single right-hand-side op(A)x = b where A is a triangular matrix stored in packed format, and x and b are vectors. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C The solution x overwrites the right-hand-sides b on exit. No test for singularity or near-singularity is included in this function. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the tri- angular matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the triangu- lar matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. 4.6. cuBLAS Level-2 Function Reference 73 cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle uplo trans diag n AP de- vice in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix are unity and should not be accessed. number of rows and columns of matrix A. <type> array with A stored in packed format. x de- vice in/out<type> vector with n elements. incx in- put stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? diag != CUBLAS_DIAG_UNIT, CUBLAS_DIAG_NON_UNIT CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: stpsv, dtpsv, ctpsv, ztpsv 74 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.15. cublas<t>trmv() cublasStatus_t cublasStrmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float *A, int lda, float *x, int incx) cublasStatus_t cublasDtrmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double *A, int lda, double *x, int incx) cublasStatus_t cublasCtrmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex *A, int lda, cuComplex *x, int incx) cublasStatus_t cublasZtrmv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex *A, int lda, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function performs the triangular matrix-vector multiplication x = op(A)x where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, and x is a vector. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C 4.6. cuBLAS Level-2 Function Reference 75 cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle uplo trans diag n A lda de- vice in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) (that is, non- or conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows and columns of matrix A. <type> array of dimensions lda x n , with lda>=max(1,n). leading dimension of two-dimensional array used to store matrix A. x de- vice in/out<type> vector with n elements. incx in- put stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if diag != CUBLAS_DIAG_UNIT, CUBLAS_DIAG_NON_UNIT or ? lda < max(1, n) CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_EXECUTION_FAILED the allocation of internal scratch memory failed the function failed to launch on the GPU For references please refer to: strmv, dtrmv, ctrmv, ztrmv 76 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.16. cublas<t>trsv() cublasStatus_t cublasStrsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float *A, int lda, float *x, int incx) cublasStatus_t cublasDtrsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double *A, int lda, double *x, int incx) cublasStatus_t cublasCtrsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex *A, int lda, cuComplex *x, int incx) cublasStatus_t cublasZtrsv(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex *A, int lda, cuDoubleComplex *x, int incx) This function supports the 64-bit Integer Interface. This function solves the triangular linear system with a single right-hand-side op(A)x = b where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, and x and b are vectors. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C The solution x overwrites the right-hand-sides b on exit. No test for singularity or near-singularity is included in this function. 4.6. cuBLAS Level-2 Function Reference 77 cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle uplo trans diag n A lda de- vice in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows and columns of matrix A. <type> array of dimension lda x n, with lda>=max(1,n). leading dimension of two-dimensional array used to store matrix A. x de- vice in/out<type> vector with n elements. incx in- put stride between consecutive elements of x. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if diag != CUBLAS_DIAG_UNIT, CUBLAS_DIAG_NON_UNIT or ? lda < max(1, n) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: strsv, dtrsv, ctrsv, ztrsv 78 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.17. cublas<t>hemv() cublasStatus_t cublasChemv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *x, int incx, const cuComplex *beta, cuComplex *y, int incy) cublasStatus_t cublasZhemv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, const cuDoubleComplex *beta, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function performs the Hermitian matrix-vector multiplication y = ?Ax + ?y where A is a n n Hermitian matrix stored in lower or upper mode, x and y are vectors, and ? and ? are scalars. This function has an alternate faster implementation using atomics that can be enabled with Please see the section on the for more details about the usage of atomics 4.6. cuBLAS Level-2 Function Reference 79 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha A lda x incx beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> array of dimension lda x n, with lda>=max(1,n). The imaginary parts of the diagonal elements are assumed to be zero. leading dimension of two-dimensional array used to store matrix A. <type> vector with n elements. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then y does not have to be a valid input. y device in/out<type> vector with n elements. incy in- put stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? lda < n CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: chemv, zhemv 80 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.18. cublas<t>hbmv() cublasStatus_t cublasChbmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *x, int incx, const cuComplex *beta, cuComplex *y, int incy) cublasStatus_t cublasZhbmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, const cuDoubleComplex *beta, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function performs the Hermitian banded matrix-vector multiplication y = ?Ax + ?y where A is a n n Hermitian banded matrix with k subdiagonals and superdiagonals, x and y are vectors, and ? and ? are scalars. If uplo == CUBLAS_FILL_MODE_LOWER then the Hermitian banded matrix A is stored column by column, with the main diagonal of the matrix stored in row 1, the first subdiagonal in row 2 (starting at first position), the second subdiagonal in row 3 (starting at first position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+i-j,j) for j = 1, . . . , n and i [j, min(m, j + k)] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the bottom right k ? k triangle) are not referenced. If uplo == CUBLAS_FILL_MODE_UPPER then the Hermitian banded matrix A is stored column by column, with the main diagonal of the matrix stored in row k+1, the first superdiagonal in row k (start- ing at second position), the second superdiagonal in row k-1 (starting at third position), etc. So that in general, the element A(i, j) is stored in the memory location A(1+k+i-j,j) for j = 1, . . . , n and i ? [max(1, j ? k), j] . Also, the elements in the array A that do not conceptually correspond to the elements in the banded matrix (the top left k ? k triangle) are not referenced. 4.6. cuBLAS Level-2 Function Reference 81 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n k al- pha A lda x incx beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. number of sub- and super-diagonals of matrix A. <type> scalar used for multiplication. <type> array of dimensions lda x n, with lda>=k+1. The imaginary parts of the diagonal elements are assumed to be zero. leading dimension of two-dimensional array used to store matrix A. <type> vector with n elements. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then does not have to be a valid input. y device in/out<type> vector with n elements. incy in- put stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if incx = 0 or incy = 0 or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < (k + 1) or ? alpha == NULL or beta == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: chbmv, zhbmv 82 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.19. cublas<t>hpmv() cublasStatus_t cublasChpmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, const cuComplex *AP, const cuComplex *x, int incx, const cuComplex *beta, cuComplex *y, int incy) cublasStatus_t cublasZhpmv(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *AP, const cuDoubleComplex *x, int incx, const cuDoubleComplex *beta, cuDoubleComplex *y, int incy) This function supports the 64-bit Integer Interface. This function performs the Hermitian packed matrix-vector multiplication y = ?Ax + ?y where A is a n n Hermitian matrix stored in packed format, x and y are vectors, and ? and ? are scalars. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the Her- mitian matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the Her- mitian matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. 4.6. cuBLAS Level-2 Function Reference 83 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha AP x incx beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> array with A stored in packed format. The imaginary parts of the di- agonal elements are assumed to be zero. <type> vector with n elements. stride between consecutive elements of x. <type> scalar used for multiplication, if beta==0 then y does not have to be a valid input. y device in/out<type> vector with n elements. incy in- put stride between consecutive elements of y. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx == 0 or incy == 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? alpha == NULL or beta == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: chpmv, zhpmv 84 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.20. cublas<t>her() cublasStatus_t cublasCher(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const cuComplex *x, int incx, cuComplex *A, int lda) cublasStatus_t cublasZher(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const cuDoubleComplex *x, int incx, cuDoubleComplex *A, int lda) This function supports the 64-bit Integer Interface. This function performs the Hermitian rank-1 update A = ?xxH + A where A is a n ? n Hermitian matrix stored in column-major format, x is a vector, and ? is a scalar. ParamM. em- In/outMeaning han- dle uplo n al- pha x incx ory host or device device in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. A device in/out<type> array of dimensions lda x n, with lda>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. lda in- put leading dimension of two-dimensional array used to store matrix A. The possible error values returned by this function and their meanings are listed below. 4.6. cuBLAS Level-2 Function Reference 85 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx == 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if lda < max(1, n) or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: cher, zher 4.6.21. cublas<t>her2() cublasStatus_t cublasCher2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, const cuComplex *x, int incx, const cuComplex *y, int incy, cuComplex *A, int lda) cublasStatus_t cublasZher2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, int incx, const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda) This function supports the 64-bit Integer Interface. This function performs the Hermitian rank-2 update A = ?xyH + ?yxH + A where A is a n n Hermitian matrix stored in column-major format, x and y are vectors, and ? is a scalar. 86 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha x incx y incy ory host or device device device in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. A device in/out<type> array of dimension lda x n with lda>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. lda in- put leading dimension of two-dimensional array used to store matrix A. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx == 0 or incy == 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if lda < max(1, n) or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: cher2, zher2 4.6. cuBLAS Level-2 Function Reference 87 cuBLAS, Release 12.3 4.6.22. cublas<t>hpr() cublasStatus_t cublasChpr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *alpha, const cuComplex *x, int incx, cuComplex *AP) cublasStatus_t cublasZhpr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *alpha, const cuDoubleComplex *x, int incx, cuDoubleComplex *AP) This function supports the 64-bit Integer Interface. This function performs the packed Hermitian rank-1 update A = ?xxH + A where A is a n ? n Hermitian matrix stored in packed format, x is a vector, and ? is a scalar. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the Her- mitian matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the Her- mitian matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. ParamM. em- In/outMeaning han- dle uplo n al- pha x incx ory host or device device in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. AP device in/out<type> array with A stored in packed format. The imaginary parts of the di- agonal elements are assumed and set to zero. The possible error values returned by this function and their meanings are listed below. 88 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx == 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: chpr, zhpr 4.6.23. cublas<t>hpr2() cublasStatus_t cublasChpr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *alpha, const cuComplex *x, int incx, const cuComplex *y, int incy, cuComplex *AP) cublasStatus_t cublasZhpr2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *x, int incx, const cuDoubleComplex *y, int incy, cuDoubleComplex *AP) This function supports the 64-bit Integer Interface. This function performs the packed Hermitian rank-2 update A = ?xyH + ?yxH + A where A is a n ? n Hermitian matrix stored in packed format, x and y are vectors, and ? is a scalar. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the Her- mitian matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the Her- mitian matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. 4.6. cuBLAS Level-2 Function Reference 89 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo n al- pha x incx y incy ory host or device device device in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows and columns of matrix A. <type> scalar used for multiplication. <type> vector with n elements. stride between consecutive elements of x. <type> vector with n elements. stride between consecutive elements of y. AP device in/out<type> array with A stored in packed format. The imaginary parts of the di- agonal elements are assumed and set to zero. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if incx == 0 or incy == 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: chpr2, zhpr2 90 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.6.24. cublas<t>gemvBatched() cublasStatus_t cublasSgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const float *const Aarray[], int lda, const float *const xarray[], int incx, const float *beta, float *const yarray[], int incy, int batchCount) cublasStatus_t cublasDgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double *alpha, const double *const Aarray[], int lda, const double *const xarray[], int incx, const double *beta, double *const yarray[], int incy, int batchCount) cublasStatus_t cublasCgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex *alpha, const cuComplex *const Aarray[], int lda, const cuComplex *const xarray[], int incx, const cuComplex *beta, cuComplex *const yarray[], int incy, int batchCount) cublasStatus_t cublasZgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *const Aarray[], int lda, const cuDoubleComplex *const xarray[], int incx, const cuDoubleComplex *beta, cuDoubleComplex *const yarray[], int incy, int batchCount) #if defined( cplusplus) cublasStatus_t cublasHSHgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const half *const Aarray[], int lda, const half *const xarray[], int incx, const float *beta, half *const yarray[], int incy, int batchCount) cublasStatus_t cublasHSSgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const half *const Aarray[], int lda, const half *const xarray[], int incx, const float *beta, float *const yarray[], int incy, int batchCount) cublasStatus_t cublasTSTgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const nv_bfloat16 const nv_bfloat16 *const Aarray[], int lda, *const xarray[], int incx, (continues on next page) 4.6. cuBLAS Level-2 Function Reference 91 cuBLAS, Release 12.3 const float *beta, (continued from previous page) nv_bfloat16 int batchCount) *const yarray[], int incy, cublasStatus_t cublasTSSgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const nv_bfloat16 const nv_bfloat16 *const Aarray[], int lda, *const xarray[], int incx, #endif const float *beta, float *const yarray[], int incy, int batchCount) This function supports the 64-bit Integer Interface. This function performs the matrix-vector multiplication of a batch of matrices and vectors. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n), leading dimension (lda), increments (incx, incy) and transposition (trans) for their respective A matrix, x and y vectors. The address of the input matrix and vector, and the output vector of each instance of the batch are read from arrays of pointers passed to the function by the caller. y[i] = ?op(A[i])x[i] + ?y[i], for i ? [0, batchCount ? 1] where ? and ? are scalars, and A is an array of pointers to matrice A[i] stored in column-major format with dimension m ? n , and x and y are arrays of pointers to vectors. Also, for matrix A[i] , op(A[i]) = A[i]T if trans == CUBLAS_OP_T ???A[i]H if trans == CUBLAS_OP_C Note: y[i] vectors must not overlap, i.e. the individual gemv operations must be computable indepen- dently; otherwise, undefined behavior is expected. On certain problem sizes, it might be advantageous to make multiple calls to cublas<t>gemv in differ- ent CUDA streams, rather than use this API. 92 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning ory han- dle trans m n al- pha Aar- ray lda xar- ray incx beta host or de- vice de- vice de- vice host or de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. operation op(A[i]) that is non- or (conj.) transpose. number of rows of matrix A[i]. number of columns of matrix A[i]. <type> scalar used for multiplication. array of pointers to <type> array, with each array of dim. lda x n with lda>=max(1,m). All pointers must meet certain alignment criteria. Please see below for details. leading dimension of two-dimensional array used to store each matrix A[i]. array of pointers to <type> array, with each dimension n if trans==CUBLAS_OP_N and m otherwise. All pointers must meet certain alignment criteria. Please see below for details. stride of each one-dimensional array x[i]. <type> scalar used for multiplication. If beta == 0, y does not have to be a valid input. yarrayde- vice in/outarray of pointers to <type> array. It has dimensions m if trans==CUBLAS_OP_N and n otherwise. Vectors y[i] should not overlap; otherwise, undefined behavior is expected. All pointers must meet certain alignment criteria. Please see below for details. incy batch- Count in- put in- put stride of each one-dimensional array y[i]. number of pointers contained in Aarray, xarray and yarray. If math mode enables fast math modes when using cublasSgemvBatched(), pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is recommended that they meet the following rule: ? if k % 4==0 then ensure intptr_t(ptr) % 16 == 0, The possible error values returned by this function and their meanings are listed below. 4.6. cuBLAS Level-2 Function Reference 93 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n,batchCount<0 the function failed to launch on the GPU 4.6.25. cublas<t>gemvStridedBatched() cublasStatus_t cublasSgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const float *A, int lda, long long int strideA, const float *x, int incx, long long int stridex, const float *beta, float *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasDgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double *alpha, const double *A, int lda, long long int strideA, const double *x, int incx, long long int stridex, const double *beta, double *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasCgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, long long int strideA, const cuComplex *x, int incx, long long int stridex, const cuComplex *beta, cuComplex *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasZgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, long long int strideA, const cuDoubleComplex *x, int incx, (continues on next page) 94 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) long long int stridex, const cuDoubleComplex *beta, cuDoubleComplex *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasHSHgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const half *A, int lda, long long int strideA, const half *x, int incx, long long int stridex, const float *beta, half *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasHSSgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const half *A, int lda, long long int strideA, const half *x, int incx, long long int stridex, const float *beta, float *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasTSTgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const nv_bfloat16 *A, int lda, long long int strideA, const nv_bfloat16 *x, int incx, long long int stridex, const float *beta, nv_bfloat16 *y, int incy, long long int stridey, int batchCount) cublasStatus_t cublasTSSgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float *alpha, const nv_bfloat16 *A, int lda, long long int strideA, const nv_bfloat16 *x, int incx, long long int stridex, const float *beta, float *y, int incy, long long int stridey, int batchCount) This function supports the 64-bit Integer Interface. This function performs the matrix-vector multiplication of a batch of matrices and vectors. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n), leading dimension 4.6. cuBLAS Level-2 Function Reference 95 cuBLAS, Release 12.3 (lda), increments (incx, incy) and transposition (trans) for their respective A matrix, x and y vectors. Input matrix A and vector x, and output vector y for each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance. Pointers to A matrix, x and y vectors for the first instance are passed to the function by the user along with offsets in number of elements - strideA, stridex and stridey that determine the locations of input matrices and vectors, and output vectors in future instances. y + i ? stridey = ?op(A + i ? strideA)(x + i ? stridex) + ?(y + i ? stridey), for i ? [0, batchCount ? 1] where ? and ? are scalars, and A is an array of pointers to matrix stored in column-major format with dimension A[i] m ? n , and x and y are arrays of pointers to vectors. Also, for matrix A[i] op(A[i]) = A[i]T if trans == CUBLAS_OP_T ???A[i]H if trans == CUBLAS_OP_C Note: y[i] matrices must not overlap, i.e. the individual gemv operations must be computable inde- pendently; otherwise, undefined behavior is expected. On certain problem sizes, it might be advantageous to make multiple calls to cublas<t>gemv in differ- ent CUDA streams, rather than use this API. Note: In the table below, we use A[i], x[i], y[i] as notation for A matrix, and x and y vectors in the ith instance of the batch, implicitly assuming they are respectively offsets in number of elements strideA, stridex, stridey away from A[i-1], x[i-1], y[i-1]. The unit for the offset is number of elements and must not be zero . 96 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle trans m n al- pha A lda ory host or de- vice de- vice in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. operation op(A[i]) that is non- or (conj.) transpose. number of rows of matrix A[i]. number of columns of matrix A[i]. <type> scalar used for multiplication. <type>* pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x n with lda>=max(1,m). leading dimension of two-dimensional array used to store each matrix A[i]. strideA in- put Value of type long long int that gives the offset in number of elements between A[i] and A[i+1] x incx de- vice in- put in- put <type>* pointer to the x vector corresponding to the first instance of the batch, with each dimension n if trans==CUBLAS_OP_N and m otherwise. stride of each one-dimensional array x[i]. stridex in- put Value of type long long int that gives the offset in number of elements between x[i] and x[i+1] beta host or de- vice in- put <type> scalar used for multiplication. If beta == 0, y does not have to be a valid input. y de- vice in/out<type>* pointer to the y vector corresponding to the first instance of the batch, with each dimension m if trans==CUBLAS_OP_N and n otherwise. Vectors y[i] should not overlap; otherwise, undefined behavior is expected. incy stridey batch- Count in- put in- put in- put stride of each one-dimensional array y[i]. Value of type long long int that gives the offset in number of elements between y[i] and y[i+1] number of GEMVs to perform in the batch. The possible error values returned by this function and their meanings are listed below. 4.6. cuBLAS Level-2 Function Reference 97 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n,batchCount<0 the function failed to launch on the GPU 4.7. cuBLAS Level-3 Function Reference In this chapter we describe the Level-3 Basic Linear Algebra Subprograms (BLAS3) functions that per- form matrix-matrix operations. 4.7.1. cublas<t>gemm() cublasStatus_t cublasSgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float *alpha, const float *A, int lda, const float *B, int ldb, const float *beta, float *C, int ldc) cublasStatus_t cublasDgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double *alpha, const double *A, int lda, const double *B, int ldb, const double *beta, double *C, int ldc) cublasStatus_t cublasCgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) cublasStatus_t cublasHgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, (continues on next page) 98 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) int m, int n, int k, const half *alpha, const half *A, int lda, const half *B, int ldb, const half *beta, half *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the matrix-matrix multiplication C = ?op(A)op(B) + ?C where ? and ? are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A) m ? k , op(B) k ? n and C m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C 4.7. cuBLAS Level-3 Function Reference 99 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle ory in- put handle to the cuBLAS library context. transa transb m n k in- put in- put in- put in- put in- put operation op(A) that is non- or (conj.) transpose. operation op(B) that is non- or (conj.) transpose. number of rows of matrix op(A) and C. number of columns of matrix op(B) and C. number of columns of op(A) and rows of op(B). al- pha A lda B ldb beta host or device device device host or device in- put in- put in- put in- put in- put in- put <type> scalar used for multiplication. <type> array of dimensions lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store the matrix A. <type> array of dimension ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication. If beta==0, C does not have to be a valid input. C device in/out<type> array of dimensions ldc x n with ldc>=max(1,m). ldc in- put leading dimension of a two-dimensional array used to store the matrix C. The possible error values returned by this function and their meanings are listed below. 100 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m, n, k < 0 or ? if transa, transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) or ? if alpha, beta == NULL or ? C == NULL if C needs to be scaled CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_EXECUTION_FAILED in the case of cublasHgemm() the device does not support math in half precision. the function failed to launch on the GPU For references please refer to: sgemm, dgemm, cgemm, zgemm 4.7.2. cublas<t>gemm3m() cublasStatus_t cublasCgemm3m(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZgemm3m(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the complex matrix-matrix multiplication, using Gauss complexity reduction algorithm. This can lead to an increase in performance up to 25% C = ?op(A)op(B) + ?C 4.7. cuBLAS Level-3 Function Reference 101 cuBLAS, Release 12.3 where ? and ? are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A) m ? k , op(B) k ? n and C m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C Note: These 2 routines are only supported on GPUs with architecture capabilities equal to or greater than 5.0 ParamM. em- In/outMeaning han- dle ory in- put Handle to the cuBLAS library context. transa transb m n k in- put in- put in- put in- put in- put Operation op(A) that is non- or (conj.) transpose. Operation op(B) that is non- or (conj.) transpose. Number of rows of matrix op(A) and C. Number of columns of matrix op(B) and C. Number of columns of op(A) and rows of op(B). al- pha A lda B ldb beta host or device device device host or device in- put in- put in- put in- put in- put in- put <type> scalar used for multiplication. <type> array of dimensions lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. Leading dimension of two-dimensional array used to store the matrix A. <type> array of dimension ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1,n) otherwise. Leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication. If beta==0, C does not have to be a valid input. C device in/out<type> array of dimensions ldc x n with ldc>=max(1,m). ldc in- put Leading dimension of a two-dimensional array used to store the matrix C. The possible error values returned by this function and their meanings are listed in the following table: 102 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. ? If m, n, k < 0 or ? if transa, transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) or ? if alpha, beta == NULL or ? C == NULL if C needs to be scaled CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_EXECUTION_FAILED The device has a compute capabilites lower than 5.0. The function failed to launch on the GPU. For references please refer to: cgemm, zgemm 4.7.3. cublas<t>gemmBatched() cublasStatus_t cublasHgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const half *alpha, const half *const Aarray[], int lda, const half *const Barray[], int ldb, const half *beta, half *const Carray[], int ldc, int batchCount) cublasStatus_t cublasSgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float *alpha, const float *const Aarray[], int lda, const float *const Barray[], int ldb, const float *beta, float *const Carray[], int ldc, int batchCount) cublasStatus_t cublasDgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, (continues on next page) 4.7. cuBLAS Level-3 Function Reference 103 cuBLAS, Release 12.3 (continued from previous page) int m, int n, int k, const double *alpha, const double *const Aarray[], int lda, const double *const Barray[], int ldb, const double *beta, double *const Carray[], int ldc, int batchCount) cublasStatus_t cublasCgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const cuComplex *const Aarray[], int lda, const cuComplex *const Barray[], int ldb, const cuComplex *beta, cuComplex *const Carray[], int ldc, int batchCount) cublasStatus_t cublasZgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *const Aarray[], int lda, const cuDoubleComplex *const Barray[], int ldb, const cuDoubleComplex *beta, cuDoubleComplex *const Carray[], int ldc, int batchCount) This function supports the 64-bit Integer Interface. This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. The address of the input matrices and the output matrix of each instance of the batch are read from arrays of pointers passed to the function by the caller. C[i] = ?op(A[i])op(B[i]) + ?C[i], for i ? [0, batchCount ? 1] where ? and ? are scalars, and A , B and C are arrays of pointers to matrices stored in column-major format with dimensions op(A[i]) m ? k , op(B[i]) k ? n and C[i] m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C Note: C[i] matrices must not overlap, that is, the individual gemm operations must be computable independently; otherwise, undefined behavior is expected. On certain problem sizes, it might be advantageous to make multiple calls to cublas<t>gemm in dif- ferent CUDA streams, rather than use this API. 104 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning ory han- dle transa transb m n k in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. operation op(A[i]) that is non- or (conj.) transpose. operation op(B[i]) that is non- or (conj.) transpose. number of rows of matrix op(A[i]) and C[i]. number of columns of op(B[i]) and C[i]. number of columns of op(A[i]) and rows of op(B[i]). al- pha Aar- ray lda Bar- ray ldb beta host or de- vice de- vice de- vice host or de- vice in- put in- put in- put in- put in- put in- put <type> scalar used for multiplication. array of pointers to <type> array, with each array of dim. lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1, k) otherwise. All pointers must meet certain alignment criteria. Please see below for details. leading dimension of two-dimensional array used to store each matrix A[i]. array of pointers to <type> array, with each array of dim. ldb x n with ldb>=max(1,k) if transb==CUBLAS_OP_N and ldb x k with ldb>=max(1, n) max(1,) otherwise. All pointers must meet certain alignment criteria. Please see below for details. leading dimension of two-dimensional array used to store each matrix B[i]. <type> scalar used for multiplication. If beta == 0, C does not have to be a valid input. Car- ray de- vice in/outarray of pointers to <type> array. It has dimensions ldc x n with ldc>=max(1, m). Matrices C[i] should not overlap; otherwise, undefined behavior is expected. All pointers must meet certain alignment criteria. Please see below for details. ldc batch- Count in- put in- put leading dimension of two-dimensional array used to store each matrix C[i]. number of pointers contained in Aarray, Barray and Carray. If math mode enables fast math modes when using cublasSgemmBatched(), pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is recommended that they meet the 4.7. cuBLAS Level-3 Function Reference 105 cuBLAS, Release 12.3 following rule: ? if k%4==0 then ensure intptr_t(ptr) % 16 == 0, The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m, n, k, batchCount < 0 or ? if transa, transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_ARCH_MISMATCH the function failed to launch on the GPU cublasHgemmBatched() is only supported for GPU with architecture capabilities equal or greater than 5.3 4.7.4. cublas<t>gemmStridedBatched() cublasStatus_t cublasHgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const half *alpha, const half *A, int lda, long long int strideA, const half *B, int ldb, long long int strideB, const half *beta, half *C, int ldc, long long int strideC, int batchCount) cublasStatus_t cublasSgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float *alpha, const float *A, int lda, long long int strideA, const float *B, int ldb, long long int strideB, (continues on next page) 106 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 const float *beta, (continued from previous page) float *C, int ldc, long long int strideC, int batchCount) cublasStatus_t cublasDgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double *alpha, const double *A, int lda, long long int strideA, const double *B, int ldb, long long int strideB, const double *beta, double *C, int ldc, long long int strideC, int batchCount) cublasStatus_t cublasCgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, long long int strideA, const cuComplex *B, int ldb, long long int strideB, const cuComplex *beta, cuComplex *C, int ldc, long long int strideC, int batchCount) cublasStatus_t cublasCgemm3mStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, long long int strideA, const cuComplex *B, int ldb, long long int strideB, const cuComplex *beta, cuComplex *C, int ldc, long long int strideC, int batchCount) cublasStatus_t cublasZgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, long long int strideA, const cuDoubleComplex *B, int ldb, long long int strideB, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc, long long int strideC, int batchCount) 4.7. cuBLAS Level-3 Function Reference 107 cuBLAS, Release 12.3 This function supports the 64-bit Integer Interface. This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance. Pointers to A, B and C matrices for the first instance are passed to the function by the user along with offsets in number of elements - strideA, strideB and strideC that determine the locations of input and output matrices in future instances. C + i ? strideC = ?op(A + i ? strideA)op(B + i ? strideB) + ?(C + i ? strideC), for i ? [0, batchCount ? 1] where ? and ? are scalars, and A , B and C are arrays of pointers to matrices stored in column-major format with dimensions op(A[i]) m ? k , op(B[i]) k ? n and C[i] m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C Note: C[i] matrices must not overlap, i.e. the individual gemm operations must be computable inde- pendently; otherwise, undefined behavior is expected. On certain problem sizes, it might be advantageous to make multiple calls to cublas<t>gemm in dif- ferent CUDA streams, rather than use this API. Note: In the table below, we use A[i], B[i], C[i] as notation for A, B and C matrices in the ith instance of the batch, implicitly assuming they are respectively offsets in number of elements strideA, strideB, strideC away from A[i-1], B[i-1], C[i-1]. The unit for the offset is number of elements and must not be zero . 108 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Param.Mem- ory In/outMeaning han- dle transa transb m n k al- pha A lda host or de- vice de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. operation op(A[i]) that is non- or (conj.) transpose. operation op(B[i]) that is non- or (conj.) transpose. number of rows of matrix op(A[i]) and C[i]. number of columns of op(B[i]) and C[i]. number of columns of op(A[i]) and rows of op(B[i]). <type> scalar used for multiplication. <type>* pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store each matrix A[i]. strideA in- put Value of type long long int that gives the offset in number of elements between A[i] and A[i+1] B ldb de- vice in- put in- put <type>* pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transb==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. leading dimension of two-dimensional array used to store each matrix B[i]. strideB in- put Value of type long long int that gives the offset in number of elements between B[i] and B[i+1] beta host or de- vice in- put <type> scalar used for multiplication. If beta == 0, C does not have to be a valid input. C de- vice in/out<type>* pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). Matrices C[i] should not overlap; otherwise, undefined behavior is expected. ldc strideC batch- Count in- put in- put in- put leading dimension of two-dimensional array used to store each matrix C[i]. Value of type long long int that gives the offset in number of elements between C[i] and C[i+1] number of GEMMs to perform in the batch. 4.7. cuBLAS Level-3 Function Reference 109 cuBLAS, Release 12.3 The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m, n, k, batchCount < 0 or ? if transa, transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_ARCH_MISMATCH the function failed to launch on the GPU cublasHgemmStridedBatched() is only supported for GPU with architecture capabilities equal or greater than 5.3 4.7.5. cublas<t>symm() cublasStatus_t cublasSsymm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const float *alpha, const float *A, int lda, const float *B, int ldb, const float *beta, float *C, int ldc) cublasStatus_t cublasDsymm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const double *alpha, const double *A, int lda, const double *B, int ldb, const double *beta, double *C, int ldc) cublasStatus_t cublasCsymm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZsymm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, (continues on next page) 110 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the symmetric matrix-matrix multiplication C = ??AB + ?C if side == CUBLAS_SIDE_LEFT ??BA + ?C if side == CUBLAS_SIDE_RIGHT where A is a symmetric matrix stored in lower or upper mode, B and C are m n matrices, and ? and ? are scalars. ParamM. em- In/outMeaning han- dle side uplo m n al- pha A lda B ldb beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows of matrix C and B, with matrix A sized accordingly. number of columns of matrix C and B, with matrix A sized accordingly. <type> scalar used for multiplication. <type> array of dimension lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta == 0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 4.7. cuBLAS Level-3 Function Reference 111 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m, n < 0 or ? if side != CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, m) if side == CUBLAS_SIDE_LEFT and lda < max(1, n) otherwise or ? if ldb < max(1, m) or ? if ldc < max(1, m) or ? if alpha == NULL or beta == NULL or ? C == NULL if C needs to be scaled CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssymm, dsymm, csymm, zsymm 4.7.6. cublas<t>syrk() cublasStatus_t cublasSsyrk(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const float *A, int lda, const float *beta, float *C, int ldc) cublasStatus_t cublasDsyrk(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double *alpha, const double *A, int lda, const double *beta, double *C, int ldc) cublasStatus_t cublasCsyrk(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZsyrk(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex *alpha, (continues on next page) 112 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) const cuDoubleComplex *A, int lda, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the symmetric rank- k update C = ?op(A)op(A)T + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ? A if transa == CUBLAS_OP_N ?AT if transa == CUBLAS_OP_T ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda beta ory host or device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix C lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. operation op(A) that is non- or transpose. number of rows of matrix op(A) and C. number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if trans == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 4.7. cuBLAS Level-3 Function Reference 113 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n, k < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? if alpha == NULL or beta == NULL or ? C == NULL if C needs to be scaled CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssyrk, dsyrk, csyrk, zsyrk 4.7.7. cublas<t>syr2k() cublasStatus_t cublasSsyr2k(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const float *A, int lda, const float *B, int ldb, const float *beta, float *C, int ldc) cublasStatus_t cublasDsyr2k(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double *alpha, const double *A, int lda, const double *B, int ldb, const double *beta, double *C, int ldc) cublasStatus_t cublasCsyr2k(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZsyr2k(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, (continues on next page) 114 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the symmetric rank- 2k update C = ?(op(A)op(B)T + op(B)op(A)T ) + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N ParamM. em- AT and BT if trans == CUBLAS_OP_T In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements. operation op(A) that is non- or transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimensions ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0, then C does not have to be a valid input. C device in/out<type> array of dimensions ldc x n with ldc>=max(1,n). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 4.7. cuBLAS Level-3 Function Reference 115 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n, k < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldb < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? if alpha == NULL or beta == NULL or ? C == NULL if C needs to be scaled CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssyr2k, dsyr2k, csyr2k, zsyr2k 4.7.8. cublas<t>syrkx() cublasStatus_t cublasSsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const float *A, int lda, const float *B, int ldb, const float *beta, float *C, int ldc) cublasStatus_t cublasDsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double *alpha, const double *A, int lda, const double *B, int ldb, const double *beta, double *C, int ldc) cublasStatus_t cublasCsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZsyrkx(cublasHandle_t handle, (continues on next page) 116 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs a variation of the symmetric rank- k update C = ?op(A)op(B)T + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrices A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N AT and BT if trans == CUBLAS_OP_T This routine can be used when B is in such way that the result is guaranteed to be symmetric. A usual example is when the matrix B is a scaled form of the matrix A: this is equivalent to B being the product of the matrix A and a diagonal matrix. For an efficient computation of the product of a regular matrix with a diagonal matrix, refer to the routine cublas<t>dgmm. 4.7. cuBLAS Level-3 Function Reference 117 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements. operation op(A) that is non- or transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimensions ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0, then C does not have to be a valid input. C device in/out<type> array of dimensions ldc x n with ldc>=max(1,n). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 118 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n, k < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldb < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? if alpha == NULL or beta == NULL or ? C == NULL if C needs to be scaled CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: ssyrk, dsyrk, csyrk, zsyrk and ssyr2k, dsyr2k, csyr2k, zsyr2k 4.7.9. cublas<t>trmm() cublasStatus_t cublasStrmm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float *alpha, const float *A, int lda, const float *B, int ldb, float *C, int ldc) cublasStatus_t cublasDtrmm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double *alpha, const double *A, int lda, const double *B, int ldb, double *C, int ldc) cublasStatus_t cublasCtrmm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, cuComplex *C, int ldc) (continues on next page) 4.7. cuBLAS Level-3 Function Reference 119 cuBLAS, Release 12.3 cublasStatus_t cublasZtrmm(cublasHandle_t handle, (continued from previous page) cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the triangular matrix-matrix multiplication C = ?op(A)B if side == CUBLAS_SIDE_LEFT ?Bop(A) if side == CUBLAS_SIDE_RIGHT where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m ? n matrix, and ? is a scalar. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C Notice that in order to achieve better parallelism cuBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results written back to B), while the cuBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in the cuBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported. 120 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle side uplo trans diag m n al- pha A lda B ldb ory host or device device device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows of matrix B, with matrix A sized accordingly. number of columns of matrix B, with matrix A sized accordingly. <type> scalar used for multiplication, if alpha==0 then A is not referenced and B does not have to be a valid input. <type> array of dimension lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. C device in/out<type> array of dimension ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 4.7. cuBLAS Level-3 Function Reference 121 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m, n < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if side != CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT or ? if lda < max(1, m) if side == CUBLAS_SIDE_LEFT and lda < max(1, n) otherwise or ? if ldb < max(1, m) or ? C == NULL if C needs to be scaled CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: strmm, dtrmm, ctrmm, ztrmm 4.7.10. cublas<t>trsm() cublasStatus_t cublasStrsm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float *alpha, const float *A, int lda, float *B, int ldb) cublasStatus_t cublasDtrsm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double *alpha, const double *A, int lda, double *B, int ldb) cublasStatus_t cublasCtrsm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, cuComplex *B, int ldb) cublasStatus_t cublasZtrsm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, (continues on next page) 122 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, cuDoubleComplex *B, int ldb) This function supports the 64-bit Integer Interface. This function solves the triangular linear system with multiple right-hand-sides op(A)X = ?B if side == CUBLAS_SIDE_LEFT Xop(A) = ?B if side == CUBLAS_SIDE_RIGHT where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, X and B are m ? n matrices, and ? is a scalar. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C The solution X overwrites the right-hand-sides B on exit. No test for singularity or near-singularity is included in this function. ParamM. em- In/outMeaning han- dle side uplo trans diag m n al- pha A lda ory host or device device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A is on the left or right of X. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows of matrix B, with matrix A sized accordingly. number of columns of matrix B, with matrix A is sized accordingly. <type> scalar used for multiplication, if alpha==0 then A is not referenced and B does not have to be a valid input. <type> array of dimension lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A. B device in/out<type> array. It has dimensions ldb x n with ldb>=max(1,m). ldb in- put leading dimension of two-dimensional array used to store matrix B. 4.7. cuBLAS Level-3 Function Reference 123 cuBLAS, Release 12.3 The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if side != CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT or ? if diag != CUBLAS_DIAG_NON_UNIT, CUBLAS_DIAG_UNIT or ? if lda < max(1, m) if side == CUBLAS_SIDE_LEFT and lda < max(1, n) otherwise or ? if ldb < max(1, m) or ? alpha == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: strsm, dtrsm, ctrsm, ztrsm 4.7.11. cublas<t>trsmBatched() cublasStatus_t cublasStrsmBatched( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float *alpha, const float *const A[], int lda, float *const B[], int ldb, int batchCount); cublasStatus_t cublasDtrsmBatched( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double *alpha, (continues on next page) 124 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) const double *const A[], int lda, double *const B[], int ldb, int batchCount); cublasStatus_t cublasCtrsmBatched( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex *alpha, const cuComplex *const A[], int lda, cuComplex *const B[], int ldb, int batchCount); cublasStatus_t cublasZtrsmBatched( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *const A[], int lda, cuDoubleComplex *const B[], int ldb, int batchCount); This function supports the 64-bit Integer Interface. This function solves an array of triangular linear systems with multiple right-hand-sides op(A[i])X[i] = ?B[i] if side == CUBLAS_SIDE_LEFT X[i]op(A[i]) = ?B[i] if side == CUBLAS_SIDE_RIGHT where A[i] is a triangular matrix stored in lower or upper mode with or without the main diagonal, X[i] and B[i] are m ? n matrices, and ? is a scalar. Also, for matrix A op(A[i]) = AT [i] if transa == CUBLAS_OP_T ???AH [i] if transa == CUBLAS_OP_C The solution X[i] overwrites the right-hand-sides B[i] on exit. No test for singularity or near-singularity is included in this function. This function works for any sizes but is intended to be used for matrices of small sizes where the launch overhead is a significant factor. For bigger sizes, it might be advantageous to call batchCount times the regular cublas<t>trsm within a set of CUDA streams. The current implementation is limited to devices with compute capability above or equal 2.0. 4.7. cuBLAS Level-3 Function Reference 125 cuBLAS, Release 12.3 Param. Mem- ory In/outMeaning han- dle side uplo trans diag m n al- pha A lda host or de- vice de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A[i] is on the left or right of X[i]. indicates if matrix A[i] lower or upper part is stored, the other part is not referenced and is inferred from the stored elements. operation op(A[i]) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A[i] are unity and should not be accessed. number of rows of matrix B[i], with matrix A[i] sized accordingly. number of columns of matrix B[i], with matrix A[i] is sized accordingly. <type> scalar used for multiplication, if alpha==0 then A[i] is not refer- enced and B[i] does not have to be a valid input. array of pointers to <type> array, with each array of dim. lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A[i]. B de- vice in/outarray of pointers to <type> array, with each array of dim. ldb x n with ldb>=max(1,m). Matrices B[i] should not overlap; otherwise, undefined behavior is expected. ldb batch- Count in- put in- put leading dimension of two-dimensional array used to store matrix B[i]. number of pointers contained in A and B. The possible error values returned by this function and their meanings are listed below. 126 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or batchCount < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if side != CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT or ? if diag != CUBLAS_DIAG_NON_UNIT, CUBLAS_DIAG_UNIT or ? if lda < max(1, m) if side == CUBLAS_SIDE_LEFT and lda < max(1, n) otherwise or ? ldb < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: strsm, dtrsm, ctrsm, ztrsm 4.7.12. cublas<t>hemm() cublasStatus_t cublasChemm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasZhemm(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the Hermitian matrix-matrix multiplication C = ??AB + ?C if side == CUBLAS_SIDE_LEFT ??BA + ?C if side == CUBLAS_SIDE_RIGHT 4.7. cuBLAS Level-3 Function Reference 127 cuBLAS, Release 12.3 where A is a Hermitian matrix stored in lower or upper mode, B and C are m n matrices, and ? and ? are scalars. ParamM. em- ory In/outMeaning han- dle side uplo m n al- pha A lda B ldb beta host or de- vice de- vice de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows of matrix C and B, with matrix A sized accordingly. number of columns of matrix C and B, with matrix A sized accordingly. <type> scalar used for multiplication. <type> array of dimension lda x m with lda>=max(1,m) if side==CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) other- wise. The imaginary parts of the diagonal elements are assumed to be zero. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C de- vice in/out<type> array of dimensions ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 128 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or ? if side != CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, m) if side == CUBLAS_SIDE_LEFT and lda < max(1, n) otherwise or ? if ldb < max(1, m) or ? if ldc < max(1, m) or ? if alpha == NULL or beta == NULL or ? C == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: chemm, zhemm 4.7.13. cublas<t>herk() cublasStatus_t cublasCherk(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const cuComplex *A, int lda, const float *beta, cuComplex *C, int ldc) cublasStatus_t cublasZherk(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double *alpha, const cuDoubleComplex *A, int lda, const double *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the Hermitian rank- k update C = ?op(A)op(A)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ? A if transa == CUBLAS_OP_N ?AH if transa == CUBLAS_OP_C 4.7. cuBLAS Level-3 Function Reference 129 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda beta ory host or device device in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. operation op(A) that is non- or (conj.) transpose. number of rows of matrix op(A) and C. number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? if alpha == NULL or beta == NULL or ? C == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU 130 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 For references please refer to: cherk, zherk 4.7.14. cublas<t>her2k() cublasStatus_t cublasCher2k(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const float *beta, cuComplex *C, int ldc) cublasStatus_t cublasZher2k(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const double *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the Hermitian rank- 2k update C = ?op(A)op(B)H + ?op(B)op(A)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N ?AH and BH if trans == CUBLAS_OP_C 4.7. cuBLAS Level-3 Function Reference 131 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. operation op(A) that is non- or (conj.) transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 132 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldb < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? if alpha == NULL or beta == NULL or ? C == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: cher2k, zher2k 4.7.15. cublas<t>herkx() cublasStatus_t cublasCherkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const float *beta, cuComplex *C, int ldc) cublasStatus_t cublasZherkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const double *beta, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs a variation of the Hermitian rank- k update C = ?op(A)op(B)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B 4.7. cuBLAS Level-3 Function Reference 133 cuBLAS, Release 12.3 op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N AH and BH if trans == CUBLAS_OP_C This routine can be used when the matrix B is in such way that the result is guaranteed to be hermitian. An usual example is when the matrix B is a scaled form of the matrix A: this is equivalent to B being the product of the matrix A and a diagonal matrix. For an efficient computation of the product of a regular matrix with a diagonal matrix, refer to the routine cublas<t>dgmm. ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. operation op(A) that is non- or (conj.) transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. real scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. 134 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or k < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if uplo != CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldb < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? if alpha == NULL or beta == NULL or ? C == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: cherk, zherk and cher2k, zher2k 4.8. BLAS-like Extension This section describes the BLAS-extension functions that perform matrix-matrix operations. 4.8.1. cublas<t>geam() cublasStatus_t cublasSgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const float *alpha, const float *A, int lda, const float *beta, const float *B, int ldb, float *C, int ldc) cublasStatus_t cublasDgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const double *alpha, const double *A, int lda, const double *beta, const double *B, int ldb, double *C, int ldc) (continues on next page) 4.8. BLAS-like Extension 135 cuBLAS, Release 12.3 cublasStatus_t cublasCgeam(cublasHandle_t handle, (continued from previous page) cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *beta , const cuComplex *B, int ldb, cuComplex *C, int ldc) cublasStatus_t cublasZgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *beta, const cuDoubleComplex *B, int ldb, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the matrix-matrix addition/transposition C = ?op(A) + ?op(B) where ? and ? are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A) m ? n , op(B) m ? n and C m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C and op(B) is defined similarly for matrix B . The operation is out-of-place if C does not overlap A or B. The in-place mode supports the following two operations, C = ?*C + ?op(B) C = ?op(A) + ?*C For in-place mode, if C = A, ldc = lda and transa = CUBLAS_OP_N. If C = B, ldc = ldb and transb = CUBLAS_OP_N. If the user does not meet above requirements, CUBLAS_STATUS_INVALID_VALUE is returned. The operation includes the following special cases: the user can reset matrix C to zero by setting *alpha=*beta=0. the user can transpose matrix A by setting *alpha=1 and *beta=0. 136 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle ory in- put handle to the cuBLAS library context. transa transb m n in- put in- put in- put in- put operation op(A) that is non- or (conj.) transpose. operation op(B) that is non- or (conj.) transpose. number of rows of matrix op(A) and C. number of columns of matrix op(B) and C. al- pha A lda B ldb beta C ldc host or device device device host or device device in- put in- put in- put in- put in- put in- put out- put in- put <type> scalar used for multiplication. If *alpha == 0, A does not have to be a valid input. <type> array of dimensions lda x n with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store the matrix A. <type> array of dimension ldb x n with ldb>=max(1,m) if transb == CUBLAS_OP_N and ldb x m with ldb>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication. If *beta == 0, B does not have to be a valid input. <type> array of dimensions ldc x n with ldc>=max(1,m). leading dimension of a two-dimensional array used to store the matrix C. The possible error values returned by this function and their meanings are listed below. 4.8. BLAS-like Extension 137 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or ? if transa != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, n) other- wise or ? if ldb < max(1, m) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) or ? if A == C, ((CUBLAS_OP_N != transa) || (lda != ldc)) or ? if B == C, ((CUBLAS_OP_N != transb) || (ldb != ldc)) or ? alpha == NULL or beta == NULL CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU 4.8.2. cublas<t>dgmm() cublasStatus_t cublasSdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const float *A, int lda, const float *x, int incx, float *C, int ldc) cublasStatus_t cublasDdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const double *A, int lda, const double *x, int incx, double *C, int ldc) cublasStatus_t cublasCdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuComplex *A, int lda, const cuComplex *x, int incx, cuComplex *C, int ldc) cublasStatus_t cublasZdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, cuDoubleComplex *C, int ldc) This function supports the 64-bit Integer Interface. This function performs the matrix-matrix multiplication 138 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 C = ?A ? diag(X) if mode == CUBLAS_SIDE_RIGHT ?diag(X) ? A if mode == CUBLAS_SIDE_LEFT where A and C are matrices stored in column-major format with dimensions m n . X is a vector of size n if mode == CUBLAS_SIDE_RIGHT and of size m if mode == CUBLAS_SIDE_LEFT. X is gathered from one-dimensional array x with stride incx. The absolute value of incx is the stride and the sign of incx is direction of the stride. If incx is positive, then we forward x from the first element. Otherwise, we backward x from the last element. The formula of X is X[j] = ?? x[j ? incx] if incx ? 0 x[(? ? 1) ? |incx| ? j ? |incx|] if incx < 0 where ? = m if mode == CUBLAS_SIDE_LEFT and ? = n if mode == CUBLAS_SIDE_RIGHT. Example 1: if the user wants to perform diag(diag(B)) A , then incx = ldb + 1 where ldb is leading dimension of matrix B, either row-major or column-major. Example 2: if the user wants to perform ? A , then there are two choices, either cublas<t>geam() with *beta=0 and transa == CUBLAS_OP_N or cublas<t>dgmm() with incx=0 and x[0]=alpha. The operation is out-of-place. The in-place only works if lda = ldc. Param.Mem- ory In/outMeaning han- dle mode m n A lda x incx de- vice de- vice in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLAS library context. left multiply if mode == CUBLAS_SIDE_LEFT or right multiply if mode == CUBLAS_SIDE_RIGHT number of rows of matrix A and C. number of columns of matrix A and C. <type> array of dimensions lda x n with lda>=max(1,m) leading dimension of two-dimensional array used to store the matrix A. one-dimensional <type> array of size |inc|? m if mode == CUBLAS_SIDE_LEFT and |inc| ? n if mode == CUBLAS_SIDE_RIGHT stride of one-dimensional array x. C de- vice in/out<type> array of dimensions ldc x n with ldc>=max(1,m). ldc in- put leading dimension of a two-dimensional array used to store the matrix C. The possible error values returned by this function and their meanings are listed below. 4.8. BLAS-like Extension 139 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or ? if mode != CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT or ? if lda < max(1, m) or ? ldc < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU 4.8.3. cublas<t>getrfBatched() cublasStatus_t cublasSgetrfBatched(cublasHandle_t handle, int n, float *const Aarray[], int lda, int *PivotArray, int *infoArray, int batchSize); cublasStatus_t cublasDgetrfBatched(cublasHandle_t handle, int n, double *const Aarray[], int lda, int *PivotArray, int *infoArray, int batchSize); cublasStatus_t cublasCgetrfBatched(cublasHandle_t handle, int n, cuComplex *const Aarray[], int lda, int *PivotArray, int *infoArray, int batchSize); cublasStatus_t cublasZgetrfBatched(cublasHandle_t handle, int n, cuDoubleComplex *const Aarray[], int lda, int *PivotArray, int *infoArray, int batchSize); Aarray is an array of pointers to matrices stored in column-major format with dimensions nxn and leading dimension lda. This function performs the LU factorization of each Aarray[i] for i = 0, …, batchSize-1 by the following equation 140 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 P*Aarray[i] = L*U where P is a permutation matrix which represents partial pivoting with row interchanges. L is a lower triangular matrix with unit diagonal and U is an upper triangular matrix. Formally P is written by a product of permutation matrices Pj, for j = 1,2,...,n, say P = P1 * P2 * P3 * .... * Pn. Pj is a permutation matrix which interchanges two rows of vector x when performing Pj*x. Pj can be constructed by j element of PivotArray[i] by the following Matlab code ?? In Matlab PivotArray[i] is an array of base-1. ?? In C, PivotArray[i] is base-0. Pj = eye(n); swap Pj(j,:) and Pj(PivotArray[i][j] ,:) L and U are written back to original matrix A, and diagonal elements of L are discarded. The L and U can be constructed by the following Matlab code ?? A is a matrix of nxn after getrf. L = eye(n); for j = 1:n L(j+1:n,j) = A(j+1:n,j) end U = zeros(n); for i = 1:n U(i,i:n) = A(i,i:n) end If matrix A(=Aarray[i]) is singular, getrf still works and the value of info(=infoArray[i]) reports first row index that LU factorization cannot proceed. If info is k, U(k,k) is zero. The equation P*A=L*U still holds, however L and U reconstruction needs different Matlab code as follows: ?? A is a matrix of nxn after getrf. ?? info is k, which means U(k,k) is zero. L = eye(n); for j = 1:k-1 L(j+1:n,j) = A(j+1:n,j) end U = zeros(n); for i = 1:k-1 U(i,i:n) = A(i,i:n) end for i = k:n U(i,k:n) = A(i,k:n) end This function is intended to be used for matrices of small sizes where the launch overhead is a signif- icant factor. cublas<t>getrfBatched supports non-pivot LU factorization if PivotArray is NULL. cublas<t>getrfBatched supports arbitrary dimension. cublas<t>getrfBatched only supports compute capability 2.0 or above. 4.8. BLAS-like Extension 141 cuBLAS, Release 12.3 ParamM. em-In/outMeaning ory han- dle n Aar- de- in- put in- put in- handle to the cuBLAS library context. number of rows and columns of Aarray[i]. array of pointers to <type> array, with each array of dim. n x n with lda>=max(1, ray vice put/ount)p.utMatrices Aarray[i] should not overlap; otherwise, undefined behavior is expected. lda Piv- de- otAr- vice ray in- put out- put leading dimension of two-dimensional array used to store each matrix Aar- ray[i]. array of size n x batchSize that contains the pivoting sequence of each factor- ization of Aarray[i] stored in a linear fashion. If PivotArray is NULL, pivoting is disabled. in- de- foAr- vice ray batch- Size out- put in- put array of size batchSize that info(=infoArray[i]) contains the information of fac- torization of Aarray[i]. If info=0, the execution is successful. If info = -j, the j-th parameter had an illegal value. If info = k, U(k,k) is 0. The factorization has been completed, but U is exactly singular. number of pointers contained in A The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,batchSize,lda <0 the function failed to launch on the GPU For references please refer to: sgeqrf, dgeqrf, cgeqrf, zgeqrf 4.8.4. cublas<t>getrsBatched() cublasStatus_t cublasSgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const float *const Aarray[], int lda, const int *devIpiv, (continues on next page) 142 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) float *const Barray[], int ldb, int *info, int batchSize); cublasStatus_t cublasDgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const double *const Aarray[], int lda, const int *devIpiv, double *const Barray[], int ldb, int *info, int batchSize); cublasStatus_t cublasCgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuComplex *const Aarray[], int lda, const int *devIpiv, cuComplex *const Barray[], int ldb, int *info, int batchSize); cublasStatus_t cublasZgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuDoubleComplex *const Aarray[], int lda, const int *devIpiv, cuDoubleComplex *const Barray[], int ldb, int *info, int batchSize); This function solves an array of systems of linear equations of the form: op(A[i])X[i] = B[i] where A[i] is a matrix which has been LU factorized with pivoting, X[i] and B[i] are n nrhs matrices. Also, for matrix A op(A[i]) = AT [i] if trans == CUBLAS_OP_T ???AH [i] if trans == CUBLAS_OP_C This function is intended to be used for matrices of small sizes where the launch overhead is a signif- icant factor. cublas<t>getrsBatched supports non-pivot LU factorization if devIpiv is NULL. cublas<t>getrsBatched supports arbitrary dimension. 4.8. BLAS-like Extension 143 cuBLAS, Release 12.3 cublas<t>getrsBatched only supports compute capability 2.0 or above. ParamM. em-In/out Meaning han- dle trans n nrhs Aar- ray lda de- vIpiv Bar- ory de- vice de- vice de- input input input input input input input in- handle to the cuBLAS library context. operation op(A) that is non- or (conj.) transpose. number of rows and columns of Aarray[i]. number of columns of Barray[i]. array of pointers to <type> array, with each array of dim. n x n with lda>=max(1,n). leading dimension of two-dimensional array used to store each matrix Aar- ray[i]. array of size n x batchSize that contains the pivoting sequence of each fac- torization of Aarray[i] stored in a linear fashion. If devIpiv is NULL, pivoting for all Aarray[i] is ignored. array of pointers to <type> array, with each array of dim. n x nrhs with ray vice put/outpludtb>=max(1,n). Matrices Barray[i] should not overlap; otherwise, unde- fined behavior is expected. ldb info host input out- put leading dimension of two-dimensional array used to store each solution matrix Barray[i]. If info=0, the execution is successful. If info = -j, the j-th parameter had an illegal value. batch- Size input number of pointers contained in A The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or nrhs < 0 or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, n) or ? ldb < max(1, n) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sgeqrs, dgeqrs, cgeqrs, zgeqrs 144 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.8.5. cublas<t>getriBatched() cublasStatus_t cublasSgetriBatched(cublasHandle_t handle, int n, const float *const Aarray[], int lda, int *PivotArray, float *const Carray[], int ldc, int *infoArray, int batchSize); cublasStatus_t cublasDgetriBatched(cublasHandle_t handle, int n, const double *const Aarray[], int lda, int *PivotArray, double *const Carray[], int ldc, int *infoArray, int batchSize); cublasStatus_t cublasCgetriBatched(cublasHandle_t handle, int n, const cuComplex *const Aarray[], int lda, int *PivotArray, cuComplex *const Carray[], int ldc, int *infoArray, int batchSize); cublasStatus_t cublasZgetriBatched(cublasHandle_t handle, int n, const cuDoubleComplex *const Aarray[], int lda, int *PivotArray, cuDoubleComplex *const Carray[], int ldc, int *infoArray, int batchSize); Aarray and Carray are arrays of pointers to matrices stored in column-major format with dimensions n*n and leading dimension lda and ldc respectively. This function performs the inversion of matrices A[i] for i = 0, …, batchSize-1. Prior to calling cublas<t>getriBatched, the matrix A[i] must be factorized first using the routine cublas<t>getrfBatched. After the call of cublas<t>getrfBatched, the matrix pointing by Aarray[i] will contain the LU factors of the matrix A[i] and the vector pointing by (PivotArray+i) will contain the pivoting sequence. Following the LU factorization, cublas<t>getriBatched uses forward and backward triangular solvers to complete inversion of matrices A[i] for i = 0, …, batchSize-1. The inversion is out-of-place, so memory space of Carray[i] cannot overlap memory space of Array[i]. Typically all parameters in cublas<t>getrfBatched would be passed into cublas<t>getriBatched. For example, 4.8. BLAS-like Extension 145 cuBLAS, Release 12.3 ?? step 1: perform in-place LU decomposition, P*A = L*U. ?? Aarray[i] is n*n matrix A[i] cublasDgetrfBatched(handle, n, Aarray, lda, PivotArray, infoArray, batchSize); ?? check infoArray[i] to see if factorization of A[i] is successful or not. ?? Array[i] contains LU factorization of A[i] ?? step 2: perform out-of-place inversion, Carray[i] = inv(A[i]) cublasDgetriBatched(handle, n, Aarray, lda, PivotArray, Carray, ldc, infoArray, ‹>batchSize); ?? check infoArray[i] to see if inversion of A[i] is successful or not. The user can check singularity from either cublas<t>getrfBatched or cublas<t>getriBatched. This function is intended to be used for matrices of small sizes where the launch overhead is a signif- icant factor. If cublas<t>getrfBatched is performed by non-pivoting, PivotArray of cublas<t>getriBatched should be NULL. cublas<t>getriBatched supports arbitrary dimension. cublas<t>getriBatched only supports compute capability 2.0 or above. ParamM. em-In/outMeaning han- dle n Aar- ray lda Piv- otAr- ray Car- ray ldc in- foAr- ray ory de- vice de- vice de- vice de- vice in- put in- put in- put in- put out- put out- put in- put out- put handle to the cuBLAS library context. number of rows and columns of Aarray[i]. array of pointers to <type> array, with each array of dimension n*n with lda>=max(1,n). leading dimension of two-dimensional array used to store each matrix Aar- ray[i]. array of size n*batchSize that contains the pivoting sequence of each factor- ization of Aarray[i] stored in a linear fashion. If PivotArray is NULL, pivoting is disabled. array of pointers to <type> array, with each array of dimension n*n with ldc>=max(1,n). Matrices Carray[i] should not overlap; otherwise, undefined behavior is expected. leading dimension of two-dimensional array used to store each matrix Car- ray[i]. array of size batchSize that info(=infoArray[i]) contains the information of in- version of A[i]. If info=0, the execution is successful. If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed. batch- Size in- put number of pointers contained in A The possible error values returned by this function and their meanings are listed below. 146 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or lda < 0 or ldc < 0 or batchSize < 0 or ? lda < n or ldc < n CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU 4.8.6. cublas<t>matinvBatched() cublasStatus_t cublasSmatinvBatched(cublasHandle_t handle, int n, const float *const A[], int lda, float *const Ainv[], int lda_inv, int *info, int batchSize); cublasStatus_t cublasDmatinvBatched(cublasHandle_t handle, int n, const double *const A[], int lda, double *const Ainv[], int lda_inv, int *info, int batchSize); cublasStatus_t cublasCmatinvBatched(cublasHandle_t handle, int n, const cuComplex *const A[], int lda, cuComplex *const Ainv[], int lda_inv, int *info, int batchSize); cublasStatus_t cublasZmatinvBatched(cublasHandle_t handle, int n, const cuDoubleComplex *const A[], int lda, cuDoubleComplex *const Ainv[], int lda_inv, int *info, int batchSize); A and Ainv are arrays of pointers to matrices stored in column-major format with dimensions n*n and leading dimension lda and lda_inv respectively. This function performs the inversion of matrices A[i] for i = 0, …, batchSize-1. 4.8. BLAS-like Extension 147 cuBLAS, Release 12.3 This function is a short cut of cublas<t>getrfBatched plus cublas<t>getriBatched. However it doesn’t work if n is greater than 32. If not, the user has to go through cublas<t>getrfBatched and cublas<t>getriBatched. If the matrix A[i] is singular, then info[i] reports singularity, the same as cublas<t>getrfBatched. ParamM. em-In/outMeaning han- dle n A lda Ainv ory de- vice de- vice in- put in- put in- put in- put out- put handle to the cuBLAS library context. number of rows and columns of A[i]. array of pointers to <type> array, with each array of dimension n*n with lda>=max(1,n). leading dimension of two-dimensional array used to store each matrix A[i]. array of pointers to <type> array, with each array of dimension n*n with lda_inv>=max(1,n). Matrices Ainv[i] should not overlap; otherwise, unde- fined behavior is expected. lda_inv in- put leading dimension of two-dimensional array used to store each matrix Ainv[i]. info de- vice out- put array of size batchSize that info[i] contains the information of inversion of A[i]. If info[i]=0, the execution is successful. If info[i]=k, U(k,k) is 0. The U is exactly singular and the inversion failed. batch- Size in- put number of pointers contained in A. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or lda < 0 or lda_inv < 0 or batch- Size < 0 or ? if lda < n or lda_inv < n or ? n > 32 CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU 148 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.8.7. cublas<t>geqrfBatched() cublasStatus_t cublasSgeqrfBatched( cublasHandle_t handle, int m, int n, float *const Aarray[], int lda, float *const TauArray[], int *info, int batchSize); cublasStatus_t cublasDgeqrfBatched( cublasHandle_t handle, int m, int n, double *const Aarray[], int lda, double *const TauArray[], int *info, int batchSize); cublasStatus_t cublasCgeqrfBatched( cublasHandle_t handle, int m, int n, cuComplex *const Aarray[], int lda, cuComplex *const TauArray[], int *info, int batchSize); cublasStatus_t cublasZgeqrfBatched( cublasHandle_t handle, int m, int n, cuDoubleComplex *const Aarray[], int lda, cuDoubleComplex *const TauArray[], int *info, int batchSize); Aarray is an array of pointers to matrices stored in column-major format with dimensions m x n and leading dimension lda. TauArray is an array of pointers to vectors of dimension of at least max (1, min(m, n). This function performs the QR factorization of each Aarray[i] for i = 0, ...,batchSize-1 using Householder reflections. Each matrix Q[i] is represented as a product of elementary reflectors and is stored in the lower part of each Aarray[i] as follows : Q[j] = H[j][1] H[j][2] . . . H[j](k), where k = min(m,n). Each H[j][i] has the form H[j][i] = I - tau[j] * v * v' where tau[j] is a real scalar, and v is a real vector with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in Aarray[j][i+1:m,i], and tau in TauArray[j][i]. This function is intended to be used for matrices of small sizes where the launch overhead is a signif- icant factor. 4.8. BLAS-like Extension 149 cuBLAS, Release 12.3 cublas<t>geqrfBatched supports arbitrary dimension. cublas<t>geqrfBatched only supports compute capability 2.0 or above. Param. Mem- ory In/out Meaning handle m n Aarray lda TauAr- ray info batch- Size de- vice de- vice host in- put in- put in- put in- put in- put out- put out- put in- put handle to the cuBLAS library context. number of rows Aarray[i]. number of columns of Aarray[i]. array of pointers to <type> array, with each array of dim. m x n with lda>=max(1,m). leading dimension of two-dimensional array used to store each matrix Aar- ray[i]. array of pointers to <type> vector, with each vector of dim. max(1,min(m, n)). If info=0, the parameters passed to the function are valid If info<0, the parameter in postion -info is invalid number of pointers contained in A The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or batchSize < 0 or ? lda < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: sgeqrf, dgeqrf, cgeqrf, zgeqrf 150 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.8.8. cublas<t>gelsBatched() cublasStatus_t cublasSgelsBatched( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, float *const Aarray[], int lda, float *const Carray[], int ldc, int *info, int *devInfoArray, int batchSize ); cublasStatus_t cublasDgelsBatched( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, double *const Aarray[], int lda, double *const Carray[], int ldc, int *info, int *devInfoArray, int batchSize ); cublasStatus_t cublasCgelsBatched( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuComplex *const Aarray[], int lda, cuComplex *const Carray[], int ldc, int *info, int *devInfoArray, int batchSize ); cublasStatus_t cublasZgelsBatched( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuDoubleComplex *const Aarray[], int lda, cuDoubleComplex *const Carray[], int ldc, int *info, int *devInfoArray, int batchSize ); Aarray is an array of pointers to matrices stored in column-major format. Carray is an array of point- ers to matrices stored in column-major format. This function find the least squares solution of a batch of overdetermined systems: it solves the least 4.8. BLAS-like Extension 151 cuBLAS, Release 12.3 squares problem described as follows : minimize || Carray[i] - Aarray[i]*Xarray[i] || , with i = 0, ...,batchSize-1 On exit, each Aarray[i] is overwritten with their QR factorization and each Carray[i] is overwritten with the least square solution cublas<t>gelsBatched supports only the non-transpose operation and only solves over-determined systems (m >= n). cublas<t>gelsBatched only supports compute capability 2.0 or above. This function is intended to be used for matrices of small sizes where the launch overhead is a signif- icant factor. ParamM. em-In/outMeaning ory han- dle trans m n nrhs Aar- de- in- put in- put in- put in- put in- put in- handle to the cuBLAS library context. operation op(Aarray[i]) that is non- or (conj.) transpose. Only non-transpose operation is currently supported. number of rows of each Aarray[i] and Carray[i] if trans == CUBLAS_OP_N, numbers of columns of each Aarray[i] otherwise (not supported currently). number of columns of each Aarray[i] if trans == CUBLAS_OP_N, and number of rows of each Aarray[i] and Carray[i] otherwise (not supported currently). number of columns of each Carray[i]. array of pointers to <type> array, with each array of dim. m x n with lda>=max(1, ray vice put/oumt)puifttrans == CUBLAS_OP_N, and n x m with lda>=max(1,n) otherwise (not supported currently). Matrices Aarray[i] should not overlap; otherwise, unde- fined behavior is expected. lda Car- de- in- put in- leading dimension of two-dimensional array used to store each matrix Aar- ray[i]. array of pointers to <type> array, with each array of dim. m x nrhs with ray vice put/oultdpcu>t =max(1,m) if trans == CUBLAS_OP_N, and n x nrhs with lda>=max(1, n) otherwise (not supported currently). Matrices Carray[i] should not overlap; otherwise, undefined behavior is expected. ldc info dev- In- foAr- ray host de- vice in- put out- put out- put leading dimension of two-dimensional array used to store each matrix Car- ray[i]. If info=0, the parameters passed to the function are valid If info<0, the parameter in position -info is invalid optional array of integers of dimension batchsize. If non-null, every element devInfoArray[i] contain a value V with the following meaning: V = 0 : the i-th problem was sucessfully solved V > 0 : the V-th diagonal element of the Aarray[i] is zero. Aarray[i] does not have full rank. batch- Size in- put number of pointers contained in Aarray and Carray 152 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If m < 0 or n < 0 or nrhs < 0 or batchSize < 0 or ? lda < max(1, m) or ldc < max(1, m) CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_EXECUTION_FAILED the parameters m <n or trans is different from non-transpose. the function failed to launch on the GPU For references please refer to: sgels, dgels, cgels, zgels 4.8.9. cublas<t>tpttr() cublasStatus_t cublasStpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *AP, float *A, int lda ); cublasStatus_t cublasDtpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double *AP, double *A, int lda ); cublasStatus_t cublasCtpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *AP, cuComplex *A, int lda ); cublasStatus_t cublasZtpttr ( cublasHandle_t handle, cublasFillMode_t uplo int n, const cuDoubleComplex *AP, cuDoubleComplex *A, int lda ); This function performs the conversion from the triangular packed format to the triangular format If uplo == CUBLAS_FILL_MODE_LOWER then the elements of AP are copied into the lower tri- angular part of the triangular matrix A and the upper part of A is left untouched. If uplo == 4.8. BLAS-like Extension 153 cuBLAS, Release 12.3 CUBLAS_FILL_MODE_UPPER then the elements of AP are copied into the upper triangular part of the triangular matrix A and the lower part of A is left untouched. Param. Mem- ory In/out Meaning han- dle uplo n AP A lda de- vice de- vice in- put in- put in- put in- put out- put in- put handle to the cuBLAS library context. indicates if matrix AP contains lower or upper part of matrix A. number of rows and columns of matrix A. <type> array with A stored in packed format. <type> array of dimensions lda x n , with lda>=max(1,n). The opposite side of A is left untouched. leading dimension of two-dimensional array used to store matrix A. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? lda < max(1, n) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: stpttr, dtpttr, ctpttr, ztpttr 4.8.10. cublas<t>trttp() cublasStatus_t cublasStrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float *A, int lda, float *AP ); cublasStatus_t cublasDtrttp ( cublasHandle_t handle, (continues on next page) 154 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 (continued from previous page) cublasFillMode_t uplo, int n, const double *A, int lda, double *AP ); cublasStatus_t cublasCtrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex *A, int lda, cuComplex *AP ); cublasStatus_t cublasZtrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex *A, int lda, cuDoubleComplex *AP ); This function performs the conversion from the triangular format to the triangular packed format If uplo == CUBLAS_FILL_MODE_LOWER then the lower triangular part of the triangular matrix A is copied into the array AP. If uplo == CUBLAS_FILL_MODE_UPPER then then the upper triangular part of the triangular matrix A is copied into the array AP. Param. handle uplo n A lda AP Memory device device In/out input input input input input output Meaning handle to the cuBLAS library context. indicates which matrix A lower or upper part is referenced. number of rows and columns of matrix A. <type> array of dimensions lda x n , with lda>=max(1,n). leading dimension of two-dimensional array used to store matrix A. <type> array with A stored in packed format. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized ? If n < 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? lda < max(1, n) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: 4.8. BLAS-like Extension 155 cuBLAS, Release 12.3 strttp, dtrttp, ctrttp, ztrttp 4.8.11. cublas<t>gemmEx() cublasStatus_t cublasSgemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float *alpha, const void *A, cudaDataType_t Atype, int lda, const void *B, cudaDataType_t Btype, int ldb, const float *beta, void *C, cudaDataType_t Ctype, int ldc) cublasStatus_t cublasCgemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const void *A, cudaDataType_t Atype, int lda, const void *B, cudaDataType_t Btype, int ldb, const cuComplex *beta, void *C, cudaDataType_t Ctype, int ldc) This function supports the 64-bit Integer Interface. This function is an extension of cublas<t>gemm. In this function the input matrices and output ma- trices can have a lower precision but the computation is still done in the type <t>. For example, in the type float for cublasSgemmEx() and in the type cuComplex for cublasCgemmEx(). C = ?op(A)op(B) + ?C where ? and ? are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A) m ? k , op(B) k ? n and C m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C 156 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle ory in- put handle to the cuBLAS library context. transa transb m n k in- put in- put in- put in- put in- put operation op(A) that is non- or (conj.) transpose. operation op(B) that is non- or (conj.) transpose. number of rows of matrix op(A) and C. number of columns of matrix op(B) and C. number of columns of op(A) and rows of op(B). al- pha A Atype lda B Btype ldb beta host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put <type> scalar used for multiplication. <type> array of dimensions lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. enumerant specifying the datatype of matrix A. leading dimension of two-dimensional array used to store the matrix A. <type> array of dimension ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1,n) otherwise. enumerant specifying the datatype of matrix B. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication. If beta==0, C does not have to be a valid input. C device in/out<type> array of dimensions ldc x n with ldc>=max(1,m). Ctype ldc in- put in- put enumerant specifying the datatype of matrix C. leading dimension of a two-dimensional array used to store the matrix C. The matrix types combinations supported for cublasSgemmEx() are listed below: 4.8. BLAS-like Extension 157 cuBLAS, Release 12.3 C CUDA_R_16BF CUDA_R_16F CUDA_R_32F A/B CUDA_R_16BF CUDA_R_16F CUDA_R_8I CUDA_R_16BF CUDA_R_16F CUDA_R_32F The matrix types combinations supported for cublasCgemmEx() are listed below : C CUDA_C_32F A/B CUDA_C_8I CUDA_C_32F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized cublasCgemmEx() is only supported for GPU with architecture capabilities equal or greater than 5.0 the combination of the parameters Atype,Btype and Ctype is not supported ? If m < 0 or n < 0 or k < 0 or ? if transa or transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? ldc < max(1, m) CUBLAS_STATUS_EXECUTION_FAILED the function failed to launch on the GPU For references please refer to: 158 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 sgemm For more information about the numerical behavior of some GEMM algorithms, refer to the GEMM Algorithms Numerical Behavior section. 4.8.12. cublasGemmEx() cublasStatus_t cublasGemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void *alpha, const void *A, cudaDataType_t Atype, int lda, const void *B, cudaDataType_t Btype, int ldb, const void *beta, void *C, cudaDataType_t Ctype, int ldc, cublasComputeType_t computeType, cublasGemmAlgo_t algo) #if defined( cplusplus) cublasStatus_t cublasGemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void *alpha, const void *A, cudaDataType Atype, int lda, const void *B, cudaDataType Btype, int ldb, const void *beta, void *C, cudaDataType Ctype, int ldc, cudaDataType computeType, cublasGemmAlgo_t algo) #endif This function supports the 64-bit Integer Interface. This function is an extension of cublas<t>gemm that allows the user to individually specify the data types for each of the A, B and C matrices, the precision of computation and the GEMM algorithm to be run. Supported combinations of arguments are listed further down in this section. Note: The second variant of cublasGemmEx() function is provided for backward compatibility with 4.8. BLAS-like Extension 159 cuBLAS, Release 12.3 C++ applications code, where the computeType parameter is of cudaDataType instead of cublas- ComputeType_t. C applications would still compile with the updated function signature. This function is only supported on devices with compute capability 5.0 or later. C = ?op(A)op(B) + ?C where ? and ? are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A) m ? k , op(B) k ? n and C m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C 160 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Param. Mem- ory In/outMeaning han- dle transa transb m n k alpha A Atype lda B Btype ldb beta host or device device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Operation op(A) that is non- or (conj.) transpose. Operation op(B) that is non- or (conj.) transpose. Number of rows of matrix op(A) and C. Number of columns of matrix op(B) and C. Number of columns of op(A) and rows of op(B). Scaling factor for A*B of the type that corresponds to the computeType and Ctype, see the table below for details. <type> array of dimensions lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. Enumerant specifying the datatype of matrix A. Leading dimension of two-dimensional array used to store the matrix A. <type> array of dimension ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1,n) otherwise. Enumerant specifying the datatype of matrix B. Leading dimension of two-dimensional array used to store matrix B. Scaling factor for C of the type that corresponds to the computeType and Ctype, see the table below for details. If beta==0, C does not have to be a valid input. C device in/out<type> array of dimensions ldc x n with ldc>=max(1,m). Ctype ldc com- pute- Type algo in- put in- put in- put in- put Enumerant specifying the datatype of matrix C. Leading dimension of a two-dimensional array used to store the matrix C. Enumerant specifying the computation type. Enumerant specifying the algorithm. See cublasGemmAlgo_t. 4.8. BLAS-like Extension 161 cuBLAS, Release 12.3 cublasGemmEx() supports the following Compute Type, Scale Type, Atype/Btype, and Ctype: Compute Type CUBLAS_COMPUTE_16F or CUBLAS_COMPUTE_16F_PEDANTIC Scale Type (alpha and beta) CUDA_R_16F Atype/Btype Ctype CUDA_R_16F CUDA_R_16F CUBLAS_COMPUTE_32I or CUBLAS_COMPUTE_32I_PEDANTIC CUDA_R_32I CUDA_R_8I CUDA_R_32I CUBLAS_COMPUTE_32F or CUBLAS_COMPUTE_32F_PEDANTIC CUDA_R_32F CUDA_R_16BFCUDA_R_16BF CUDA_R_16F CUDA_R_16F CUDA_R_8I CUDA_R_32F CUDA_R_16BFCUDA_R_32F CUDA_R_16F CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_C_32F CUDA_C_8I CUDA_C_32F CUBLAS_COMPUTE_32F_FAST_16F or CUBLAS_COMPUTE_32F_FAST_16BF or CUBLAS_COMPUTE_32F_FAST_TF32 CUBLAS_COMPUTE_64F or CUBLAS_COMPUTE_64F_PEDANTIC CUDA_R_32F CUDA_C_32F CUDA_R_64F CUDA_C_64F CUDA_C_32F CUDA_C_32F CUDA_R_32F CUDA_R_32F CUDA_C_32F CUDA_C_32F CUDA_R_64F CUDA_R_64F CUDA_C_64F CUDA_C_64F Note: CUBLAS_COMPUTE_32I and CUBLAS_COMPUTE_32I_PEDANTIC compute types are only sup- ported with A, B being 4-byte aligned and lda, ldb being multiples of 4. For better performance, it is also recommended that IMMA kernels requirements for a regular data ordering listed here are met. The possible error values returned by this function and their meanings are listed in the following table. 162 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. cublasGemmEx() is only supported for GPU with architecture capabilities equal or greater than 5.0. The combination of the parameters Atype,Btype and Ctype or the algorithm,algois not supported. ? If m < 0 or n < 0 or k < 0 or ? if transa or transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) or ? Atype or Btype or Ctype or algo is not supported CUBLAS_STATUS_EXECUTION_FAILED The function failed to launch on the GPU. Starting with release 11.2, using the typed functions instead of the extension functions (cublas**Ex()) helps in reducing the binary size when linking to static cuBLAS Library. Also refer to: sgemm. For more information about the numerical behavior of some GEMM algorithms, refer to the GEMM Algorithms Numerical Behavior section. 4.8.13. cublasGemmBatchedEx() cublasStatus_t cublasGemmBatchedEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void *alpha, const void *const Aarray[], cudaDataType_t Atype, int lda, const void *const Barray[], cudaDataType_t Btype, int ldb, const void *beta, (continues on next page) 4.8. BLAS-like Extension 163 cuBLAS, Release 12.3 #if defined( cplusplus) void *const Carray[], cudaDataType_t Ctype, int ldc, int batchCount, cublasComputeType_t computeType, cublasGemmAlgo_t algo) (continued from previous page) cublasStatus_t cublasGemmBatchedEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void *alpha, const void *const Aarray[], cudaDataType Atype, int lda, const void *const Barray[], cudaDataType Btype, int ldb, const void *beta, void *const Carray[], cudaDataType Ctype, int ldc, int batchCount, cudaDataType computeType, cublasGemmAlgo_t algo) #endif This function supports the 64-bit Integer Interface. This function is an extension of cublas<t>gemmBatched that performs the matrix-matrix multipli- cation of a batch of matrices and allows the user to individually specify the data types for each of the A, B and C matrix arrays, the precision of computation and the GEMM algorithm to be run. Like cublas<t>gemmBatched, the batch is considered to be “uniform”, i.e. all instances have the same di- mensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their re- spective A, B and C matrices. The address of the input matrices and the output matrix of each in- stance of the batch are read from arrays of pointers passed to the function by the caller. Supported combinations of arguments are listed further down in this section. Note: The second variant of cublasGemmBatchedEx() function is provided for backward compatibil- ity with C++ applications code, where the computeType parameter is of cudaDataType instead of cublasComputeType_t. C applications would still compile with the updated function signature. C[i] = ?op(A[i])op(B[i]) + ?C[i], for i ? [0, batchCount ? 1] where ? and ? are scalars, and A , B and C are arrays of pointers to matrices stored in column-major format with dimensions op(A[i]) m ? k , op(B[i]) k ? n and C[i] m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C 164 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Note: C[i] matrices must not overlap, i.e. the individual gemm operations must be computable inde- pendently; otherwise, undefined behavior is expected. On certain problem sizes, it might be advantageous to make multiple calls to cublas<t>gemm in dif- ferent CUDA streams, rather than use this API. 4.8. BLAS-like Extension 165 cuBLAS, Release 12.3 Param.Mem- In/outMeaning ory han- dle transa transb m n k al- pha Aar- ray Atype lda Bar- ray Btype ldb beta host or de- vice de- vice de- vice host or de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Operation op(A[i]) that is non- or (conj.) transpose. Operation op(B[i]) that is non- or (conj.) transpose. Number of rows of matrix op(A[i]) and C[i]. Number of columns of matrix op(B[i]) and C[i]. Number of columns of op(A[i]) and rows of op(B[i]). Scaling factor for A*B of the type that corresponds to the computeType and Ctype, see the table below for details. Array of pointers to <Atype> array, with each array of dim. lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1, k) otherwise. All pointers must meet certain alignment criteria. Please see below for details. Enumerant specifying the datatype of Aarray. Leading dimension of two-dimensional array used to store the matrix A[i]. Array of pointers to <Btype> array, with each array of dim. ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1, n) otherwise. All pointers must meet certain alignment criteria. Please see below for details. Enumerant specifying the datatype of Barray. Leading dimension of two-dimensional array used to store matrix B[i]. Scaling factor for C of the type that corresponds to the computeType and Ctype, see the table below for details. If beta==0, C[i] does not have to be a valid input. Car- ray de- vice in/outArray of pointers to <Ctype> array. It has dimensions ldc x n with ldc>=max(1,m). Matrices C[i] should not overlap; otherwise, undefined be- havior is expected. All pointers must meet certain alignment criteria. Please see below for details. Ctype ldc 166 batch- Count com- in- put in- put in- put in- Enumerant specifying the datatype of Carray. Leading dimension of a two-dimensional array used to store each matrix C[i]. Chapter 4. Using the cuBLAS API Number of pointers contained in Aarray, Barray and Carray. Enumerant specifying the computation type. cuBLAS, Release 12.3 cublasGemmBatchedEx() supports the following Compute Type, Scale Type, Atype/Btype, and Ctype: Compute Type CUBLAS_COMPUTE_16F or CUBLAS_COMPUTE_16F_PEDANTIC Scale Type (alpha and beta) CUDA_R_16F Atype/Btype Ctype CUDA_R_16F CUDA_R_16F CUBLAS_COMPUTE_32I or CUBLAS_COMPUTE_32I_PEDANTIC CUDA_R_32I CUDA_R_8I CUDA_R_32I CUBLAS_COMPUTE_32F or CUBLAS_COMPUTE_32F_PEDANTIC CUDA_R_32F CUDA_R_16BFCUDA_R_16BF CUDA_R_16F CUDA_R_16F CUDA_R_8I CUDA_R_32F CUDA_R_16BFCUDA_R_32F CUDA_R_16F CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_C_32F CUDA_C_8I CUDA_C_32F CUBLAS_COMPUTE_32F_FAST_16F or CUBLAS_COMPUTE_32F_FAST_16BF or CUBLAS_COMPUTE_32F_FAST_TF32 CUBLAS_COMPUTE_64F or CUBLAS_COMPUTE_64F_PEDANTIC CUDA_R_32F CUDA_C_32F CUDA_R_64F CUDA_C_64F CUDA_C_32F CUDA_C_32F CUDA_R_32F CUDA_R_32F CUDA_C_32F CUDA_C_32F CUDA_R_64F CUDA_R_64F CUDA_C_64F CUDA_C_64F If Atype is CUDA_R_16F or CUDA_R_16BF, or computeType is any of the FAST options, or when math mode or algo enable fast math modes, pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is recommended that they meet the following rule: ? if k%8==0 then ensure intptr_t(ptr) % 16 == 0, ? if k%2==0 then ensure intptr_t(ptr) % 4 == 0. Note: Compute types CUBLAS_COMPUTE_32I and CUBLAS_COMPUTE_32I_PEDANTIC are only sup- ported with all pointers A[i], B[i] being 4-byte aligned and lda, ldb being multiples of 4. For a better performance, it is also recommended that IMMA kernels requirements for the regular data ordering listed here are met. The possible error values returned by this function and their meanings are listed below. 4.8. BLAS-like Extension 167 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. cublasGemmBatchedEx() is only supported for GPU with architecture capabilities equal to or greater than 5.0. The combination of the parameters Atype,Btype and Ctype or the algorithm,algois not supported. ? If m < 0 or n < 0 or k < 0 or ? if transa or transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) or ? Atype or Btype or Ctype or algo or com- puteType is not supported CUBLAS_STATUS_EXECUTION_FAILED The function failed to launch on the GPU. Also refer to: sgemm. 4.8.14. cublasGemmStridedBatchedEx() cublasStatus_t cublasGemmStridedBatchedEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void *alpha, const void *A, cudaDataType_t Atype, int lda, long long int strideA, const void *B, cudaDataType_t Btype, int ldb, long long int strideB, const void *beta, void *C, cudaDataType_t Ctype, int ldc, (continues on next page) 168 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 #if defined( cplusplus) long long int strideC, int batchCount, cublasComputeType_t computeType, cublasGemmAlgo_t algo) (continued from previous page) cublasStatus_t cublasGemmStridedBatchedEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void *alpha, const void *A, cudaDataType Atype, int lda, long long int strideA, const void *B, cudaDataType Btype, int ldb, long long int strideB, const void *beta, void *C, cudaDataType Ctype, int ldc, long long int strideC, int batchCount, cudaDataType computeType, cublasGemmAlgo_t algo) #endif This function supports the 64-bit Integer Interface. This function is an extension of cublas<t>gemmStridedBatched that performs the matrix-matrix mul- tiplication of a batch of matrices and allows the user to individually specify the data types for each of the A, B and C matrices, the precision of computation and the GEMM algorithm to be run. Like cublas<t>gemmStridedBatched, the batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance. Pointers to A, B and C matrices for the first instance are passed to the function by the user along with the offsets in number of elements - strideA, strideB and strideC that determine the locations of input and output matrices in future instances. Note: The second variant of cublasGemmStridedBatchedEx() function is provided for backward com- patibility with C++ applications code, where the computeType parameter is of cudaDataType_t instead of cublasComputeType_t. C applications would still compile with the updated function signature. C + i ? strideC = ?op(A + i ? strideA)op(B + i ? strideB) + ?(C + i ? strideC), for i ? [0, batchCount ? 1] where ? and ? are scalars, and A , B and C are arrays of pointers to matrices stored in column-major format with dimensions op(A[i]) m ? k , op(B[i]) k ? n and C[i] m ? n , respectively. Also, for matrix A 4.8. BLAS-like Extension 169 cuBLAS, Release 12.3 op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C Note: C[i] matrices must not overlap, i.e. the individual gemm operations must be computable inde- pendently; otherwise, undefined behavior is expected. On certain problem sizes, it might be advantageous to make multiple calls to cublas<t>gemm in dif- ferent CUDA streams, rather than use this API. Note: In the table below, we use A[i], B[i], C[i] as notation for A, B and C matrices in the ith instance of the batch, implicitly assuming they are respectively offsets in number of elements strideA, strideB, strideC away from A[i-1], B[i-1], C[i-1]. The unit for the offset is number of elements and must not be zero . 170 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Param. Mem- ory In/outMeaning han- dle transa transb m n k al- pha A Atype lda strideA B Btype ldb strideB beta host or de- vice de- vice de- vice host or de- vice in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Operation op(A[i]) that is non- or (conj.) transpose. Operation op(B[i]) that is non- or (conj.) transpose. Number of rows of matrix op(A[i]) and C[i]. Number of columns of matrix op(B[i]) and C[i]. Number of columns of op(A[i]) and rows of op(B[i]). Scaling factor for A*B of the type that corresponds to the computeType and Ctype, see the table below for details. Pointer to <Atype> matrix, A, corresponds to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. Enumerant specifying the datatype of A. Leading dimension of two-dimensional array used to store the matrix A[i]. Value of type long long int that gives the offset in number of elements between A[i] and A[i+1]. Pointer to <Btype> matrix, B, corresponds to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1,n) otherwise. Enumerant specifying the datatype of B. Leading dimension of two-dimensional array used to store matrix B[i]. Value of type long long int that gives the offset in number of elements between B[i] and B[i+1]. Scaling factor for C of the type that corresponds to the computeType and Ctype, see the table below for details. If beta==0, C[i] does not have to be a valid input. C de- vice in/outPointer to <Ctype> matrix, C, corresponds to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). Matrices C[i] should not overlap; otherwise, undefined behavior is expected. Ctype in- put Enumerant specifying the datatype of C. 4l.d8c. BLAS-like Einxt-ensLioenading dimension of a two-dimensional array used to store each matrix C[i1]7.1 put strideC in- Value of type long long int that gives the offset in number of elements between cuBLAS, Release 12.3 cublasGemmStridedBatchedEx() supports the following Compute Type, Scale Type, Atype/Btype, and Ctype: Compute Type CUBLAS_COMPUTE_16F or CUBLAS_COMPUTE_16F_PEDANTIC Scale Type (alpha and beta) CUDA_R_16F Atype/Btype Ctype CUDA_R_16F CUDA_R_16F CUBLAS_COMPUTE_32I or CUBLAS_COMPUTE_32I_PEDANTIC CUDA_R_32I CUDA_R_8I CUDA_R_32I CUBLAS_COMPUTE_32F or CUBLAS_COMPUTE_32F_PEDANTIC CUDA_R_32F CUDA_R_16BFCUDA_R_16BF CUDA_R_16F CUDA_R_16F CUDA_R_8I CUDA_R_32F CUDA_R_16BFCUDA_R_32F CUDA_R_16F CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_C_32F CUDA_C_8I CUDA_C_32F CUBLAS_COMPUTE_32F_FAST_16F or CUBLAS_COMPUTE_32F_FAST_16BF or CUBLAS_COMPUTE_32F_FAST_TF32 CUBLAS_COMPUTE_64F or CUBLAS_COMPUTE_64F_PEDANTIC CUDA_R_32F CUDA_C_32F CUDA_R_64F CUDA_C_64F CUDA_C_32F CUDA_C_32F CUDA_R_32F CUDA_R_32F CUDA_C_32F CUDA_C_32F CUDA_R_64F CUDA_R_64F CUDA_C_64F CUDA_C_64F Note: Compute types CUBLAS_COMPUTE_32I and CUBLAS_COMPUTE_32I_PEDANTIC are only sup- ported with all pointers A[i], B[i] being 4-byte aligned and lda, ldb being multiples of 4. For a better performance, it is also recommended that IMMA kernels requirements for the regular data ordering listed here are met. The possible error values returned by this function and their meanings are listed below. 172 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. cublasGemmBatchedEx() is only supported for GPU with architecture capabilities equal or greater than 5.0. The combination of the parameters Atype,Btype and Ctype or the algorithm,algois not supported. ? If m < 0 or n < 0 or k < 0 or ? if transa or transb != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, m) if transa == CUBLAS_OP_N and lda < max(1, k) other- wise or ? if ldb < max(1, k) if transb == CUBLAS_OP_N and ldb < max(1, n) other- wise or ? if ldc < max(1, m) or ? Atype or Btype or Ctype or algo or com- puteType is not supported CUBLAS_STATUS_EXECUTION_FAILED The function failed to launch on the GPU Also refer to: sgemm. 4.8.15. cublasCsyrkEx() cublasStatus_t cublasCsyrkEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const void *A, cudaDataType Atype, int lda, const float *beta, cuComplex *C, cudaDataType Ctype, int ldc) This function supports the 64-bit Integer Interface. This function is an extension of cublasCsyrk() where the input matrix and output matrix can have a lower precision but the computation is still done in the type cuComplex This function performs the symmetric rank- k update 4.8. BLAS-like Extension 173 cuBLAS, Release 12.3 C = ?op(A)op(A)T + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ?? A if transa == CUBLAS_OP_N Note: This routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A Atype lda beta ory host or device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Indicates if matrix C lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. Operation op(A) that is non- or transpose. Number of rows of matrix op(A) and C. Number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if trans == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. Enumerant specifying the datatype of matrix A. Leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). Ctype ldc in- put in- put Enumerant specifying the datatype of matrix C. Leading dimension of two-dimensional array used to store matrix C. The matrix types combinations supported for cublasCsyrkEx() are listed below: 174 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 A CUDA_C_8I CUDA_C_32F C CUDA_C_32F CUDA_C_32F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. ? If n < 0 or k < 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? Atype or Ctype is not supported CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_EXECUTION_FAILED The combination of the parameters Atype and Ctype is not supported. The device has a compute capability lower than 5.0. The function failed to launch on the GPU. For references please refer to: ssyrk, dsyrk, csyrk, zsyrk 4.8.16. cublasCsyrk3mEx() cublasStatus_t cublasCsyrk3mEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const void *A, cudaDataType Atype, int lda, const float *beta, cuComplex *C, cudaDataType Ctype, int ldc) This function supports the 64-bit Integer Interface. 4.8. BLAS-like Extension 175 cuBLAS, Release 12.3 This function is an extension of cublasCsyrk() where the input matrix and output matrix can have a lower precision but the computation is still done in the type cuComplex. This routine is implemented using the Gauss complexity reduction algorithm which can lead to an increase in performance up to 25% This function performs the symmetric rank- k update C = ?op(A)op(A)T + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ?? A if transa == CUBLAS_OP_N Note: This routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A Atype lda beta ory host or device device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Indicates if matrix C lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. Operation op(A) that is non- or transpose. Number of rows of matrix op(A) and C. Number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if trans == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. Enumerant specifying the datatype of matrix A. Leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). Ctype ldc in- put in- put Enumerant specifying the datatype of matrix C. Leading dimension of two-dimensional array used to store matrix C. 176 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 The matrix types combinations supported for cublasCsyrk3mEx() are listed below : A CUDA_C_8I CUDA_C_32F C CUDA_C_32F CUDA_C_32F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. ? If n < 0 or k < 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? Atype or Ctype is not supported CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_EXECUTION_FAILED The combination of the parameters Atype and Ctype is not supported. The device has a compute capability lower than 5.0. The function failed to launch on the GPU. For references please refer to: ssyrk, dsyrk, csyrk, zsyrk 4.8.17. cublasCherkEx() cublasStatus_t cublasCherkEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const void *A, cudaDataType Atype, int lda, const float *beta, cuComplex *C, cudaDataType Ctype, int ldc) 4.8. BLAS-like Extension 177 cuBLAS, Release 12.3 This function supports the 64-bit Integer Interface. This function is an extension of cublasCherk() where the input matrix and output matrix can have a lower precision but the computation is still done in the type cuComplex This function performs the Hermitian rank- k update C = ?op(A)op(A)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ?? A if transa == CUBLAS_OP_N Note: This routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A Atype lda beta ory host or device device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. Operation op(A) that is non- or (conj.) transpose. Number of rows of matrix op(A) and C. Number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. Enumerant specifying the datatype of matrix A. Leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. Ctype ldc in- put in- put Enumerant specifying the datatype of matrix C. Leading dimension of two-dimensional array used to store matrix C. 178 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 The matrix types combinations supported for cublasCherkEx() are listed in the following table: A CUDA_C_8I CUDA_C_32F C CUDA_C_32F CUDA_C_32F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. ? If n < 0 or k < 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? Atype or Ctype is not supported CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_EXECUTION_FAILED The combination of the parameters Atype and Ctype is not supported. The device has a compute capability lower than 5.0. The function failed to launch on the GPU. For references please refer to: cherk 4.8.18. cublasCherk3mEx() cublasStatus_t cublasCherk3mEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const void *A, cudaDataType Atype, int lda, const float *beta, cuComplex *C, cudaDataType Ctype, int ldc) 4.8. BLAS-like Extension 179 cuBLAS, Release 12.3 This function supports the 64-bit Integer Interface. This function is an extension of cublasCherk() where the input matrix and output matrix can have a lower precision but the computation is still done in the type cuComplex. This routine is implemented using the Gauss complexity reduction algorithm which can lead to an increase in performance up to 25% This function performs the Hermitian rank- k update C = ?op(A)op(A)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ?? A if transa == CUBLAS_OP_N Note: This routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0 180 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A Atype lda beta ory host or device device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put Handle to the cuBLAS library context. Indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. Operation op(A) that is non- or (conj.) transpose. Number of rows of matrix op(A) and C. Number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. Enumerant specifying the datatype of matrix A. Leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. Ctype ldc in- put in- put Enumerant specifying the datatype of matrix C. Leading dimension of two-dimensional array used to store matrix C. The matrix types combinations supported for cublasCherk3mEx() are listed in the following table: A CUDA_C_8I CUDA_C_32F C CUDA_C_32F CUDA_C_32F The possible error values returned by this function and their meanings are listed below. 4.8. BLAS-like Extension 181 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning The operation completed successfully. The library was not initialized. ? If n < 0 or k < 0 or ? if uplo != CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_LOWER or ? if trans != CUBLAS_OP_N, CUBLAS_OP_C, CUBLAS_OP_T or ? if lda < max(1, n) if trans == CUBLAS_OP_N and lda < max(1, k) otherwise or ? if ldc < max(1, n) or ? Atype or Ctype is not supported CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_EXECUTION_FAILED The combination of the parameters Atype and Ctype is not supported. The device has a compute capability lower than 5.0. The function failed to launch on the GPU. For references please refer to: cherk 4.8.19. cublasNrm2Ex() cublasStatus_t cublasNrm2Ex( cublasHandle_t handle, int n, const void *x, cudaDataType xType, int incx, void *result, cudaDataType resultType, cudaDataType executionType) This function supports the 64-bit Integer Interface. This function is an API generalization of the routine cublas<t>nrm2 where input data, output data and compute type can be specified independently. This function computes the Euclidean norm of the vector x. The code uses a multiphase model of accumulation to avoid intermediate underflow and overflow, with the result being equivalent to n i=1 (x[j] ? x[j]) where j = 1 + (i ? 1) ? incx in exact arithmetic. Notice that the last equation re- flects 1-based indexing used for compatibility with Fortran. 182 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Param. handle n x xType incx result resultType execution- Type Memory device host or de- vice In/out input input input input input out- put input input Meaning handle to the cuBLAS library context. number of elements in the vector x. <type> vector with n elements. enumerant specifying the datatype of vector x. stride between consecutive elements of x. the resulting norm, which is 0.0 if n,incx<=0. enumerant specifying the datatype of the result. enumerant specifying the datatype in which the computation is executed. The datatypes combinations currently supported for cublasNrm2Ex() are listed below : x CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_C_32F CUDA_R_64F CUDA_C_64F result CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_R_64F execution CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_R_64F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_INVALID_VALUE Meaning the operation completed successfully the library was not initialized the reduction buffer could not be allocated the combination of the parameters xType, re- sultType and executionType is not supported the function failed to launch on the GPU ? If xType or resultType or execution- Type is not supported or ? result == NULL For references please refer to: snrm2, dnrm2, scnrm2, dznrm2 4.8. BLAS-like Extension 183 cuBLAS, Release 12.3 4.8.20. cublasAxpyEx() cublasStatus_t cublasAxpyEx (cublasHandle_t handle, int n, const void *alpha, cudaDataType alphaType, const void *x, cudaDataType xType, int incx, void *y, cudaDataType yType, int incy, cudaDataType executiontype); This function supports the 64-bit Integer Interface. This function is an API generalization of the routine cublas<t>axpy where input data, output data and compute type can be specified independently. This function multiplies the vector x by the scalar ? and adds it to the vector y overwriting the latest vector with the result. Hence, the performed operation is y[j] = ? x[k] + y[j] for i = 1, . . . , n , k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle n alpha alphaType x xType incx y yType incy execution- Type Memory host or de- vice device device In/out input input input input input input input in/out input input input Meaning Handle to the cuBLAS library context. Number of elements in the vector x and y. <type> scalar used for multiplication. Enumerant specifying the datatype of scalar alpha. <type> vector with n elements. Enumerant specifying the datatype of vector x. Stride between consecutive elements of x. <type> vector with n elements. Enumerant specifying the datatype of vector y. Stride between consecutive elements of y. Enumerant specifying the datatype in which the computation is executed. The datatypes combinations currently supported for cublasAxpyEx() are listed in the following table: 184 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 alpha CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F x CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F y CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F execution CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS Meaning The operation completed successfully. CUBLAS_STATUS_NOT_INITIALTIhZeElDibrary was not initialized. CUBLAS_STATUS_NOT_SUPPORTTEhDe combination of the parameters xType,yType, and execution- Type is not supported. CUBLAS_STATUS_EXECUTION_FTAhIeLfEuDnction failed to launch on the GPU. CUBLAS_STATUS_INVALID_VALaUlEphaType or xType or yType or executionType is not supported. For references please refer to: saxpy, daxpy, caxpy, zaxpy 4.8.21. cublasDotEx() cublasStatus_t cublasDotEx (cublasHandle_t handle, int n, const void *x, cudaDataType xType, int incx, const void *y, cudaDataType yType, int incy, void *result, cudaDataType resultType, cudaDataType executionType); cublasStatus_t cublasDotcEx (cublasHandle_t handle, int n, const void *x, cudaDataType xType, int incx, const void *y, cudaDataType yType, int incy, void *result, (continues on next page) 4.8. BLAS-like Extension 185 cuBLAS, Release 12.3 (continued from previous page) cudaDataType resultType, cudaDataType executionType); These functions are an API generalization of the routines cublas<t>dot and cublas<t>dotc where in- put data, output data and compute type can be specified independently. Note: cublas<t>dotc is dot product conjugated, cublas<t>dotu is dot product unconjugated. This function computes the dot product of vectors x and y. Hence, the result is ?n (x[k] ? y[j]) where k = 1 + (i 1) incx and j = 1 + (i 1) incy . Notice that in the first equation the conjugate of the element of vector x should be used if the function name ends in character ‘c’ and that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle n x xType incx y yType incy result resultType execution- Type Memory device device host or de- vice In/out input input input input input input input input out- put input input Meaning Handle to the cuBLAS library context. Number of elements in the vectors x and y. <type> vector with n elements. Enumerant specifying the datatype of vector x. Stride between consecutive elements of x. <type> vector with n elements. Enumerant specifying the datatype of vector y. Stride between consecutive elements of y. The resulting dot product, which is 0.0 if n<=0. Enumerant specifying the datatype of the result. Enumerant specifying the datatype in which the computation is executed. The datatypes combinations currently supported for cublasDotEx() and cublasDotcEx() are listed below: x CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F y CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F result CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F execution CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F The possible error values returned by this function and their meanings are listed in the following table: 186 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS Meaning The operation completed successfully. CUBLAS_STATUS_NOT_INITITAhLeIliZbEraDry was not initialized. CUBLAS_STATUS_ALLOC_FAITLhEeDreduction buffer could not be allocated. CUBLAS_STATUS_NOT_SUPPOTRhTeEcDombination of the parameters xType,yType, resultType and executionType is not supported. CUBLAS_STATUS_EXECUTIONT_hFeAfIuLnEcDtion failed to launch on the GPU. CUBLAS_STATUS_INVALID_VxATLyUpEe or yType or resultType or executionType is not supported. For references please refer to: sdot, ddot, cdotu, cdotc, zdotu, zdotc 4.8.22. cublasRotEx() cublasStatus_t cublasRotEx(cublasHandle_t handle, int n, void *x, cudaDataType xType, int incx, void *y, cudaDataType yType, int incy, const void *c, ?* host or device pointer *? const void *s, cudaDataType csType, cudaDataType executiontype); This function supports the 64-bit Integer Interface. This function is an extension to the routine cublas<t>rot where input data, output data, cosine/sine type, and compute type can be specified independently. This function applies Givens rotation matrix (i.e., rotation in the x,y plane counter-clockwise by angle defined by cos(alpha)=c, sin(alpha)=s): G = ? c s? ? to vectors x and y. Hence, the result is x[k] = c x[k] + s y[j] and y[j] = s x[k] + c y[j] where k = 1 + (i 1) incx and j = 1 +(i 1) incy . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. 4.8. BLAS-like Extension 187 cuBLAS, Release 12.3 Param. handle n x xType incx y yType incy c s csType execution- Type Memory device device host or de- vice host or de- vice In/out input input in/out input input in/out input input input input input input Meaning handle to the cuBLAS library context. number of elements in the vectors x and y. <type> vector with n elements. enumerant specifying the datatype of vector x. stride between consecutive elements of x. <type> vector with n elements. enumerant specifying the datatype of vector y. stride between consecutive elements of y. cosine element of the rotation matrix. sine element of the rotation matrix. enumerant specifying the datatype of c and s. enumerant specifying the datatype in which the computation is executed. The datatypes combinations currently supported for cublasRotEx() are listed below : execution- Type CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F xType / yType CUDA_R_16BF CUDA_R_16F CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_32F CUDA_C_64F CUDA_C_64F csType CUDA_R_16BF CUDA_R_16F CUDA_R_32F CUDA_R_64F CUDA_R_32F CUDA_C_32F CUDA_R_64F CUDA_C_64F The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the function failed to launch on the GPU For references please refer to: srot, drot, crot, csrot, zrot, zdrot 188 Chapter 4. Using the cuBLAS API cuBLAS, Release 12.3 4.8.23. cublasScalEx() cublasStatus_t cublasScalEx(cublasHandle_t handle, int n, const void *alpha, cudaDataType alphaType, void *x, cudaDataType xType, int incx, cudaDataType executionType); This function supports the 64-bit Integer Interface. This function scales the vector x by the scalar ? and overwrites it with the result. Hence, the performed operation is x[j] = ? x[j] for i = 1, . . . , n and j = 1 + (i 1) incx . Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran. Param. handle n alpha alphaType x xType incx execution- Type Memory host or de- vice device In/out input input input input in/out input input input Meaning handle to the cuBLAS library context. number of elements in the vector x. <type> scalar used for multiplication. enumerant specifying the datatype of scalar alpha. <type> vector with n elements. enumerant specifying the datatype of vector x. stride between consecutive elements of x. enumerant specifying the datatype in which the computation is executed. The datatypes combinations currently supported for cublasScalEx() are listed below : alpha CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F x CUDA_R_16F CUDA_R_16BF CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F execution CUDA_R_32F CUDA_R_32F CUDA_R_32F CUDA_R_64F CUDA_C_32F CUDA_C_64F The possible error values returned by this function and their meanings are listed below. 4.8. BLAS-like Extension 189 cuBLAS, Release 12.3 Error Value CUBLAS_STATUS_SUCCESS Meaning the operation completed successfully CUBLAS_STATUS_NOT_INITIALItZhEeDlibrary was not initialized CUBLAS_STATUS_NOT_SUPPORTEtDhe combination of the parameters xType and executionType is not supported CUBLAS_STATUS_EXECUTION_FAtIhLeEDfunction failed to launch on the GPU CUBLAS_STATUS_INVALID_VALUaElphaType or xType or executionType is not supported For references please refer to: sscal, dscal, csscal, cscal, zdscal, zscal 190 Chapter 4. Using the cuBLAS API Chapter 5. Using the cuBLASLt API 5.1. General Description The cuBLASLt library is a new lightweight library dedicated to GEneral Matrix-to-matrix Multiply (GEMM) operations with a new flexible API. This new library adds flexibility in matrix data layouts, input types, compute types, and also in choosing the algorithmic implementations and heuristics through parameter programmability. Once a set of options for the intended GEMM operation are identified by the user, these options can be used repeatedly for different inputs. This is analogous to how cuFFT and FFTW first create a plan and reuse for same size and type FFTs with different input data. Note: The cuBLASLt library does not guarantee the support of all possible sizes and configurations, however, since CUDA 12.2 update 2, the problem size limitations on m, n, and batch size have been largely resolved. The main focus of the library is to provide the most performant kernels, which might have some implied limitations. Some non-standard configurations may require a user to handle them manually, typically by decomposing the problem into smaller parts (see Problem Size Limitations). 5.1.1. Problem Size Limitations There are inherent problem size limitations that are a result of limitations in CUDA grid dimensions. For example, many kernels do not support batch sizes greater than 65535 due to a limitation on the z dimension of a grid. There are similar restriction on the m and n values for a given problem. In cases where a problem cannot be run by a single kernel, cuBLASLt will attempt to decompose the problem into multiple sub-problems and solve it by running the kernel on each sub-problem. There are some restrictions on cuBLASLt internal problem decomposition which are summarized below: ? Amax computations are not supported. This means that CUBLASLT_MATMUL_DESC_AMAX_D_POINTER and CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_AMAX_POINT must be left unset (see cublasLtMatmulDescAttributes_t) ? All matrix layouts must have CUBLASLT_MATRIX_LAYOUT_ORDER set to CUBLASLT_ORDER_COL (see cublasLtOrder_t) ? cuBLASLt will not partition along the n dimension when CUBLASLT_MATMUL_DESC_EPILOGUE is set to CUBLASLT_EPILOGUE_DRELU_BGRAD or CUBLASLT_EPILOGUE_DGELU_BGRAD (see cublasLtEpilogue_t) 191 cuBLAS, Release 12.3 To overcome these limitations, a user may want to partition the problem themself, launch kernels for each sub-problem, and compute any necessary reductions to combine the results. 5.1.2. Heuristics Cache cuBLASLt uses heuristics to pick the most suitable matmul kernel for execution based on the problem sizes, GPU configuration, and other parameters. This requires performing some computations on the host CPU, which could take tens of microseconds. To overcome this overhead, it is recommended to query the heuristics once using cublasLtMatmulAlgoGetHeuristic() and then reuse the result for subsequent computations using cublasLtMatmul(). For the cases where querying heuristics once and then reusing them is not feasible, cuBLASLt imple- ments a heuristics cache that maps matmul problems to kernels previously selected by heuristics. The heuristics cache uses an LRU-like eviction policy and is thread-safe. The user can control the heuristics cache capacity with the CUBLASLT_HEURISTICS_CACHE_CAPACITY environment variable or with the cublasLtHeuristicsCacheSetCapacity() function which has higher precedence. The capacity is measured in number of entries and might be rounded up to the nearest multiple of some factor for performance reasons. Each entry takes about 360 bytes but is subject to change. The default capacity is 8192 entries. Note: Setting capacity to zero disables the cache completely. This can be useful for workloads that do not have a steady state and for which cache operations may have higher overhead than regular heuristics computations. Note: The cache is not ideal for performance reasons, so it is sometimes necessary to increase its capacity 1.5x-2.x over the anticipated number of unique matmul problems to achieve a nearly perfect hit rate. See also: cublasLtHeuristicsCacheGetCapacity(), cublasLtHeuristicsCacheSetCapacity(). 5.1.3. cuBLASLt Logging cuBLASLt logging mechanism can be enabled by setting the following environment variables before launching the target application: CUBLASLT_LOG_LEVEL=<level> - while level is one of the following levels: ? “0” - Off - logging is disabled (default) ? “1” - Error - only errors will be logged ? “2” - Trace - API calls that launch CUDA kernels will log their parameters and important informa- tion ? “3” - Hints - hints that can potentially improve the application’s performance ? “4” - Info - provides general information about the library execution, may contain details about heuristic status ? “5” - API Trace - API calls will log their parameter and important information 192 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 CUBLASLT_LOG_MASK=<mask> - while mask is a combination of the following masks: ? “0” - Off ? “1” - Error ? “2” - Trace ? “4” - Hints ? “8” - Info ? “16” - API Trace CUBLASLT_LOG_FILE=<file_name> - while file name is a path to a logging file. File name may contain %i, that will be replaced with the process ID. for example “<file_name>_%i.log”. If CUBLASLT_LOG_FILE is not defined, the log messages are printed to stdout. Another option is to use the experimental cuBLASLt logging API. See: cublasLtLoggerSetCallback(), cublasLtLoggerSetFile(), cublasLtLoggerOpenFile(), cublasLtLogger- SetLevel(), cublasLtLoggerSetMask(), cublasLtLoggerForceDisable() 5.1.4. 8-bit Floating Point Data Types (FP8) Usage FP8 was first introduced with Ada and Hopper GPUs (compute capability 8.9 and above) and is designed to further accelerate matrix multiplications. There are two types of FP8 avaiable: ? CUDA_R_8F_E4M3 is designed to be accurate at a smaller dynamic range than half precision. The E4 and M3 represent a 4-bit exponent and a 3-bit mantissa respectively. For more details, see nv fp8 e4m3. ? CUDA_R_8F_E5M2 is designed to be accurate at a similar dynamic range as half precision. The E5 and M2 represent a 5-bit exponent and a 2-bit mantissa respectively. For more information see nv fp8 e5m2. Note: Unless otherwise stated, FP8 refers to both CUDA_R_8F_E4M3 and CUDA_R_8F_E5M2. In order to maintain accurate FP8 matrix multiplications, we define native compute FP8 matrix multi- plication as follows: D = scaleD · (? · scaleA · scaleB · op(A)op(B) + ? · scaleC · C) where A, B, and C are input matrices, and scaleA, scaleB, scaleC, scaleD, alpha, and beta are input scalars. This differs from the other matrix multiplication routines because of this addition of scaling factors for each matrix. The scaleA, scaleB, and scaleC are used for de-quantization, and scaleD is used for quantization. Note that all the scaling factors are applied multiplicatively. This means that sometimes it is necessary to use a scaling factor or its reciprocal depending on the context in which it is applied. For more information on FP8, see cublasLtMatmul() and cublasLtMatmulDescAttributes_t. For FP8 matrix multiplications, epilogues and amaxD may be computed as follows: Dt?mp, Auxt?mp = Epilogue(? · scaleA · scaleB · op(A)op(B) + ? · scaleC · C) amaxD = absmax(Dt?mp) amaxAu? = absmax(Auxt?mp) D = scaleD ? Dt?mp Aux = scaleAu? ? Auxt?mp 5.1. General Description 193 cuBLAS, Release 12.3 Here Aux is an auxiliary output of an epilogue function like GELU, scaleAux is an optional scal- ing factor that can be applied to Aux, and amaxAux is the maximum absolute value in Aux be- fore scaling. For more information, see attributes CUBLASLT_MATMUL_DESC_AMAX_D_POINTER and CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_AMAX_POINTER in cublasLtMatmulDescAttributes_t. 5.1.5. Disabling CPU Instructions As mentioned in the Heuristics Cache section, cuBLASLt heuristics perform some compute-intensive operations on the host CPU. To speed-up the operations, the implementation detects CPU capabilities and may use special instructions, such as Advanced Vector Extensions (AVX) on x86-64 CPUs. However, in some rare cases this might be not desirable. For instance, using advanced instructions may result in CPU running at a lower frequency, which would affect performance of the other host code. The user can optionally instruct the cuBLASLt library to not use some CPU instructions with the CUBLASLT_DISABLE_CPU_INSTRUCTIONS_MASK environment variable or with the cublasLtDis- ableCpuInstructionsSetMask() function which has higher precedence. The default mask is 0, meaning that there are no restrictions. Please check cublasLtDisableCpuInstructionsSetMask() for more information. 5.2. cuBLASLt Code Examples Please visit https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuBLASLt for updated code examples. 5.3. cuBLASLt Datatypes Reference 5.3.1. cublasLtClusterShape_t cublasLtClusterShape_t is an enumerated type used to configure thread block cluster dimensions. Thread block clusters add an optional hierarchical level and are made up of thread blocks. Similar to thread blocks, these can be one, two, or three-dimensional. See also Thread Block Clusters. Value CUBLASLT_CLUSTER_SHAPE_AUTO CUBLASLT_CLUSTER_SHAPE_1x1x1 CUBLASLT_CLUSTER_SHAPE_1x2x1 CUBLASLT_CLUSTER_SHAPE_1x4x1 CUBLASLT_CLUSTER_SHAPE_2x1x1 CUBLASLT_CLUSTER_SHAPE_2x2x1 Description Cluster shape is automatically selected. Cluster shape is 1 x 1 x 1. Cluster shape is 1 x 2 x 1. Cluster shape is 1 x 4 x 1. Cluster shape is 2 x 1 x 1. Cluster shape is 2 x 2 x 1. continues on next page 194 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Value Table 1 – continued from previous page Description CUBLASLT_CLUSTER_SHAPE_2x4x1 CUBLASLT_CLUSTER_SHAPE_4x1x1 CUBLASLT_CLUSTER_SHAPE_4x2x1 CUBLASLT_CLUSTER_SHAPE_4x4x1 CUBLASLT_CLUSTER_SHAPE_1x8x1 CUBLASLT_CLUSTER_SHAPE_8x1x1 CUBLASLT_CLUSTER_SHAPE_2x8x1 CUBLASLT_CLUSTER_SHAPE_8x2x1 CUBLASLT_CLUSTER_SHAPE_1x16x1 CUBLASLT_CLUSTER_SHAPE_16x1x1 CUBLASLT_CLUSTER_SHAPE_1x3x1 CUBLASLT_CLUSTER_SHAPE_1x5x1 CUBLASLT_CLUSTER_SHAPE_1x6x1 CUBLASLT_CLUSTER_SHAPE_1x7x1 CUBLASLT_CLUSTER_SHAPE_1x9x1 CUBLASLT_CLUSTER_SHAPE_1x10x1 CUBLASLT_CLUSTER_SHAPE_1x11x1 CUBLASLT_CLUSTER_SHAPE_1x12x1 CUBLASLT_CLUSTER_SHAPE_1x13x1 CUBLASLT_CLUSTER_SHAPE_1x14x1 CUBLASLT_CLUSTER_SHAPE_1x15x1 CUBLASLT_CLUSTER_SHAPE_2x3x1 CUBLASLT_CLUSTER_SHAPE_2x5x1 CUBLASLT_CLUSTER_SHAPE_2x6x1 CUBLASLT_CLUSTER_SHAPE_2x7x1 CUBLASLT_CLUSTER_SHAPE_3x1x1 CUBLASLT_CLUSTER_SHAPE_3x2x1 CUBLASLT_CLUSTER_SHAPE_3x3x1 CUBLASLT_CLUSTER_SHAPE_3x4x1 CUBLASLT_CLUSTER_SHAPE_3x5x1 CUBLASLT_CLUSTER_SHAPE_4x3x1 CUBLASLT_CLUSTER_SHAPE_5x1x1 Cluster shape is 2 x 4 x 1. Cluster shape is 4 x 1 x 1. Cluster shape is 4 x 2 x 1. Cluster shape is 4 x 4 x 1. Cluster shape is 1 x 8 x 1. Cluster shape is 8 x 1 x 1. Cluster shape is 2 x 8 x 1. Cluster shape is 8 x 2 x 1. Cluster shape is 1 x 16 x 1. Cluster shape is 16 x 1 x 1. Cluster shape is 1 x 3 x 1. Cluster shape is 1 x 5 x 1. Cluster shape is 1 x 6 x 1. Cluster shape is 1 x 7 x 1. Cluster shape is 1 x 9 x 1. Cluster shape is 1 x 10 x 1. Cluster shape is 1 x 11 x 1. Cluster shape is 1 x 12 x 1. Cluster shape is 1 x 13 x 1. Cluster shape is 1 x 14 x 1. Cluster shape is 1 x 15 x 1. Cluster shape is 2 x 3 x 1. Cluster shape is 2 x 5 x 1. Cluster shape is 2 x 6 x 1. Cluster shape is 2 x 7 x 1. Cluster shape is 3 x 1 x 1. Cluster shape is 3 x 2 x 1. Cluster shape is 3 x 3 x 1. Cluster shape is 3 x 4 x 1. Cluster shape is 3 x 5 x 1. Cluster shape is 4 x 3 x 1. Cluster shape is 5 x 1 x 1. continues on next page 5.3. cuBLASLt Datatypes Reference 195 cuBLAS, Release 12.3 Value Table 1 – continued from previous page Description CUBLASLT_CLUSTER_SHAPE_5x2x1 CUBLASLT_CLUSTER_SHAPE_5x3x1 CUBLASLT_CLUSTER_SHAPE_6x1x1 CUBLASLT_CLUSTER_SHAPE_6x2x1 CUBLASLT_CLUSTER_SHAPE_7x1x1 CUBLASLT_CLUSTER_SHAPE_7x2x1 CUBLASLT_CLUSTER_SHAPE_9x1x1 CUBLASLT_CLUSTER_SHAPE_10x1x1 CUBLASLT_CLUSTER_SHAPE_11x1x1 CUBLASLT_CLUSTER_SHAPE_12x1x1 CUBLASLT_CLUSTER_SHAPE_13x1x1 CUBLASLT_CLUSTER_SHAPE_14x1x1 CUBLASLT_CLUSTER_SHAPE_15x1x1 Cluster shape is 5 x 2 x 1. Cluster shape is 5 x 3 x 1. Cluster shape is 6 x 1 x 1. Cluster shape is 6 x 2 x 1. Cluster shape is 7 x 1 x 1. Cluster shape is 7 x 2 x 1. Cluster shape is 9 x 1 x 1. Cluster shape is 10 x 1 x 1. Cluster shape is 11 x 1 x 1. Cluster shape is 12 x 1 x 1. Cluster shape is 13 x 1 x 1. Cluster shape is 14 x 1 x 1. Cluster shape is 15 x 1 x 1. 5.3.2. cublasLtEpilogue_t The cublasLtEpilogue_t is an enum type to set the postprocessing options for the epilogue. 196 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Value Description CUBLASLT_EPILOGUE_DENFAoUsLpTecial postprocessing, just scale and quantize the results if necessary. = 1 CUBLASLT_EPILOGUE_RELAUpply ReLU point-wise transform to the results (x := max(x, 0)). = 2 CUBLASLT_EPILOGUE_RELAUp_pAlyUXReLU point-wise transform to the results (x := max(x, = 0)). This epilogue mode produces an extra output, see CUBLASLT_EPILOGUE_RELCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of cublasLt- | 128 MatmulDescAttributes_t. CUBLASLT_EPILOGUE_BIAASpply (broadcast) bias from the bias vector. Bias vector length must = 4 match matrix D rows, and it must be packed (such as stride between vec- tor elements is 1). Bias vector is broadcast to all columns and added be- fore applying the final postprocessing. CUBLASLT_EPILOGUE_RELAUp_pBlyIAbSias and then ReLU transform. = CUBLASLT_EPILOGUE_RELU | CUBLASLT_EPILOGUE_BIAS CUBLASLT_EPILOGUE_RELAUp_pAlyUbXi_aBsIAanSd then ReLU transform. This epilogue mode produces an = extra output, see CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of CUBLASLT_EPILOGUE_RELcuUb_lAaUsLXtMatmulDescAttributes_t. | CUBLASLT_EPILOGUE_BIAS CUBLASLT_EPILOGUE_DRAEpLpUly ReLu gradient to matmul output. Store ReLu gradient in = 8 | 128 the output matrix. This epilogue mode requires an extra input, see CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of cublasLtMat- mulDescAttributes_t. CUBLASLT_EPILOGUE_DRAEpLpUl_yBinGdReApDendently ReLu and Bias gradient to matmul output. Store ReLu = gradient in the output matrix, and Bias gradient in the bias buffer (see CUBLASLT_EPILOGUE_DRCEULUBLASLT_MATMUL_DESC_BIAS_POINTER). This epilogue mode requires | 16 an extra input, see CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of cublasLtMatmulDescAttributes_t. CUBLASLT_EPILOGUE_GEALUpply GELU point-wise transform to the results (x := GELU(x)). = 32 CUBLASLT_EPILOGUE_GEALUpp_AlyUGXELU point-wise transform to the results (x := GELU(x)). This epi- = logue mode outputs GELU input as a separate matrix (useful for training). CUBLASLT_EPILOGUE_GESLUee CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of cublasLtMat- | 128 mulDescAttributes_t. CUBLASLT_EPILOGUE_GEALUpp_BlyIABSias and then GELU transform1. = CUBLASLT_EPILOGUE_GELU | CUBLASLT_EPILOGUE_BIAS CUBLASLT_EPILOGUE_GEALUpp_AlyUXB_iaBsIAaSnd then GELU transformPage 198, 1. This epilogue mode = outputs GELU input as a separate matrix (useful for training). See CUBLASLT_EPILOGUE_GECLUUB_LAAUSXLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of cublasLtMat- | mulDescAttributes_t. CUBLASLT_EPILOGUE_BIAS 5C.3U. BcLuABSLLATS_ELPt IDLaOtGaUtyEp_eDsGRAEepLfpUelyrenGcEeLU gradient to matmul output. Store GELU gradient 1i9n7 = 64 | 128 the output matrix. This epilogue mode requires an extra input, see CUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER of cublasLtMat- mulDescAttributes_t. cuBLAS, Release 12.3 NOTES: 5.3.3. cublasLtHandle_t The cublasLtHandle_t type is a pointer type to an opaque structure holding the cuBLASLt library con- text. Use cublasLtCreate() to initialize the cuBLASLt library context and return a handle to an opaque structure holding the cuBLASLt library context, and use cublasLtDestroy() to destroy a previously cre- ated cuBLASLt library context descriptor and release the resources. Note: cuBLAS handle (cublasHandle_t) encapsulates a cuBLASLt handle. Any valid cublasHandle_t can be used in place of cublasLtHandle_t with a simple cast. However, unlike a cuBLAS handle, a cuBLASLt handle is not tied to any particular CUDA context. 5.3.4. cublasLtLoggerCallback_t cublasLtLoggerCallback_t is a callback function pointer type. A callback function can be set using cublasLtLoggerSetCallback(). Parameters: Parameter logLevel functionName message Memory Input / Output Output Output Output Description See cuBLASLt Logging. The name of the API that logged this message. The log message. 5.3.5. cublasLtMatmulAlgo_t cublasLtMatmulAlgo_t is an opaque structure holding the description of the matrix multiplication al- gorithm. This structure can be trivially serialized and later restored for use with the same version of cuBLAS library to save on selecting the right configuration again. 5.3.6. cublasLtMatmulAlgoCapAttributes_t cublasLtMatmulAlgoCapAttributes_t enumerates matrix multiplication algorithm capability attributes that can be retrieved from an initialized cublasLtMatmulAlgo_t descriptor using cublasLtMatmulAlgo- CapGetAttribute(). 1 GELU (Gaussian Error Linear Unit) is approximated by: 0.5x (1 + tanh (v2/? (x + 0.044715x?))) 198 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Value Description Data Type CUBLASLT_ALGSOup_pCoArPt_SfPoLrITsKp_liStU-KP.POBoRoTlean (0 or 1) to express if split-K implemen- tation is supported. 0 means no support, and supported otherwise. See CUBLASLT_ALGO_CONFIG_SPLITK_NUM of cublasLtMatmulAlgoConfigAt- tributes_t. CUBLASLT_ALGMOa_sCkAP_tRoEDeUxCpTrIeOsNs _StChHeEMtEy_pMeAs SKof reduction schemes supported, see cublasLtReductionScheme_t. If the reduction scheme is not masked out then it is supported. For example: int isRe- ductionSchemeComputeTypeSupported ? (reduction- SchemeMask & CUBLASLT_REDUCTION_SCHEME_COMPUTE_TYPE) == CUBLASLT_REDUCTION_SCHEME_COMPUTE_TYPE ? 1 : 0; CUBLASLT_ALGSOup_pCoArPt_CfToAr_SCWTIAZ-ZsLwINizGzli_nSgU. PPORBToolean (0 or 1) to express if CTA- swizzling implementation is supported. 0 means no support, and 1 means supported value of 1; other values are reserved. See also CUBLASLT_ALGO_CONFIG_CTA_SWIZZLING of cublasLtMatmulAlgoConfi- gAttributes_t. CUBLASLT_ALGSOup_pCoArPt_sStTriRdIeDdEDba_tBcAhT. C0Hm_SeUanPsPnOoRTsupport, supported otherwise. CUBLASLT_ALGSOup_pCoArPt_rOeUsuTl_tOsFo_uPtLAoCf Ep_laRcEeSU(DLT!_=SCUPinPODR=T alpha.A.B + beta.C). 0 means no support, supported otherwise. CUBLASLT_ALGSOyr_kC(AsyPm_UmPeLtOri_cSrUaPnPkOkRuTpdate)/herk (Hermitian rank k update) support (on top of regular gemm). 0 means no support, supported otherwise. CUBLASLT_ALGThOe_CtiAleP_idTsILEp_oIsDsSible to use. See cublasLtMatmulTile_t. If no tile ids are sup- ported then use CUBLASLT_MATMUL_TILE_UNDEFINED. Use cublasLtMatmu- lAlgoCapGetAttribute() with sizeInBytes = 0 to query the actual count. CUBLASLT_ALGThOe_CsAtaPg_SesTAidGsESp_oIsDsSible to use. See cublasLtMatmulStages_t. If no stages ids are supported then use CUBLASLT_MATMUL_STAGES_UNDEFINED. Use cublasLtMatmulAlgoCapGetAttribute() with sizeInBytes = 0 to query the actual count. int32_t uint32_t uint32_t int32_t int32_t int32_t Ar- ray of uint32_t Ar- ray of uint32_t CUBLASLT_ALGCOus_tCoAmP_oCpUtiSoTnOraMn_gOePisTfIOroNm_M0 tAoXCUBLASLT_ALGO_CAP_CUSTOM_OPTION_MAXint32_t (inclusive). See CUBLASLT_ALGO_CONFIG_CUSTOM_OPTION of cublasLtMat- mulAlgoConfigAttributes_t . CUBLASLT_ALGInOd_icCaAtPe_sMwAhTeHthMeOr tDhEe_aIMlgPorLithm is using regular compute or tensor operations. 0 means regular compute, 1 means tensor operations. DEPRECATED CUBLASLT_ALGInOd_icCaAtPe_wGhAeUtShSerIAtNhe_IaMlgPoLrithm implements the Gaussian optimization of com- plex matrix multiplication. 0 means regular compute; 1 means Gaussian. See cublasMath_t. DEPRECATED CUBLASLT_ALGInOd_icCaAtPe_sCwUhSeTtOhMer_tMhEeMalOgRorYi_thOmRDsEuRpports custom (not COL or ROW memory order). 0 means only COL and ROW memory order is allowed, non-zero means that algo might have different requirements. See cublasLtOrder_t. CUBLASLT_ALGBOitm_CaAsPk_ePnOuImNTeEraRt_inMgOtDheE_pMoiAntSeKr modes the algorithm supports. See cublasLt- PointerModeMask_t. CUBLASLT_ALGBOitm_CaAsPk_eEnPuILmOeGraUtEin_gMtAhSeKkinds of postprocessing algorithm supported in the epilogue. See cublasLtEpilogue_t. CUBLASLT_ALGSOup_pCoArPt_fLoDr_nNeEgGatAiTveIVlEd for all of the matrices. 0 means no support, supported otherwise. 5.3. cuBLASLt Datatypes Reference CUBLASLT_ALGDOet_aCilAsPa_bNoUuMt EaRlgIoCrAitLh_mIM’sPiLm_FpLleAmGeSntation that affect it’s numerical behavior. See cublasLtNumericalImplFlags_t. CUBLASLT_ALGMOin_iCmAuPm_MaIlNig_nAmLeIGnNt rMeEqNuiTre_Ad_fBoYr TAEmS atrix in bytes. int32_t int32_t int32_t uint32_t uint32_t uint32_t 199 uint64_t uint32_t cuBLAS, Release 12.3 5.3.7. cublasLtMatmulAlgoConfigAttributes_t cublasLtMatmulAlgoConfigAttributes_t is an enumerated type that contains the configuration at- tributes for cuBLASLt matrix multiply algorithms. The configuration attributes are algorithm-specific, and can be set. The attributes configuration of a given algorithm should agree with its capability at- tributes. Use cublasLtMatmulAlgoConfigGetAttribute() and cublasLtMatmulAlgoConfigSetAttribute() to get and set the attribute value of a matmul algorithm descriptor. Value Description Data Type CUBLASLT_ALGOR_eCaOdN-oFnIlGy_aIttDribute. Algorithm index. See cublasLtMatmulAlgoGetIds(). Set by cublasLtMatmulAlgoInit(). int32_t CUBLASLT_ALGOT_ileCONFIiGd_. TILE_ID See cublasLtMatmulTile_t. Default: uint32_t CUBLASLT_MATMUL_TILE_UNDEFINED. CUBLASLT_ALGOst_aCgOeNsFIG_SidT,AGES_IseDe cublasLtMatmulStages_t. Default: CUBLASLT_MATMUL_STAGES_UNDEFINED. CUBLASLT_ALGON_uCmObNeFrIoGf_KSPsLpIlitTsK. _IfNtUhMe number of K splits is greater than one, SPLITK_NUM parts of matrix multiplication will be computed in parallel. The results will be accumulated according to CUBLASLT_ALGO_CONFIG_REDUCTION_SCHEME. uint32_t uint32_t CUBLASLT_ALGOR_eCdOuNctFiIoGn_RsEcDhUeCmTIeONt_oSCHuEsMeE when splitK value > 1. Default: uint32_t CUBLASLT_REDUCTION_SCHEME_NONE. See cublasLtReductionScheme_t. CUBLASLT_ALGOE_nCaOblNeF/DIGis_aCbTleA_CSTWAIsZwZiLzIzlNinGg. Change mapping from CUDA grid coordinates to parts of the matrices. Possible values: 0 and 1; other values reserved. CUBLASLT_ALGOC_uCsOtoNmFIGop_tCiUoSnTvOaMlu_eO.PTEIaOcNh algorithm can support some custom options that don’t fit the description of the other configuration attributes. See the CUBLASLT_ALGO_CAP_CUSTOM_OPTION_MAX of cublasLtMatmulAlgoCap- Attributes_t for the accepted range for a specific case. CUBLASLT_ALGOIn_nCeOrNFsIhGa_pIeNNEIDR._SRHeAfPeEr_ItDo cublasLtMatmulInnerShape_t. Default: CUBLASLT_MATMUL_INNER_SHAPE_UNDEFINED. CUBLASLT_ALGOC_luCsOtNeFr IGs_hCaLpUeSTEIDR_. SHRAePfEe_r IDto cublasLtClusterShape_t. Default: CUBLASLT_CLUSTER_SHAPE_AUTO. uint32_t uint32_t uint16_t uint16_t 5.3.8. cublasLtMatmulDesc_t The cublasLtMatmulDesc_t is a pointer to an opaque structure holding the description of the matrix multiplication operation cublasLtMatmul(). A descriptor can be created by calling cublasLtMatmulDe- scCreate() and destroyed by calling cublasLtMatmulDescDestroy(). 200 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.3.9. cublasLtMatmulDescAttributes_t cublasLtMatmulDescAttributes_t is a descriptor structure containing the attributes that define the specifics of the matrix multiply operation. Use cublasLtMatmulDescGetAttribute() and cublasLtMat- mulDescSetAttribute() to get and set the attribute value of a matmul descriptor. 5.3. cuBLASLt Datatypes Reference 201 cuBLAS, Release 12.3 Attribute Name Description Data Type CUBLASLT_MATMUL_DESC_COMPUTCEo_mTpYuPtEe type. Defines the data type used for multiply and accumulate operations, and the accumulator during the matrix multiplication. See cublasCom- puteType_t. CUBLASLT_MATMUL_DESC_SCALE_STcaYlPeEtype. Defines the data type of the scaling factors alpha and beta. The accu- mulator value and the value from matrix C are typically converted to scale type be- fore final scaling. The value is then converted from scale type to the type of matrix D before storing in memory. Default value is aligned with int32_t int32_t CUBLASLT_MATMUL_DESC_COMPUTE_TYPE. See cudaDataType_t. CUBLASLT_MATMUL_DESC_POINTESRp_eMciOfiDeEs alpha and beta are passed by reference, whether they are scalars on the host or on the device, or device vectors. Default value is: CUBLASLT_POINTER_MODE_HOST (i.e., on the host). See cublasLt- PointerMode_t. CUBLASLT_MATMUL_DESC_TRANSASpecifies the type of transfor- mation operation that should be performed on matrix A. De- fault value is: CUBLAS_OP_N (i.e., non-transpose operation). See cublasOperation_t. CUBLASLT_MATMUL_DESC_TRANSBSpecifies the type of transfor- mation operation that should be performed on matrix B. De- fault value is: CUBLAS_OP_N (i.e., non-transpose operation). See cublasOperation_t. CUBLASLT_MATMUL_DESC_TRANSCSpecifies the type of transfor- mation operation that should be performed on matrix C. Currently only CUBLAS_OP_N is supported. Default value is: CUBLAS_OP_N (i.e., non- transpose operation). See cublasOperation_t. CUBLASLT_MATMUL_DESC_FILL_MInOdDicEates whether the lower or upper part of the dense matrix was filled, and con- int32_t int32_t int32_t int32_t int32_t 202 sequently should be used bCyhapter 5. Using the cuBLASLt API the function. Default value is: CUBLAS_FILL_MODE_FULL.See cublasFillMode_t. cuBLAS, Release 12.3 5.3.10. cublasLtMatmulHeuristicResult_t cublasLtMatmulHeuristicResult_t is a descriptor that holds the configured matrix multiplication algo- rithm descriptor and its runtime properties. Member cublasLt- Matmu- lAlgo_t algo size_t workspace- Size; cublasSta- tus_t state; float wavesCount; int re- served[4]; Description Must be initialized with cublasLtMatmulAlgoInit() if the pref- erence CUBLASLT_MATMUL_PERF_SEARCH_MODE is set to CUBLASLT_SEARCH_LIMITED_BY_ALGO_ID. See cublasLtMatmulSearch_t. Actual size of workspace memory required. Result status. Other fields are valid only if, after call to cublasLtMatmulAlgoGetHeuris- tic(), this member is set to CUBLAS_STATUS_SUCCESS. Waves count is a device utilization metric. A wavesCount value of 1.0f suggests that when the kernel is launched it will fully occupy the GPU. Reserved. 5.3.11. cublasLtMatmulInnerShape_t cublasLtMatmulInnerShape_t is an enumerated type used to configure various aspects of the internal kernel design. This does not impact the CUDA grid size. Value CUBLASLT_MATMUL_INNER_SHAPE_UNDEFINED CUBLASLT_MATMUL_INNER_SHAPE_MMA884 CUBLASLT_MATMUL_INNER_SHAPE_MMA1684 CUBLASLT_MATMUL_INNER_SHAPE_MMA1688 CUBLASLT_MATMUL_INNER_SHAPE_MMA16816 Description Inner shape is undefined. Inner shape is MMA884. Inner shape is MMA1684. Inner shape is MMA1688. Inner shape is MMA16816. 5.3.12. cublasLtMatmulPreference_t The cublasLtMatmulPreference_t is a pointer to an opaque structure holding the description of the preferences for cublasLtMatmulAlgoGetHeuristic() configuration. Use cublasLtMatmulPreferenceCre- ate() to create one instance of the descriptor and cublasLtMatmulPreferenceDestroy() to destroy a previously created descriptor and release the resources. 5.3. cuBLASLt Datatypes Reference 203 cuBLAS, Release 12.3 5.3.13. cublasLtMatmulPreferenceAttributes_t cublasLtMatmulPreferenceAttributes_t is an enumerated type used to apply algorithm search pref- erences while fine-tuning the heuristic function. Use cublasLtMatmulPreferenceGetAttribute() and cublasLtMatmulPreferenceSetAttribute() to get and set the attribute value of a matmul preference descriptor. Value Description Data Type CUBLASLT_MASTeMarUchL_PRmEFo_dSeE. ARCH_MSOeDeE CUBLASLT_SEARCH_BEST_FIT. cublasLtMatmulSearch_t. Default is uint32_t CUBLASLT_MAMTaMxiUmLu_PmRaElFlo_wMeAdXw_WorOkRspKaScPeAmCEe_mBoYrTyE. SDefault is 0 (no workspace memory al- lowed). CUBLASLT_MARTeMduUcLt_ioPnRsEcFh_RemEDeUmCaTsIOk.NS_eSeCcHuEbMlaEsL_tMRAedSuKctionScheme_t. Only algorithm con- figurations specifying CUBLASLT_ALGO_CONFIG_REDUCTION_SCHEME that is not masked out by this attribute are allowed. For example, a mask value of 0x03 will allow only INPLACE and COMPUTE_TYPE reduction schemes. Default is CUBLASLT_REDUCTION_SCHEME_MASK (i.e., allows all reduction schemes). CUBLASLT_MAMTiMniUmLu_mPRbEuFff_MerINa_liAgLnImGNenMtEfNorT_mAa_tBrYixTEAS(in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix A, which is not as strictly aligned as the algorithms need. Default is 256 bytes. CUBLASLT_MAMTiMniUmLu_mPRbEuFff_MerINa_liAgLnImGNenMtEfNorT_mBa_tBrYixTEBS(in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix B, which is not as strictly aligned as the algorithms need. Default is 256 bytes. CUBLASLT_MAMTiMniUmLu_mPRbEuFff_MerINa_liAgLnImGNenMtEfNorT_mCa_tBrYixTECS(in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix C, which is not as strictly aligned as the algorithms need. Default is 256 bytes. CUBLASLT_MAMTiMniUmLu_mPRbEuFff_MerINa_liAgLnImGNenMtEfNorT_mDa_tBrYixTEDS(in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix D, which is not as strictly aligned as the algorithms need. Default is 256 bytes. CUBLASLT_MAMTaMxiUmLu_PmREwFa_vMe AcXo_uWntA.VESSe_eCcOuUbNlaTsLtMatmulHeuristicResult_t::wavesCount. Selecting a non-zero value will exclude algorithms that report device utilization higher than specified. Default is 0.0f. CUBLASLT_MANTuMmUeLri_cPaRl iEmF_pIlMemPLe_nMtaAtiSoKn details mask. See cublasLtNumericalImplFlags_t. Fil- ters heuristic result to only include algorithms that use the allowed implemen- tations. default: uint64_t(-1) (allow everything) uint64_t uint32_t uint32_t uint32_t uint32_t uint32_t float uint64_t 204 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.3.14. cublasLtMatmulSearch_t cublasLtMatmulSearch_t is an enumerated type that contains the attributes for heuristics search type. Value CUBLASLT_SEARCH_BEST_FIT Description Request heuristics for the best algorithm for the given use case. Data Type CUBLASLT_SEARCH_LIMITED_BY_ALRGeOq_uIDest heuristics only for the pre-configured algo id. 5.3.15. cublasLtMatmulTile_t cublasLtMatmulTile_t is an enumerated type used to set the tile size in rows x columns. See also CUTLASS: Fast Linear Algebra in CUDA C++. Value CUBLASLT_MATMUL_TILE_UNDEFINED CUBLASLT_MATMUL_TILE_8x8 CUBLASLT_MATMUL_TILE_8x16 CUBLASLT_MATMUL_TILE_16x8 CUBLASLT_MATMUL_TILE_8x32 CUBLASLT_MATMUL_TILE_16x16 CUBLASLT_MATMUL_TILE_32x8 CUBLASLT_MATMUL_TILE_8x64 CUBLASLT_MATMUL_TILE_16x32 CUBLASLT_MATMUL_TILE_32x16 CUBLASLT_MATMUL_TILE_64x8 CUBLASLT_MATMUL_TILE_32x32 CUBLASLT_MATMUL_TILE_32x64 CUBLASLT_MATMUL_TILE_64x32 CUBLASLT_MATMUL_TILE_32x128 CUBLASLT_MATMUL_TILE_64x64 CUBLASLT_MATMUL_TILE_128x32 CUBLASLT_MATMUL_TILE_64x128 CUBLASLT_MATMUL_TILE_128x64 Description Tile size is undefined. Tile size is 8 rows x 8 columns. Tile size is 8 rows x 16 columns. Tile size is 16 rows x 8 columns. Tile size is 8 rows x 32 columns. Tile size is 16 rows x 16 columns. Tile size is 32 rows x 8 columns. Tile size is 8 rows x 64 columns. Tile size is 16 rows x 32 columns. Tile size is 32 rows x 16 columns. Tile size is 64 rows x 8 columns. Tile size is 32 rows x 32 columns. Tile size is 32 rows x 64 columns. Tile size is 64 rows x 32 columns. Tile size is 32 rows x 128 columns. Tile size is 64 rows x 64 columns. Tile size is 128 rows x 32 columns. Tile size is 64 rows x 128 columns. Tile size is 128 rows x 64 columns. continues on next page 5.3. cuBLASLt Datatypes Reference 205 cuBLAS, Release 12.3 Value Table 2 – continued from previous page Description CUBLASLT_MATMUL_TILE_64x256 CUBLASLT_MATMUL_TILE_128x128 CUBLASLT_MATMUL_TILE_256x64 CUBLASLT_MATMUL_TILE_64x512 CUBLASLT_MATMUL_TILE_128x256 CUBLASLT_MATMUL_TILE_256x128 CUBLASLT_MATMUL_TILE_512x64 CUBLASLT_MATMUL_TILE_64x96 CUBLASLT_MATMUL_TILE_96x64 CUBLASLT_MATMUL_TILE_96x128 CUBLASLT_MATMUL_TILE_128x160 CUBLASLT_MATMUL_TILE_160x128 CUBLASLT_MATMUL_TILE_192x128 CUBLASLT_MATMUL_TILE_128x192 CUBLASLT_MATMUL_TILE_128x96 Tile size is 64 rows x 256 columns. Tile size is 128 rows x 128 columns. Tile size is 256 rows x 64 columns. Tile size is 64 rows x 512 columns. Tile size is 128 rows x 256 columns. Tile size is 256 rows x 128 columns. Tile size is 512 rows x 64 columns. Tile size is 64 rows x 96 columns. Tile size is 96 rows x 64 columns. Tile size is 96 rows x 128 columns. Tile size is 128 rows x 160 columns. Tile size is 160 rows x 128 columns. Tile size is 192 rows x 128 columns. Tile size is 128 rows x 192 columns. Tile size is 128 rows x 96 columns. 5.3.16. cublasLtMatmulStages_t cublasLtMatmulStages_t is an enumerated type used to configure the size and number of shared mem- ory buffers where input elements are staged. Number of staging buffers defines kernel’s pipeline depth. Value CUBLASLT_MATMUL_STAGES_UNDEFINED CUBLASLT_MATMUL_STAGES_16x1 CUBLASLT_MATMUL_STAGES_16x2 CUBLASLT_MATMUL_STAGES_16x3 CUBLASLT_MATMUL_STAGES_16x4 CUBLASLT_MATMUL_STAGES_16x5 CUBLASLT_MATMUL_STAGES_16x6 CUBLASLT_MATMUL_STAGES_32x1 CUBLASLT_MATMUL_STAGES_32x2 CUBLASLT_MATMUL_STAGES_32x3 Description Stage size is undefined. Stage size is 16, number of stages is 1. Stage size is 16, number of stages is 2. Stage size is 16, number of stages is 3. Stage size is 16, number of stages is 4. Stage size is 16, number of stages is 5. Stage size is 16, number of stages is 6. Stage size is 32, number of stages is 1. Stage size is 32, number of stages is 2. Stage size is 32, number of stages is 3. continues on next page 206 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Value Table 3 – continued from previous page Description CUBLASLT_MATMUL_STAGES_32x4 CUBLASLT_MATMUL_STAGES_32x5 CUBLASLT_MATMUL_STAGES_32x6 CUBLASLT_MATMUL_STAGES_64x1 CUBLASLT_MATMUL_STAGES_64x2 CUBLASLT_MATMUL_STAGES_64x3 CUBLASLT_MATMUL_STAGES_64x4 CUBLASLT_MATMUL_STAGES_64x5 CUBLASLT_MATMUL_STAGES_64x6 CUBLASLT_MATMUL_STAGES_128x1 CUBLASLT_MATMUL_STAGES_128x2 CUBLASLT_MATMUL_STAGES_128x3 CUBLASLT_MATMUL_STAGES_128x4 CUBLASLT_MATMUL_STAGES_128x5 CUBLASLT_MATMUL_STAGES_128x6 CUBLASLT_MATMUL_STAGES_32x10 CUBLASLT_MATMUL_STAGES_8x4 CUBLASLT_MATMUL_STAGES_16x10 CUBLASLT_MATMUL_STAGES_8x5 CUBLASLT_MATMUL_STAGES_8x3 CUBLASLT_MATMUL_STAGES_8xAUTO CUBLASLT_MATMUL_STAGES_16xAUTO CUBLASLT_MATMUL_STAGES_32xAUTO CUBLASLT_MATMUL_STAGES_64xAUTO CUBLASLT_MATMUL_STAGES_128xAUTO Stage size is 32, number of stages is 4. Stage size is 32, number of stages is 5. Stage size is 32, number of stages is 6. Stage size is 64, number of stages is 1. Stage size is 64, number of stages is 2. Stage size is 64, number of stages is 3. Stage size is 64, number of stages is 4. Stage size is 64, number of stages is 5. Stage size is 64, number of stages is 6. Stage size is 128, number of stages is 1. Stage size is 128, number of stages is 2. Stage size is 128, number of stages is 3. Stage size is 128, number of stages is 4. Stage size is 128, number of stages is 5. Stage size is 128, number of stages is 6. Stage size is 32, number of stages is 10. Stage size is 8, number of stages is 4. Stage size is 16, number of stages is 10. Stage size is 8, number of stages is 5. Stage size is 8, number of stages is 3. Stage size is 8, number of stages is selected automatically. Stage size is 16, number of stages is selected automatically. Stage size is 32, number of stages is selected automatically. Stage size is 64, number of stages is selected automatically. Stage size is 128, number of stages is selected automatically. 5.3.17. cublasLtNumericalImplFlags_t cublasLtNumericalImplFlags_t: a set of bit-flags that can be specified to select implementation details that may affect numerical behavior of algorithms. Flags below can be combined using the bit OR operator “|”. 5.3. cuBLASLt Datatypes Reference 207 cuBLAS, Release 12.3 Value Description CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_FtMhAat the implementation is based on [H,F,D]FMA (fused multiply-add) family instructions. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_HthMaMt tAhe implementation is based on HMMA (tensor opera- tion) family instructions. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_ItMhMatAthe implementation is based on IMMA (integer tensor operation) family instructions. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_DthMaMt Athe implementation is based on DMMA (double preci- sion tensor operation) family instructions. CUBLASLT_NUMERICAL_IMPL_FMLaAsGkSt_oTfiENlteSrOiRm_pOlePm_MenAtSaKtions using any of the above kinds of ten- sor operations. CUBLASLT_NUMERICAL_IMPL_FMLaAsGkSt_oOfiPl_teTrYiPmEp_MlemASeKntation details about multiply-accumulate in- structions used. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_AtChCatUMthUeLiAmTpOleRm_1e6nFtation’s inner dot product is using half precision accumulator. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_AtChaCtUtMheULimATpOleRm_e3n2tFation’s inner dot product is using single precision accumulator. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_AtChaCtUtMheUiLmApTlOeRm_e6n4tFation’s inner dot product is using double precision accumulator. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_AtChaCtUtMheULimATpOleRm_e3n2tIation’s inner dot product is using 32 bit signed integer precision accumulator. CUBLASLT_NUMERICAL_IMPL_FMLaAsGkSt_oAfiClCteUrMimUpLlAeTmOeRn_tTaYtiPoEn_dMeAtaSiKls about accumulator used. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_INtPhaUtT_t1h6eF implementation’s inner dot product multiply- accumulate instruction is using half-precision inputs. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_INtPhaUtT_t1h6eBFimplementation’s inner dot product multiply- accumulate instruction is using bfloat16 inputs. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_INtPhaUtT_tThFe32implementation’s inner dot product multiply- accumulate instruction is using TF32 inputs. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_INtPhaUtT_t3h2eF implementation’s inner dot product multiply- accumulate instruction is using single-precision inputs. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_INtPhaUtT_t6h4eF implementation’s inner dot product multiply- accumulate instruction is using double-precision inputs. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_INtPhaUtT_t8hIe implementation’s inner dot product multiply- accumulate instruction is using 8-bit integer inputs. CUBLASLT_NUMERICAL_IMPL_FMLaAsGkSt_oOfiPlt_eINr PimUpTl_eTmYePnEt_aMtiAonSKdetails about accumulator input used. CUBLASLT_NUMERICAL_IMPL_FSLpAeGciSfy_GtAhUatSSthIAeNimplementation applies Gauss complexity reduc- tion algorithm to reduce arithmetic complexity of the complex ma- trix multiplication problem 208 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.3.18. cublasLtMatrixLayout_t The cublasLtMatrixLayout_t is a pointer to an opaque structure holding the description of a matrix layout. Use cublasLtMatrixLayoutCreate() to create one instance of the descriptor and cublasLtMa- trixLayoutDestroy() to destroy a previously created descriptor and release the resources. 5.3.19. cublasLtMatrixLayoutAttribute_t cublasLtMatrixLayoutAttribute_t is a descriptor structure containing the attributes that define the details of the matrix operation. Use cublasLtMatrixLayoutGetAttribute() and cublasLtMatrixLayoutSe- tAttribute() to get and set the attribute value of a matrix layout descriptor. 5.3. cuBLASLt Datatypes Reference 209 cuBLAS, Release 12.3 Attribute Name Description Data Type CUBLASLT_MATRIX_LAYOUT_TYPESpecifies the data precision type. See cudaDataType_t. CUBLASLT_MATRIX_LAYOUT_ORDSEpRecifies the memory or- der of the data of the matrix. Default value is CUBLASLT_ORDER_COL. See cublasLtOrder_t . CUBLASLT_MATRIX_LAYOUT_ROWDSescribes the number of rows in the matrix. Normally only val- ues that can be expressed as int32_t are supported. CUBLASLT_MATRIX_LAYOUT_COLDSescribes the number of columns in the matrix. Nor- mally only values that can be expressed as int32_t are supported. uint32_t int32_t uint64_t uint64_t CUBLASLT_MATRIX_LAYOUT_LD The leading dimen- sion of the matrix. For CUBLASLT_ORDER_COL this is the stride (in elements) of matrix column. See also cublasLtOrder_t. ? Currently only non- negative values are supported. ? Must be large enough so that matrix memory loca- tions are not overlapping (e.g., greater or equal to int64_t CUBLASLT_MATRIX_LAYOUT_ROWS in case of CUBLASLT_ORDER_COL). CUBLASLT_MATRIX_LAYOUT_BATCNHu_mCbOeUr NTof matmul opera- tions to perform in the batch. Default value is 1. See also int32_t CUBLASLT_ALGO_CAP_STRIDED_BATCH_SUPPORT in cublasLtMatmulAlgoCapAt- tributes_t. CUBLASLT_MATRIX_LAYOUT_STRISDtEriDd_eBA(iTnCHe_lOemFFeSnEtsT) to the next matrix for the strided batch operation. Default value is 0. When ma- trix type is planar-complex int64_t 210 (CUBLASLT_MATRIX_LAYOUT_PLANE_OFFSET != 0), batch stride is inter- preted by cublasLtMatmul() in number of real valued sub- elements. E.g. for data of type CUDA_C_16F, offset of 1024B is encoded as a stride of valuCehapter 5. Using the cuBLASLt API 512 (since each element of the real and imaginary matrices is a 2B (16bit) floating point cuBLAS, Release 12.3 5.3.20. cublasLtMatrixTransformDesc_t The cublasLtMatrixTransformDesc_t is a pointer to an opaque structure holding the description of a matrix transformation operation. Use cublasLtMatrixTransformDescCreate() to create one instance of the descriptor and cublasLtMatrixTransformDescDestroy() to destroy a previously created descriptor and release the resources. 5.3.21. cublasLtMatrixTransformDescAttributes_t cublasLtMatrixTransformDescAttributes_t is a descriptor structure containing the attributes that de- fine the specifics of the matrix transform operation. Use cublasLtMatrixTransformDescGetAttribute() and cublasLtMatrixTransformDescSetAttribute() to set the attribute value of a matrix transform de- scriptor. Transform At- tribute Name Description Data Type CUBLASLT_MATRIX_TRSAcNalSeFtOypReM. _InDpEuStCs_aSreCAcoLnEv_eTrYtPeEd to the scale type for scaling and sum- mation, and results are then converted to the output type to store in the memory. For the supported data types see cudaDataType_t. CUBLASLT_MATRIX_TRSApNecSiFfiOeRsMt_hDeESCsc_aPlOarIsNTEaRlp_hMaODaEnd beta are passed by refer- ence whether on the host or on the device. Default value is: CUBLASLT_POINTER_MODE_HOST (i.e., on the host). See cublasLt- PointerMode_t. CUBLASLT_MATRIX_TRSApNecSiFfiOeRsMth_eDtEySpCe_oTfRoApNerSaAtion that should be performed on the matrix A. Default value is: CUBLAS_OP_N (i.e., non-transpose operation). See cublasOperation_t. CUBLASLT_MATRIX_TRSApNecSiFfiOeRsMth_eDtEySpCe_oTfRoApNerSaBtion that should be performed on the matrix B. Default value is: CUBLAS_OP_N (i.e., non-transpose operation). See cublasOperation_t. int32_t int32_t int32_t int32_t 5.3. cuBLASLt Datatypes Reference 211 cuBLAS, Release 12.3 5.3.22. cublasLtOrder_t cublasLtOrder_t is an enumerated type used to indicate the data ordering of the matrix. Value Data Order Description CUBLASLDT_aOtaRiDsEoRrd_CerOeLd in column-major format. The leading dimension is the stride (in elements) to the beginning of next column in memory. CUBLASLDT_aOtaRiDsEoRr_dReOreWd in row-major format. The leading dimension is the stride (in elements) to the beginning of next row in memory. CUBLASLDT_aOtaRDisEoRr_dCeOreLd32in column-major ordered tiles of 32 columns. The leading dimension is the stride (in elements) to the beginning of next group of 32-columns. For example, if the matrix has 33 columns and 2 rows, then the leading dimension must be at least (32) * 2 = 64. CUBLASLDT_aOtaRiDsEoRrd_eCrOeLd4in_4cRo2lu_m8Cn-major ordered tiles of composite tiles with total 32 columns and 8 rows. A tile is composed of interleaved inner tiles of 4 columns within 4 even or odd rows in an alternating pattern. The leading dimension is the stride (in elements) to the beginning of the first 32 column x 8 row tile for the next 32-wide group of columns. For example, if the matrix has 33 columns and 1 row, the leading dimension must be at least (32 * 8) * 1 = 256. CUBLASLDT_aOtaRDiEsR_oCrOdLe3re2d_2Rin_4Rc4olumn-major ordered tiles of composite tiles with to- tal 32 columns ands 32 rows. Element offset within the tile is calculated as (((row%8)/2*4+row/8)*2+row%2)*32+col. Leading dimension is the stride (in elements) to the beginning of the first 32 column x 32 row tile for the next 32-wide group of columns. E.g. if matrix has 33 columns and 1 row, ld must be at least (32*32)*1 = 1024. 5.3.23. cublasLtPointerMode_t cublasLtPointerMode_t is an enumerated type used to set the pointer mode for the scaling factors alpha and beta. Value Description CUBLASLT_POINTER_MODE_HOST Matches CUBLAS_POINTER_MODE_HOST, and the pointer tar- = CUBLAS_POINTER_MODE_HOST gets a single value host memory. CUBLASLT_POINTER_MODE_DEVICME atches CUBLAS_POINTER_MODE_DEVICE, and the pointer = CUBLAS_POINTER_MODE_DEVICEtargets a single value device memory. CUBLASLT_POINTER_MODE_DEVICPEo_VinEtCeTrsORtarget device memory vectors of length equal to the = 2 number of rows of matrix D. CUBLASLT_POINTER_MODE_ALPHAa_lDpEhVaICpEo_inVtEeCrTtOarRg_eBtEsTaA_dZeEvRicOe memory vector of length equal = 3 to the number of rows of matrix D, and beta is zero. CUBLASLT_POINTER_MODE_ALPHAa_lDpEhVaICpEo_inVtEeCrTtOarRg_eBtEsTaA_dHevOicSeT memory vector of length equal = 4 to the number of rows of matrix D, and beta is a single value in host memory. 212 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.3.24. cublasLtPointerModeMask_t cublasLtPointerModeMask_t is an enumerated type used to define and query the pointer mode capa- bility. Value CUBLASLT_POINTER_MODE_MASK_HOST = 1 CUBLASLT_POINTER_MODE_MASK_DEVICE = 2 Description See CUBLASLT_POINTER_MODE_HOST in cublasLt- PointerMode_t. See CUBLASLT_POINTER_MODE_DEVICE in cublasLt- PointerMode_t. CUBLASLT_POINTER_MODE_MASK_DEVICE_VSEeCeTCOURBLASLT_POINTER_MODE_DEVICE_VECTOR in = 4 cublasLtPointerMode_t CUBLASLT_POINTER_MODE_MASK_ALPHA_DSEeVeICCEU_BVLEACSTLOTRPBOEINTAT_EZRE_RMOODE_ALPHA_DEVICE_VECTOR_BETA_ZER = 8 in cublasLtPointerMode_t CUBLASLT_POINTER_MODE_MASK_ALPHA_DSEeVeICCEU_BVLEACSTLOTRPBOEINTAT_EHRO_MSTODE_ALPHA_DEVICE_VECTOR_BETA_HOS = 16 in cublasLtPointerMode_t 5.3.25. cublasLtReductionScheme_t cublasLtReductionScheme_t is an enumerated type used to specify a reduction scheme for the por- tions of the dot-product calculated in parallel (i.e., “split - K”). Value Description CUBLASLT_REDUCTION_DSCoHnEoMt Ea_pNpOlyNrEeduction. The dot-product will be performed in one se- quence. CUBLASLT_REDUCTION_RSeCdHuEcMtiEon_INisPpLeArCfoErmed “in place” using the output buffer, parts are added up in the output data type. Workspace is only used for counters that guar- antee sequentiality. CUBLASLT_REDUCTION_RSeCdHuEcMtiEon_CdOoMnePoUuTtEo_fTYpPlaEce in a user-provided workspace. The intermedi- ate results are stored in the compute type in the workspace and reduced in a separate step. CUBLASLT_REDUCTION_RSeCdHuEcMtiEon_OdUoTnPeUoTu_tToYfPpElace in a user-provided workspace. The intermedi- ate results are stored in the output type in the workspace and reduced in a separate step. CUBLASLT_REDUCTION_ASClloHwEsMaEll_rMedAuScKtion schemes. 5.3. cuBLASLt Datatypes Reference 213 cuBLAS, Release 12.3 5.4. cuBLASLt API Reference 5.4.1. cublasLtCreate() cublasStatus_t cublasLtCreate(cublasLtHandle_t *lighthandle) This function initializes the cuBLASLt library and creates a handle to an opaque structure holding the cuBLASLt library context. It allocates light hardware resources on the host and device, and must be called prior to making any other cuBLASLt library calls. The cuBLASLt library context is tied to the current CUDA device. To use the library on multiple devices, one cuBLASLt handle should be created for each device. Parameters: Parame- ter lightHandle Mem- ory Input / Out- put Output Description Pointer to the allocated cuBLASLt handle for the created cuBLASLt context. Returns: Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED Description The allocation completed successfully. The cuBLASLt library was not initialized. This usually happens: ? when cublasLtCreate() is not called first ? an error in the CUDA Runtime API called by the cuBLASLt routine, or ? an error in the hardware setup. CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_INVALID_VALUE Resource allocation failed inside the cuBLASLt li- brary. This is usually caused by a cudaMalloc() failure. To correct: prior to the function call, deallocate the previously allocated memory as much as pos- sible. lighthandle == NULL See cublasStatus_t for a complete list of valid return codes. 214 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.2. cublasLtDestroy() cublasStatus_t cublasLtDestroy(cublasLtHandle_t lightHandle) This function releases hardware resources used by the cuBLASLt library. This function is usually the last call with a particular handle to the cuBLASLt library. Because cublasLtCreate() allocates some internal resources and the release of those resources by calling cublasLtDestroy() will implicitly call cudaDeviceSynchronize(), it is recommended to minimize the number of times these functions are called. Parameters: Parameter Memory Input / Output Description lightHandle Input Pointer to the cuBLASLt handle to be destroyed. Returns: Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE Meaning The cuBLASLt context was successfully destroyed. The cuBLASLt library was not initialized. lightHandle == NULL See cublasStatus_t for a complete list of valid return codes. 5.4.3. cublasLtDisableCpuInstructionsSetMask() unsigned cublasLtDisableCpuInstructionsSetMask(unsigned mask); Instructs cuBLASLt library to not use CPU instructions specified by the flags in the mask. The function takes precedence over the CUBLASLT_DISABLE_CPU_INSTRUCTIONS_MASK environment variable. Parameters: mask – the flags combined with bitwise OR(|) operator that specify which CPU instruc- tions should not be used. Supported flags: Value Description 0x1 x86-64 AVX512 ISA. Returns: the previous value of the mask. 5.4. cuBLASLt API Reference 215 cuBLAS, Release 12.3 5.4.4. cublasLtGetCudartVersion() size_t cublasLtGetCudartVersion(void); This function returns the version number of the CUDA Runtime library. Parameters: None. Returns:size_t - The version number of the CUDA Runtime library. 5.4.5. cublasLtGetProperty() cublasStatus_t cublasLtGetProperty(libraryPropertyType type, int *value); This function returns the value of the requested property by writing it to the memory location pointed to by the value parameter. Parameters: Pa- rame- ter type value Mem- ory Input / Output Input Output Description Of the type libraryPropertyType, whose value is requested from the property. See libraryPropertyType_t. Pointer to the host memory location where the requested information should be written. Returns: Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE Meaning The requested libraryPropertyType informa- tion is successfully written at the provided ad- dress. ? If invalid value of the type input argument or ? value == NULL See cublasStatus_t for a complete list of valid return codes. 216 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.6. cublasLtGetStatusName() const char* cublasLtGetStatusName(cublasStatus_t status); Returns the string representation of a given status. Parameters: cublasStatus_t - the status. Returns: const char* - the NULL-terminated string. 5.4.7. cublasLtGetStatusString() const char* cublasLtGetStatusString(cublasStatus_t status); Returns the description string for a given status. Parameters: cublasStatus_t - the status. Returns: const char* - the NULL-terminated string. 5.4.8. cublasLtHeuristicsCacheGetCapacity() cublasStatus_t cublasLtHeuristicsCacheGetCapacity(size_t* capacity); Returns the Heuristics Cache capacity. Parameters: Parameter Description capacity The pointer to the returned capacity value. Returns: Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE Description The capacity was successfully written. The capacity was successfully set. 5.4.9. cublasLtHeuristicsCacheSetCapacity() cublasStatus_t cublasLtHeuristicsCacheSetCapacity(size_t capacity); Sets the Heuristics Cache capacity. Set the capacity to 0 to disable the heuristics cache. This function takes precedence over CUBLASLT_HEURISTICS_CACHE_CAPACITY environment vari- able. Parameters: 5.4. cuBLASLt API Reference 217 cuBLAS, Release 12.3 Parameter Description capacity The desirable heuristics cache capacity. Returns: Return Value Description CUBLAS_STATUS_SUCCESS The capacity was successfully set. 5.4.10. cublasLtGetVersion() size_t cublasLtGetVersion(void); This function returns the version number of cuBLASLt library. Parameters: None. Returns:size_t - The version number of cuBLASLt library. 5.4.11. cublasLtLoggerSetCallback() cublasStatus_t cublasLtLoggerSetCallback(cublasLtLoggerCallback_t callback); Experimental: This function sets the logging callback function. Parameters: Parame- ter callback Mem- ory Input / Out- put Input Description Pointer to a callback function. See cublasLtLoggerCall- back_t. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If the callback function was successfully set. See cublasStatus_t for a complete list of valid return codes. 218 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.12. cublasLtLoggerSetFile() cublasStatus_t cublasLtLoggerSetFile(FILE* file); Experimental: This function sets the logging output file. Note: once registered using this function call, the provided file handle must not be closed unless the function is called again to switch to a different file handle. Parameters: Parameter Memory Input / Output Description file Input Pointer to an open file. File should have write permission. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If logging file was successfully set. See cublasStatus_t for a complete list of valid return codes. 5.4.13. cublasLtLoggerOpenFile() cublasStatus_t cublasLtLoggerOpenFile(const char* logFile); Experimental: This function opens a logging output file in the given path. Parameters: Parameter Memory Input / Output Description logFile Input Path of the logging output file. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If the logging file was successfully opened. See cublasStatus_t for a complete list of valid return codes. 5.4. cuBLASLt API Reference 219 cuBLAS, Release 12.3 5.4.14. cublasLtLoggerSetLevel() cublasStatus_t cublasLtLoggerSetLevel(int level); Experimental: This function sets the value of the logging level. Parameters: Parameter Memory Input / Output Description level Input Value of the logging level. See cuBLASLt Logging. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_SUCCESS Description If the value was not a valid logging level. See cuBLASLt Logging. If the logging level was successfully set. See cublasStatus_t for a complete list of valid return codes. 5.4.15. cublasLtLoggerSetMask() cublasStatus_t cublasLtLoggerSetMask(int mask); Experimental: This function sets the value of the logging mask. Parameters: Parameter Memory Input / Output Description mask Input Value of the logging mask. See cuBLASLt Logging. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If the logging mask was successfully set. See cublasStatus_t for a complete list of valid return codes. 220 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.16. cublasLtLoggerForceDisable() cublasStatus_t cublasLtLoggerForceDisable(); Experimental: This function disables logging for the entier run. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If logging was successfully disabled. See cublasStatus_t for a complete list of valid return codes. 5.4.17. cublasLtMatmul() cublasStatus_t cublasLtMatmul( cublasLtHandle_t lightHandle, cublasLtMatmulDesc_t computeDesc, const void *alpha, const void *A, cublasLtMatrixLayout_t Adesc, const void *B, cublasLtMatrixLayout_t Bdesc, const void *beta, const void *C, cublasLtMatrixLayout_t Cdesc, void *D, cublasLtMatrixLayout_t Ddesc, const cublasLtMatmulAlgo_t *algo, void *workspace, size_t workspaceSizeInBytes, cudaStream_t stream); This function computes the matrix multiplication of matrices A and B to produce the output matrix D, according to the following operation: D = alpha*(A*B) + beta*(C), where A, B, and C are input matrices, and alpha and beta are input scalars. Note: This function supports both in-place matrix multiplication (C == D and Cdesc == Ddesc) and out-of-place matrix multiplication (C != D, both matrices must have the same data type, number of rows, number of columns, batch size, and memory order). In the out-of-place case, the leading dimension of C can be different from the leading dimension of D. Specifically the leading dimension of C can be 0 to achieve row or column broadcast. If Cdesc is omitted, this function assumes it to be equal to Ddesc. The workspace pointer has to be aligned to at least 256 bytes. The recommendations on workspace- SizeInBytes are the same as mentioned in the cublasSetWorkspace() section. Datatypes Supported: 5.4. cuBLASLt API Reference 221 cuBLAS, Release 12.3 cublasLtMatmul() supports the following computeType, scaleType, Atype/Btype, and Ctype. Footnotes can be found at the end of this section. Table 4: Table 1. When A, B, C, and D are Regular Column- or Row-major Matrices computeType scale- Type Atype/BtypCetype Bias Type2 CUBLAS_COMPUTE_16F or CUBLAS_COMPUTE_16F_PEDANTIC CUBLAS_COMPUTE_32I or CUBLAS_COMPUTE_32I_PEDANTIC CUBLAS_COMPUTE_32F or CUBLAS_COMPUTE_32F_PEDANTIC CUBLAS_COMPUTE_32F_FAST_16F or CUBLAS_COMPUTE_32F_FAST_16BF or CUBLAS_COMPUTE_32F_FAST_TF32 CUBLAS_COMPUTE_64F or CUBLAS_COMPUTE_64F_PEDANTIC CUDA_R_16CFUDA_R_16CFUDA_R_16CFUDA_R_16F2 CUDA_R_32CIUDA_R_8ICUDA_R_32NI on-default epilogue not supported. CUDA_R_32CFUDA_R_8ICUDA_R_8INon-default epilogue not supported. CUDA_R_32CFUDA_R_16CBUFDA_R_16CBUFDA_R_16BF2 CUDA_R_16CFUDA_R_16CFUDA_R_16F2 CUDA_R_8ICUDA_R_32NFon-default epilogue not supported. CUDA_R_16CBUFDA_R_32CFUDA_R_32F2 CUDA_R_16CFUDA_R_32CFUDA_R_32F2 CUDA_R_32CFUDA_R_32CFUDA_R_32F2 CUDA_C_32CFU3DA_C_8IC3 UDA_C_32NFo3n-default epilogue not supported. CUDA_C_32CFU3DA_C_32F3 CUDA_R_32CFUDA_R_32CFUDA_R_32CFUDA_R_32F? CUDA_C_32CFU3DA_C_32CFU3DA_C_32NFo3n-default epilogue not supported. CUDA_R_64CFUDA_R_64CFUDA_R_64CFUDA_R_64F? CUDA_C_64CFU3DA_C_64CFU3DA_C_64NFo3n-default epilogue not supported. To use IMMA kernels, one of the following sets of requirements, with the first being the preferred one, must be met: 1. Using a regular data ordering: ? All matrix pointers must be 4-byte aligned. For even better performance, this condition should hold with 16 instead of 4. ? Leading dimensions of matrices A, B, C must be multiples of 4. ? Only the “TN” format is supported - A must be transposed and B non-transposed. 2 ReLU, dReLu, GELU, dGELU and Bias epilogue modes (see CUBLASLT_MATMUL_DESC_EPILOGUE in cublasLtMatmulDescAt- tributes_t) are not supported when D matrix memory order is defined as CUBLASLT_ORDER_ROW. For best performance when using the bias vector, specify zero beta and set pointer mode to CUBLASLT_POINTER_MODE_HOST. 3 Use of CUBLAS_ORDER_ROW together with CUBLAS_OP_C (Hermitian operator) is not supported unless all of A, B, C, and D matrices use the CUBLAS_ORDER_ROW ordering. 222 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 ? Pointer mode can be CUBLASLT_POINTER_MODE_HOST, CUBLASLT_POINTER_MODE_DEVICE or CUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST. With the latter mode, the kernels support the CUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE at- tribute. ? Dimensions m and k must be multiples of 4. 2. Using the IMMA-specific data ordering on Ampere or Turing (but not Hopper) architecture - CUBLASLT_ORDER_COL32` for matrices A, C, D, and CUBLASLT_ORDER_COL4_4R2_8C (on Tur- ing or Ampere architecture) or CUBLASLT_ORDER_COL32_2R_4R4 (on Ampere architecture) for matrix B: ? Leading dimensions of matrices A, B, C must fulfill conditions specific to the memory order- ing (see cublasLtOrder_t). ? Matmul descriptor must specify CUBLAS_OP_T on matrix B and CUBLAS_OP_N (default) on matrix A and C. ? If scaleType CUDA_R_32I is used, the only supported values for alpha and beta are 0 or 1. ? Pointer mode can be CUBLASLT_POINTER_MODE_HOST, CUBLASLT_POINTER_MODE_DEVICE, CUBLASLT_POINTER_MODE_DEVICE_VECTOR or CUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BET These kernels do not support CUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE. ? Only the “NT” format is supported - A must be transposed and B non-transposed. Table 5: Table 2. When A, B, C, and D Use Layouts for IMMA computeType scaleType Atype/BtypeCtype Bias Type CUBLAS_COMPUTE_32I or CUDA_R_32I CUDA_R_8I CUDA_R_32INon-default epilogue not sup- CUBLAS_COMPUTE_32I_PEDANTIC CUDA_R_32FCUDA_R_8I ported. CUDA_R_8I CUDA_R_32F To use FP8 kernels, the following set of requirements must be satisfied: ? All matrix pointers must be 16-byte aligned. ? A must be transposed and B non-transposed (The “TN” format). ? The compute type must be CUBLAS_COMPUTE_32F. ? The scale type must be CUDA_R_32F. See the table below when using FP8 kernels: 5.4. cuBLASLt API Reference 223 cuBLAS, Release 12.3 Table 6: Table 3. When A, B, C, and D Use Layouts for FP8 AType CUDA_R_8F_E4M3 CUDA_R_8F_E5M2 BType CUDA_R_8F_E4M3 CUDA_R_8F_E5M2 CUDA_R_8F_E4M3 CType CUDA_R_16BF CUDA_R_16F CUDA_R_32F CUDA_R_16BF CUDA_R_16F CUDA_R_32F CUDA_R_16BF CUDA_R_16F CUDA_R_32F DType CUDA_R_16BF CUDA_R_8F_E4M3 CUDA_R_8F_E4M3 CUDA_R_16F CUDA_R_32F CUDA_R_16BF CUDA_R_8F_E4M3 CUDA_R_8F_E5M2 CUDA_R_8F_E4M3 CUDA_R_8F_E5M2 CUDA_R_16F CUDA_R_32F CUDA_R_16BF CUDA_R_8F_E4M3 CUDA_R_8F_E5M2 CUDA_R_8F_E4M3 CUDA_R_8F_E5M2 CUDA_R_16F CUDA_R_32F Bias Type CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16F? CUDA_R_16F? CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16F? CUDA_R_16F? CUDA_R_16F? CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16BF? CUDA_R_16F? CUDA_R_16F? CUDA_R_16F? CUDA_R_16BF? And finally, see below table when A,B,C,D are planar-complex matrices (CUBLASLT_MATRIX_LAYOUT_PLANE_OFFSET != 0, see cublasLtMatrixLayoutAttribute_t) to make use of mixed precision tensor core acceleration. Table 7: Table 4. When A, B, C, and D are Planar-Complex Ma- trices computeType CUBLAS_COMPUTE_32F scaleType CUDA_C_32F Atype/Btype CUDA_C_16FPage 222, 3 CUDA_C_16BFPage 222, 3 Ctype CUDA_C_16FPage 222, 3 CUDA_C_32FPage 222, 3 CUDA_C_16BFPage 222, 3 CUDA_C_32FPage 222, 3 NOTES: Parameters: 224 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Parame- Mem- In- Description ter ory put / Out- put lightHandle comput- eDesc In- put In- put Pointer to the allocated cuBLASLt handle for the cuBLASLt context. See cublasLtHandle_t. Handle to a previously created matrix multiplication descriptor of type cublasLtMatmulDesc_t. alpha, beta A, B, and C Adesc, Bdesc and Cdesc. D Ddesc algo De- vice or host De- vice De- vice In- put In- put In- put Out- put In- put In- put Pointers to the scalars used in the multiplication. Pointers to the GPU memory associated with the corresponding descrip- tors Adesc, Bdesc and Cdesc. Handles to the previous created descriptors of the type cublasLtMa- trixLayout_t. Pointer to the GPU memory associated with the descriptor Ddesc. Handle to the previous created descriptor of the type cublasLtMatrixLay- out_t. Handle for matrix multiplication algorithm to be used. See cublasLtMat- mulAlgo_t. When NULL, an implicit heuritics query with default search preferences will be performed to determine actual algorithm to use. workspaceDe- vice workspace- SizeIn- Bytes In- put Pointer to the workspace buffer allocated in the GPU memory. Pointer must be 16B aligned (i.e. lowest 4 bits of address must be 0). Size of the workspace. stream Host In- put The CUDA stream where all the GPU work will be submitted. Returns: 5.4. cuBLASLt API Reference 225 cuBLAS, Release 12.3 Return Value Description CUBLAS_STATUS_NIfOcTu_BINLAITSIALLt IhZaEnDdle has not been initialized. CUBLAS_STATUS_IINf VtAheLIpDa_rVaAmLUetEers are unexpectedly NULL, in conflict or in an impossible config- uration. For example, when workspaceSizeInBytes is less than workspace re- quired by the configured algo. CUBLAS_STATUS_NIfOtTh_eScUuPrrPeOnRt TimEDplementation on the selected device doesn’t support the config- ured operation. CUBLAS_STATUS_AIfRtChHe_cMonISfiMguArTeCdHoperation cannot be run using the selected device. CUBLAS_STATUS_EIfXCEUCDUTAIOreNp_oFrAteILdEaDn execution error from the device. CUBLAS_STATUS_SIfUtChCeEoSpSeration completed successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.18. cublasLtMatmulAlgoCapGetAttribute() cublasStatus_t cublasLtMatmulAlgoCapGetAttribute( const cublasLtMatmulAlgo_t *algo, cublasLtMatmulAlgoCapAttributes_t attr, void *buf, size_t sizeInBytes, size_t *sizeWritten); This function returns the value of the queried capability attribute for an initialized cublasLtMatmu- lAlgo_t descriptor structure. The capability attribute value is retrieved from the enumerated type cublasLtMatmulAlgoCapAttributes_t. For example, to get list of supported Tile IDs: cublasLtMatmulTile_t tiles[CUBLASLT_MATMUL_TILE_END]; size_t num_tiles, size_written; if (cublasLtMatmulAlgoCapGetAttribute(algo, CUBLASLT_ALGO_CAP_TILE_IDS, tiles, ‹>sizeof(tiles), &size_written) == CUBLAS_STATUS_SUCCESS) { num_tiles = size_written ? sizeof(tiles[0]);} Parameters: 226 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Pa- Mem-In- Description ram- ory e- ter algo attr buf sizeIn- Bytes sizeWrit- ten put / Out- put In- put In- put Out- put In- put Out- put Pointer to the previously created opaque structure holding the matrix multiply algorithm descriptor. See cublasLtMatmulAlgo_t. The capability attribute whose value will be retrieved by this function. See cublasLtMatmulAlgoCapAttributes_t. The attribute value returned by this function. Size of buf buffer (in bytes) for verification. Valid only when the return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: then sizeWritten is the number of bytes actually written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed to write full contents. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description ? If sizeInBytes is 0 and sizeWritten is NULL, or ? if sizeInBytes is non-zero and buf is NULL, or ? sizeInBytes doesn’t match size of inter- nal storage for the selected attribute CUBLAS_STATUS_SUCCESS If attribute’s value was successfully written to user memory. See cublasStatus_t for a complete list of valid return codes. 5.4.19. cublasLtMatmulAlgoCheck() cublasStatus_t cublasLtMatmulAlgoCheck( cublasLtHandle_t lightHandle, cublasLtMatmulDesc_t operationDesc, cublasLtMatrixLayout_t Adesc, cublasLtMatrixLayout_t Bdesc, cublasLtMatrixLayout_t Cdesc, cublasLtMatrixLayout_t Ddesc, const cublasLtMatmulAlgo_t *algo, cublasLtMatmulHeuristicResult_t *result); This function performs the correctness check on the matrix multiply algorithm descriptor for the ma- trix multiply operation cublasLtMatmul() function with the given input matrices A, B and C, and the 5.4. cuBLASLt API Reference 227 cuBLAS, Release 12.3 output matrix D. It checks whether the descriptor is supported on the current device, and returns the result containing the required workspace and the calculated wave count. Note: CUBLAS_STATUS_SUCCESS doesn’t fully guarantee that the algo will run. The algo will fail if, for example, the buffers are not correctly aligned. However, if cublasLtMatmulAlgoCheck() fails, the algo will not run. Parameters: Parame- Mem-In- Description ter lightHandle opera- tionDesc Adesc, Bdesc, Cdesc, and Ddesc prefer- ence algo result ory put / Out- put In- put In- put In- put In- put In- put Out- put Pointer to the allocated cuBLASLt handle for the cuBLASLt context. See cublasLtHandle_t. Handle to a previously created matrix multiplication descriptor of type cublasLtMatmulDesc_t. Handles to the previously created matrix layout descriptors of the type cublasLtMatrixLayout_t. Pointer to the structure holding the matrix multiply preferences descrip- tor. See cublasLtMatrixLayout_t. Descriptor which specifies which matrix multiplication algorithm should be used. See cublasLtMatmulAlgo_t. May point to result->algo. Pointer to the structure holding the results returned by this function. The results comprise of the required workspace and the calculated wave count. The algo field is never updated. See cublasLtMatmulHeuristicRe- sult_t. Returns: Return Value Description CUBLAS_STATUS_INVALID_VAIfLmUEatrix layout descriptors or the operation descriptor do not match the algo descriptor. CUBLAS_STATUS_NOT_SUPPIOf tRhTeEaDlgo configuration or data type combination is not currently sup- ported on the given device. CUBLAS_STATUS_ARCH_MISIMf tAhTeCaHlgo configuration cannot be run using the selected device. CUBLAS_STATUS_SUCCESS If the check was successful. See cublasStatus_t for a complete list of valid return codes. 228 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.20. cublasLtMatmulAlgoConfigGetAttribute() cublasStatus_t cublasLtMatmulAlgoConfigGetAttribute( const cublasLtMatmulAlgo_t *algo, cublasLtMatmulAlgoConfigAttributes_t attr, void *buf, size_t sizeInBytes, size_t *sizeWritten); This function returns the value of the queried configuration attribute for an initialized cublasLtMatmu- lAlgo_t descriptor. The configuration attribute value is retrieved from the enumerated type cublasLt- MatmulAlgoConfigAttributes_t. Parameters: Pa- Mem-In- Description ram- ory e- ter algo attr buf sizeIn- Bytes sizeWrit- ten put / Out- put In- put In- put Out- put In- put Out- put Pointer to the previously created opaque structure holding the matrix multiply algorithm descriptor. See cublasLtMatmulAlgo_t. The configuration attribute whose value will be retrieved by this function. See cublasLtMatmulAlgoConfigAttributes_t. The attribute value returned by this function. Size of buf buffer (in bytes) for verification. Valid only when the return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: then sizeWritten is the number of bytes actually written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed to write full contents. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description ? If sizeInBytes is 0 and sizeWritten is NULL, or ? if sizeInBytes is non-zero and buf is NULL, or ? sizeInBytes doesn’t match size of inter- nal storage for the selected attribute CUBLAS_STATUS_SUCCESS If attribute’s value was successfully written to user memory. See cublasStatus_t for a complete list of valid return codes. 5.4. cuBLASLt API Reference 229 cuBLAS, Release 12.3 5.4.21. cublasLtMatmulAlgoConfigSetAttribute() cublasStatus_t cublasLtMatmulAlgoConfigSetAttribute( cublasLtMatmulAlgo_t *algo, cublasLtMatmulAlgoConfigAttributes_t attr, const void *buf, size_t sizeInBytes); This function sets the value of the specified configuration attribute for an initialized cublasLtMatmu- lAlgo_t descriptor. The configuration attribute is an enumerant of the type cublasLtMatmulAlgoConfi- gAttributes_t. Parameters: Pa- Mem- Input / Description rame- ter algo attr buf sizeIn- Bytes ory Output Input Input Input Input Pointer to the previously created opaque structure holding the matrix multiply algorithm descriptor. See cublasLtMatmulAlgo_t. The configuration attribute whose value will be set by this function. See cublasLtMatmulAlgoConfigAttributes_t. The value to which the configuration attribute should be set. Size of buf buffer (in bytes) for verification. Returns: Return Value Description CUBLAS_STATUS_INVALIDI_fVbAuLfUEis NULL or sizeInBytes doesn’t match the size of the internal storage for the selected attribute. CUBLAS_STATUS_SUCCESIfSthe attribute was set successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.22. cublasLtMatmulAlgoGetHeuristic() cublasStatus_t cublasLtMatmulAlgoGetHeuristic( cublasLtHandle_t lightHandle, cublasLtMatmulDesc_t operationDesc, cublasLtMatrixLayout_t Adesc, cublasLtMatrixLayout_t Bdesc, cublasLtMatrixLayout_t Cdesc, cublasLtMatrixLayout_t Ddesc, cublasLtMatmulPreference_t preference, int requestedAlgoCount, cublasLtMatmulHeuristicResult_t heuristicResultsArray[] int *returnAlgoCount); 230 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 This function retrieves the possible algorithms for the matrix multiply operation cublasLtMatmul() function with the given input matrices A, B and C, and the output matrix D. The output is placed in heuristicResultsArray[] in the order of increasing estimated compute time. Parameters: Parameter Mem-Input Description lightHandle opera- tionDesc Adesc, Bdesc, Cdesc, and Ddesc preference requestedAl- goCount heuristicRe- sultsArray[] returnAlgo- Count ory / Out- put Input Input Input Input Input Out- put Out- put Pointer to the allocated cuBLASLt handle for the cuBLASLt context. See cublasLtHandle_t. Handle to a previously created matrix multiplication descriptor of type cublasLtMatmulDesc_t. Handles to the previously created matrix layout descriptors of the type cublasLtMatrixLayout_t. Pointer to the structure holding the heuristic search preferences de- scriptor. See cublasLtMatmulPreference_t. Size of the heuristicResultsArray (in elements). This is the re- quested maximum number of algorithms to return. Array containing the algorithm heuristics and associated runtime characteristics, returned by this function, in the order of increasing estimated compute time. Number of algorithms returned by this function. This is the number of heuristicResultsArray elements written. Returns: Return Value Description CUBLAS_STATUS_INVALIfIDr_eVqAuLeUsEtedAlgoCount is less or equal to zero. CUBLAS_STATUS_NOT_ISf UnoPPhOeuRrTisEtDic function available for current configuration. CUBLAS_STATUS_SUCCIfEqSuSery was successful. Inspect heuristicResultsArray[0 to (retur- nAlgoCount -1)].state for the status of the results. See cublasStatus_t for a complete list of valid return codes. 5.4.23. cublasLtMatmulAlgoGetIds() cublasStatus_t cublasLtMatmulAlgoGetIds( cublasLtHandle_t lightHandle, cublasComputeType_t computeType, cudaDataType_t scaleType, cudaDataType_t Atype, cudaDataType_t Btype, cudaDataType_t Ctype, (continues on next page) 5.4. cuBLASLt API Reference 231 cuBLAS, Release 12.3 (continued from previous page) cudaDataType_t Dtype, int requestedAlgoCount, int algoIdsArray[], int *returnAlgoCount); This function retrieves the IDs of all the matrix multiply algorithms that are valid, and can potentially be run by the cublasLtMatmul() function, for given types of the input matrices A, B and C, and of the output matrix D. Note: The IDs are returned in no particular order. To make sure the best possible algo is contained in the list, make requestedAlgoCount large enough to receive the full list. The list is guaranteed to be full if returnAlgoCount < requestedAlgoCount. Parameters: Parameter Mem- Input Description lightHandle computeType, scaleType, Atype, Btype, Ctype, and Dtype requestedAlgoCount algoIdsArray[] returnAlgoCount ory / Out- put Input Inputs Input Output Output Pointer to the allocated cuBLASLt handle for the cuBLASLt context. See cublasLtHandle_t. Data types of the computation type, scaling factors and of the operand matrices. See cudaDataType_t. Number of algorithms requested. Must be > 0. Array containing the algorithm IDs returned by this function. Number of algorithms actually returned by this func- tion. Returns: Return Value Description CUBLAS_STATUS_INVALID_VAIfLrUeEquestedAlgoCount is less or equal to zero. CUBLAS_STATUS_SUCCESS If query was successful. Inspect returnAlgoCount to get actual num- ber of IDs available. See cublasStatus_t for a complete list of valid return codes. 232 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.24. cublasLtMatmulAlgoInit() cublasStatus_t cublasLtMatmulAlgoInit( cublasLtHandle_t lightHandle, cublasComputeType_t computeType, cudaDataType_t scaleType, cudaDataType_t Atype, cudaDataType_t Btype, cudaDataType_t Ctype, cudaDataType_t Dtype, int algoId, cublasLtMatmulAlgo_t *algo); This function initializes the matrix multiply algorithm structure for the cublasLtMatmul() , for a speci- fied matrix multiply algorithm and input matrices A, B and C, and the output matrix D. Parameters: Parameter Mem- Input / Description lightHandle computeType scaleType Atype, Btype, Ctype, and Dtype algoId algo ory Output Input Input Input Input Input Input Pointer to the allocated cuBLASLt handle for the cuBLASLt con- text. See cublasLtHandle_t. Compute type. See CUBLASLT_MATMUL_DESC_COMPUTE_TYPE of cublasLtMatmulDescAttributes_t. Scale type. See CUBLASLT_MATMUL_DESC_SCALE_TYPEof cublasLtMatmulDescAttributes_t. Usually same as compute- Type. Datatype precision for the input and output matrices. See cud- aDataType_t . Specifies the algorithm being initialized. Should be a valid al- goId returned by the cublasLtMatmulAlgoGetIds() function. Pointer to the opaque structure to be initialized. See cublasLt- MatmulAlgo_t. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description If algo is NULL or algoId is outside the recognized range. CUBLAS_STATUS_NOT_SUPPORTED If algoId is not supported for given combination of data types. CUBLAS_STATUS_SUCCESS If the structure was successfully initialized. See cublasStatus_t for a complete list of valid return codes. 5.4. cuBLASLt API Reference 233 cuBLAS, Release 12.3 5.4.25. cublasLtMatmulDescCreate() cublasStatus_t cublasLtMatmulDescCreate( cublasLtMatmulDesc_t *matmulDesc, cublasComputeType_t computeType, cudaDataType_t scaleType); This function creates a matrix multiply descriptor by allocating the memory needed to hold its opaque structure. Parameters: Param- Mem- Input / Description eter mat- mulDesc com- pute- Type scale- Type ory Output Output Input Input Pointer to the structure holding the matrix multiply descriptor created by this function. See cublasLtMatmulDesc_t. Enumerant that specifies the data precision for the matrix multiply de- scriptor this function creates. See cublasComputeType_t. Enumerant that specifies the data precision for the matrix transform descriptor this function creates. See cudaDataType. Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.26. cublasLtMatmulDescInit() cublasStatus_t cublasLtMatmulDescInit( cublasLtMatmulDesc_t matmulDesc, cublasComputeType_t computeType, cudaDataType_t scaleType); This function initializes a matrix multiply descriptor in a previously allocated one. Parameters: 234 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Param- Mem- Input / Description eter mat- mulDesc com- pute- Type scale- Type ory Output Output Input Input Pointer to the structure holding the matrix multiply descriptor initialized by this function. See cublasLtMatmulDesc_t. Enumerant that specifies the data precision for the matrix multiply de- scriptor this function initializes. See cublasComputeType_t. Enumerant that specifies the data precision for the matrix transform descriptor this function initializes. See cudaDataType. Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.27. cublasLtMatmulDescDestroy() cublasStatus_t cublasLtMatmulDescDestroy( cublasLtMatmulDesc_t matmulDesc); This function destroys a previously created matrix multiply descriptor object. Parameters: Pa- Mem- Input / Description rame- ter mat- mulDesc ory Output Input Pointer to the structure holding the matrix multiply descriptor that should be destroyed by this function. See cublasLtMatmulDesc_t. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If operation was successful. See cublasStatus_t for a complete list of valid return codes. 5.4. cuBLASLt API Reference 235 cuBLAS, Release 12.3 5.4.28. cublasLtMatmulDescGetAttribute() cublasStatus_t cublasLtMatmulDescGetAttribute( cublasLtMatmulDesc_t matmulDesc, cublasLtMatmulDescAttributes_t attr, void *buf, size_t sizeInBytes, size_t *sizeWritten); This function returns the value of the queried attribute belonging to a previously created matrix mul- tiply descriptor. Parameters: Pa- Mem-In- Description ram- e- ter mat- ory put / Out- put In- Pointer to the previously created structure holding the matrix multiply descrip- mulDesc attr buf sizeIn- Bytes sizeWrit- ten put In- put Out- put In- put Out- put tor queried by this function. See cublasLtMatmulDesc_t. The attribute that will be retrieved by this function. See cublasLtMatmulDescAt- tributes_t. Memory address containing the attribute value retrieved by this function. Size of buf buffer (in bytes) for verification. Valid only when the return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: then sizeWritten is the number of bytes actually written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed to write full contents. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description ? If sizeInBytes is 0 and sizeWritten is NULL, or ? if sizeInBytes is non-zero and buf is NULL, or ? sizeInBytes doesn’t match size of inter- nal storage for the selected attribute CUBLAS_STATUS_SUCCESS If attribute’s value was successfully written to user memory. See cublasStatus_t for a complete list of valid return codes. 236 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.29. cublasLtMatmulDescSetAttribute() cublasStatus_t cublasLtMatmulDescSetAttribute( cublasLtMatmulDesc_t matmulDesc, cublasLtMatmulDescAttributes_t attr, const void *buf, size_t sizeInBytes); This function sets the value of the specified attribute belonging to a previously created matrix multiply descriptor. Parameters: Pa- Mem- Input / Description rame- ter mat- mulDesc attr buf sizeIn- Bytes ory Output Input Input Input Input Pointer to the previously created structure holding the matrix multiply descriptor queried by this function. See cublasLtMatmulDesc_t. The attribute that will be set by this function. See cublasLtMatmulDescAt- tributes_t. The value to which the specified attribute should be set. Size of buf buffer (in bytes) for verification. Returns: Return Value Description CUBLAS_STATUS_INVALIDI_fVbAuLfUEis NULL or sizeInBytes doesn’t match the size of the internal storage for the selected attribute. CUBLAS_STATUS_SUCCESIfSthe attribute was set successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.30. cublasLtMatmulPreferenceCreate() cublasStatus_t cublasLtMatmulPreferenceCreate( cublasLtMatmulPreference_t *pref); This function creates a matrix multiply heuristic search preferences descriptor by allocating the mem- ory needed to hold its opaque structure. Parameters: 5.4. cuBLASLt API Reference 237 cuBLAS, Release 12.3 Pa- Mem- Input / Description ram- eter pref ory Output Output Pointer to the structure holding the matrix multiply preferences descrip- tor created by this function. See cublasLtMatrixLayout_t. Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.31. cublasLtMatmulPreferenceInit() cublasStatus_t cublasLtMatmulPreferenceInit( cublasLtMatmulPreference_t pref); This function initializes a matrix multiply heuristic search preferences descriptor in a previously allo- cated one. Parameters: Pa- Mem- Input / Description ram- eter pref ory Output Output Pointer to the structure holding the matrix multiply preferences descrip- tor created by this function. See cublasLtMatrixLayout_t. Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 238 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.32. cublasLtMatmulPreferenceDestroy() cublasStatus_t cublasLtMatmulPreferenceDestroy( cublasLtMatmulPreference_t pref); This function destroys a previously created matrix multiply preferences descriptor object. Parameters: Pa- Mem- Input Description ram- eter pref ory / Out- put Input Pointer to the structure holding the matrix multiply preferences descriptor that should be destroyed by this function. See cublasLtMatmulPreference_t. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If the operation was successful. See cublasStatus_t for a complete list of valid return codes. 5.4.33. cublasLtMatmulPreferenceGetAttribute() cublasStatus_t cublasLtMatmulPreferenceGetAttribute( cublasLtMatmulPreference_t pref, cublasLtMatmulPreferenceAttributes_t attr, void *buf, size_t sizeInBytes, size_t *sizeWritten); This function returns the value of the queried attribute belonging to a previously created matrix mul- tiply heuristic search preferences descriptor. Parameters: 5.4. cuBLASLt API Reference 239 cuBLAS, Release 12.3 Pa- Mem-In- Description ram- ory e- ter pref attr buf sizeIn- Bytes sizeWrit- ten put / Out- put In- put In- put Out- put In- put Out- put Pointer to the previously created structure holding the matrix multiply heuristic search preferences descriptor queried by this function. See cublasLtMatmul- Preference_t. The attribute that will be queried by this function. See cublasLtMatmulPrefer- enceAttributes_t. Memory address containing the attribute value retrieved by this function. Size of buf buffer (in bytes) for verification. Valid only when the return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: then sizeWritten is the number of bytes actually written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed to write full contents. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description ? If sizeInBytes is 0 and sizeWritten is NULL, or ? if sizeInBytes is non-zero and buf is NULL, or ? sizeInBytes doesn’t match size of inter- nal storage for the selected attribute CUBLAS_STATUS_SUCCESS If attribute’s value was successfully written to user memory. See cublasStatus_t for a complete list of valid return codes. 5.4.34. cublasLtMatmulPreferenceSetAttribute() cublasStatus_t cublasLtMatmulPreferenceSetAttribute( cublasLtMatmulPreference_t pref, cublasLtMatmulPreferenceAttributes_t attr, const void *buf, size_t sizeInBytes); This function sets the value of the specified attribute belonging to a previously created matrix multiply preferences descriptor. Parameters: 240 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Pa- Mem-Input Description ram- eter pref attr buf sizeIn- Bytes ory / Out- put Input Input Input Input Pointer to the previously created structure holding the matrix multiply pref- erences descriptor queried by this function. See cublasLtMatmulPrefer- ence_t. The attribute that will be set by this function. See cublasLtMatmulPrefer- enceAttributes_t. The value to which the specified attribute should be set. Size of buf buffer (in bytes) for verification. Returns: Return Value Description CUBLAS_STATUS_INVALIDI_fVbAuLfUisENULL or sizeInBytes doesn’t match the size of the internal stor- age for the selected attribute. CUBLAS_STATUS_SUCCESIfSthe attribute was set successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.35. cublasLtMatrixLayoutCreate() cublasStatus_t cublasLtMatrixLayoutCreate( cublasLtMatrixLayout_t *matLayout, cudaDataType type, uint64_t rows, uint64_t cols, int64_t ld); This function creates a matrix layout descriptor by allocating the memory needed to hold its opaque structure. Parameters: 5.4. cuBLASLt API Reference 241 cuBLAS, Release 12.3 Pa- Mem-Input Description ram- eter mat- Lay- out type rows, cols ld ory / Out- put Out- put Input Input Input Pointer to the structure holding the matrix layout descriptor created by this function. See cublasLtMatrixLayout_t. Enumerant that specifies the data precision for the matrix layout descriptor this function creates. See cudaDataType. Number of rows and columns of the matrix. The leading dimension of the matrix. In column major layout, this is the num- ber of elements to jump to reach the next column. Thus ld >= m (number of rows). Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If the memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.36. cublasLtMatrixLayoutInit() cublasStatus_t cublasLtMatrixLayoutInit( cublasLtMatrixLayout_t matLayout, cudaDataType type, uint64_t rows, uint64_t cols, int64_t ld); This function initializes a matrix layout descriptor in a previously allocated one. Parameters: 242 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Pa- Mem-Input Description ram- eter mat- Lay- out type rows, cols ld ory / Out- put Out- put Input Input Input Pointer to the structure holding the matrix layout descriptor initialized by this function. See cublasLtMatrixLayout_t. Enumerant that specifies the data precision for the matrix layout descriptor this function initializes. See cudaDataType. Number of rows and columns of the matrix. The leading dimension of the matrix. In column major layout, this is the num- ber of elements to jump to reach the next column. Thus ld >= m (number of rows). Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If the memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.37. cublasLtMatrixLayoutDestroy() cublasStatus_t cublasLtMatrixLayoutDestroy( cublasLtMatrixLayout_t matLayout); This function destroys a previously created matrix layout descriptor object. Parameters: Pa- Mem- Input / Description ram- eter mat- Lay- out ory Output Input Pointer to the structure holding the matrix layout descriptor that should be destroyed by this function. See cublasLtMatrixLayout_t. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If the operation was successful. See cublasStatus_t for a complete list of valid return codes. 5.4. cuBLASLt API Reference 243 cuBLAS, Release 12.3 5.4.38. cublasLtMatrixLayoutGetAttribute() cublasStatus_t cublasLtMatrixLayoutGetAttribute( cublasLtMatrixLayout_t matLayout, cublasLtMatrixLayoutAttribute_t attr, void *buf, size_t sizeInBytes, size_t *sizeWritten); This function returns the value of the queried attribute belonging to the specified matrix layout de- scriptor. Parameters: Pa- Mem-In- Description ram- ory e- ter mat- Lay- out attr buf sizeIn- Bytes sizeWrit- ten put / Out- put In- put In- put Out- put In- put Out- put Pointer to the previously created structure holding the matrix layout descriptor queried by this function. See cublasLtMatrixLayout_t. The attribute being queried for. See cublasLtMatrixLayoutAttribute_t. The attribute value returned by this function. Size of buf buffer (in bytes) for verification. Valid only when the return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: then sizeWritten is the number of bytes actually written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed to write full contents. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description ? If sizeInBytes is 0 and sizeWritten is NULL, or ? if sizeInBytes is non-zero and buf is NULL, or ? sizeInBytes doesn’t match size of inter- nal storage for the selected attribute CUBLAS_STATUS_SUCCESS If attribute’s value was successfully written to user memory. See cublasStatus_t for a complete list of valid return codes. 244 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 5.4.39. cublasLtMatrixLayoutSetAttribute() cublasStatus_t cublasLtMatrixLayoutSetAttribute( cublasLtMatrixLayout_t matLayout, cublasLtMatrixLayoutAttribute_t attr, const void *buf, size_t sizeInBytes); This function sets the value of the specified attribute belonging to a previously created matrix layout descriptor. Parameters: Pa- Mem- Input / Description rame- ter mat- Lay- out attr buf sizeIn- Bytes ory Output Input Input Input Input Pointer to the previously created structure holding the matrix layout de- scriptor queried by this function. See cublasLtMatrixLayout_t. The attribute that will be set by this function. See cublasLtMatrixLayou- tAttribute_t. The value to which the specified attribute should be set. Size of buf, the attribute buffer. Returns: Return Value Description CUBLAS_STATUS_INVALID_VIfAbLuUfEis NULL or sizeInBytes doesn’t match size of internal storage for the selected attribute. CUBLAS_STATUS_SUCCESSIf attribute was set successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.40. cublasLtMatrixTransform() cublasStatus_t cublasLtMatrixTransform( cublasLtHandle_t lightHandle, cublasLtMatrixTransformDesc_t transformDesc, const void *alpha, const void *A, cublasLtMatrixLayout_t Adesc, const void *beta, const void *B, cublasLtMatrixLayout_t Bdesc, void *C, (continues on next page) 5.4. cuBLASLt API Reference 245 cuBLAS, Release 12.3 (continued from previous page) cublasLtMatrixLayout_t Cdesc, cudaStream_t stream); This function computes the matrix transformation operation on the input matrices A and B, to produce the output matrix C, according to the below operation: C = alpha*transformation(A) + beta*transformation(B), where A, B are input matrices, and alpha and beta are input scalars. The transformation operation is defined by the transformDesc pointer. This function can be used to change the memory order of data or to scale and shift the values. Parameters: Parame- ter lightHandle transfor- mDesc alpha, beta A, B, and C Adesc, Bdesc and Cdesc. stream Mem- ory De- vice or host De- vice Host In- put / Out- put Input Input Input Input Input Input Description Pointer to the allocated cuBLASLt handle for the cuBLASLt context. See cublasLtHandle_t. Pointer to the opaque descriptor holding the matrix transformation op- eration. See cublasLtMatrixTransformDesc_t. Pointers to the scalars used in the multiplication. Pointers to the GPU memory associated with the corresponding de- scriptors Adesc, Bdesc and Cdesc. Handles to the previous created descriptors of the type cublasLtMa- trixLayout_t. Adesc or Bdesc can be NULL if corresponding pointer is NULL and cor- responding scalar is zero. The CUDA stream where all the GPU work will be submitted. Returns: Return Value Description CUBLAS_STATUS_NOT_INIfTIcAuLBIZLEADSLt handle has not been initialized. CUBLAS_STATUS_INVALIDIf_VtAhLeUpEarameters are in conflict or in an impossible configuration. For example, when A is not NULL, but Adesc is NULL. CUBLAS_STATUS_NOT_SUIfPtPhOeRcTuErDrent implementation on the selected device does not support the configured operation. CUBLAS_STATUS_ARCH_MIfISthMeAcToCnHfigured operation cannot be run using the selected device. CUBLAS_STATUS_EXECUTIfIOCNU_DFAIrLeEpDorted an execution error from the device. CUBLAS_STATUS_SUCCESIfSthe operation completed successfully. 246 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 See cublasStatus_t for a complete list of valid return codes. 5.4.41. cublasLtMatrixTransformDescCreate() cublasStatus_t cublasLtMatrixTransformDescCreate( cublasLtMatrixTransformDesc_t *transformDesc, cudaDataType scaleType); This function creates a matrix transform descriptor by allocating the memory needed to hold its opaque structure. Parameters: Param- Mem- Input / Description eter trans- for- mDesc scale- Type ory Output Output Input Pointer to the structure holding the matrix transform descriptor cre- ated by this function. See cublasLtMatrixTransformDesc_t. Enumerant that specifies the data precision for the matrix transform descriptor this function creates. See cudaDataType. Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.42. cublasLtMatrixTransformDescInit() cublasStatus_t cublasLtMatrixTransformDescInit( cublasLtMatrixTransformDesc_t transformDesc, cudaDataType scaleType); This function initializes a matrix transform descriptor in a previously allocated one. Parameters: Param- Mem- Input / Description eter trans- for- mDesc scale- Type ory Output Output Input Pointer to the structure holding the matrix transform descriptor initial- ized by this function. See cublasLtMatrixTransformDesc_t. Enumerant that specifies the data precision for the matrix transform descriptor this function initializes. See cudaDataType. 5.4. cuBLASLt API Reference 247 cuBLAS, Release 12.3 Returns: Return Value CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_SUCCESS Description If memory could not be allocated. If the descriptor was created successfully. See cublasStatus_t for a complete list of valid return codes. 5.4.43. cublasLtMatrixTransformDescDestroy() cublasStatus_t cublasLtMatrixTransformDescDestroy( cublasLtMatrixTransformDesc_t transformDesc); This function destroys a previously created matrix transform descriptor object. Parameters: Param- Mem- Input / Description eter trans- for- mDesc ory Output Input Pointer to the structure holding the matrix transform descriptor that should be destroyed by this function. See cublasLtMatrixTransfor- mDesc_t. Returns: Return Value Description CUBLAS_STATUS_SUCCESS If the operation was successful. See cublasStatus_t for a complete list of valid return codes. 5.4.44. cublasLtMatrixTransformDescGetAttribute() cublasStatus_t cublasLtMatrixTransformDescGetAttribute( cublasLtMatrixTransformDesc_t transformDesc, cublasLtMatrixTransformDescAttributes_t attr, void *buf, size_t sizeInBytes, size_t *sizeWritten); This function returns the value of the queried attribute belonging to a previously created matrix trans- form descriptor. Parameters: 248 Chapter 5. Using the cuBLASLt API cuBLAS, Release 12.3 Pa- Mem-In- Description ram- eter trans- for- mDesc attr buf sizeIn- Bytes ory put / Out- put In- put In- put Out- put In- put Pointer to the previously created structure holding the matrix transform de- scriptor queried by this function. See cublasLtMatrixTransformDesc_t. The attribute that will be retrieved by this function. See cublasLtMatrixTrans- formDescAttributes_t. Memory address containing the attribute value retrieved by this function. Size of buf buffer (in bytes) for verification. sizeWrit- ten Out- put Valid only when the return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: then sizeWritten is the number of bytes actually written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed to write full contents. Returns: Return Value CUBLAS_STATUS_INVALID_VALUE Description ? If sizeInBytes is 0 and sizeWritten is NULL, or ? if sizeInBytes is non-zero and buf is NULL, or ? sizeInBytes doesn’t match size of inter- nal storage for the selected attribute CUBLAS_STATUS_SUCCESS If attribute’s value was successfully written to user memory. See cublasStatus_t for a complete list of valid return codes. 5.4.45. cublasLtMatrixTransformDescSetAttribute() cublasStatus_t cublasLtMatrixTransformDescSetAttribute( cublasLtMatrixTransformDesc_t transformDesc, cublasLtMatrixTransformDescAttributes_t attr, const void *buf, size_t sizeInBytes); This function sets the value of the specified attribute belonging to a previously created matrix trans- form descriptor. Parameters: 5.4. cuBLASLt API Reference 249 cuBLAS, Release 12.3 Param- Mem- Input / Description eter trans- for- mDesc attr buf sizeIn- Bytes ory Output Input Input Input Input Pointer to the previously created structure holding the matrix transform descriptor queried by this function. See cublasLtMatrixTransformDesc_t. The attribute that will be set by this function. See cublasLtMatrixTrans- formDescAttributes_t. The value to which the specified attribute should be set. Size of buf buffer (in bytes) for verification. Returns: Return Value Description CUBLAS_STATUS_INVALID_IfVbAuLfUEis NULL or sizeInBytes does not match size of the internal stor- age for the selected attribute. CUBLAS_STATUS_SUCCESISf the attribute was set successfully. See cublasStatus_t for a complete list of valid return codes. 250 Chapter 5. Using the cuBLASLt API Chapter 6. Using the cuBLASXt API 6.1. General description The cuBLASXt API of cuBLAS exposes a multi-GPU capable host interface: when using this API the application only needs to allocate the required matrices on the host memory space. Additionally, the current implementation supports managed memory on Linux with GPU devices that have compute capability 6.x or greater but treats it as host memory. Managed memory is not supported on Windows. There are no restriction on the sizes of the matrices as long as they can fit into the host memory. The cuBLASXt API takes care of allocating the memory across the designated GPUs and dispatched the workload between them and finally retrieves the results back to the host. The cuBLASXt API supports only the compute-intensive BLAS3 routines (e.g matrix-matrix operations) where the PCI transfers back and forth from the GPU can be amortized. The cuBLASXt API has its own header file cublasXt. h. Starting with release 8.0, cuBLASXt API allows any of the matrices to be located on a GPU device. Note : The cuBLASXt API is only supported on 64-bit platforms. 6.1.1. Tiling design approach To be able to share the workload between multiples GPUs, the cuBLASXt API uses a tiling strategy : every matrix is divided in square tiles of user-controllable dimension BlockDim x BlockDim. The result- ing matrix tiling defines the static scheduling policy : each resulting tile is affected to a GPU in a round robin fashion One CPU thread is created per GPU and is responsible to do the proper memory transfers and cuBLAS operations to compute all the tiles that it is responsible for. From a performance point of view, due to this static scheduling strategy, it is better that compute capabilites and PCI bandwidth are the same for every GPU. The figure below illustrates the tiles distribution between 3 GPUs. To compute the first tile G0 from C, the CPU thread 0 responsible of GPU0, have to load 3 tiles from the first row of A and tiles from the first columun of B in a pipeline fashion in order to overlap memory transfer and computations and sum the results into the first tile G0 of C before to move on to the next tile G0. When the tile dimension is not an exact multiple of the dimensions of C, some tiles are partially filled on the right border or/and the bottom border. The current implementation does not pad the incomplete tiles but simply keep track of those incomplete tiles by doing the right reduced cuBLAS opearations : this way, no extra computation is done. However it still can lead to some load unbalance when all GPUS do not have the same number of incomplete tiles to work on. When one or more matrices are located on some GPU devices, the same tiling approach and workload sharing is applied. The memory transfers are in this case done between devices. However, when the 251 cuBLAS, Release 12.3 Fig. 1: Example of cublasXt<t>gemm tiling for 3 Gpus 252 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 computation of a tile and some data are located on the same GPU device, the memory transfer to/from the local data into tiles is bypassed and the GPU operates directly on the local data. This can lead to a significant performance increase, especially when only one GPU is used for the computation. The matrices can be located on any GPU device, and do not have to be located on the same GPU device. Furthermore, the matrices can even be located on a GPU device that do not participate to the computation. On the contrary of the cuBLAS API, even if all matrices are located on the same device, the cuBLASXt API is still a blocking API from the host point of view : the data results wherever located will be valid on the call return and no device synchronization is required. 6.1.2. Hybrid CPU-GPU computation In the case of very large problems, the cuBLASXt API offers the possibility to offload some of the computation to the host CPU. This feature can be setup with the routines cublasXtSetCpuRoutine() and cublasXtSetCpuRatio() The workload affected to the CPU is put aside : it is simply a percentage of the resulting matrix taken from the bottom and the right side whichever dimension is bigger. The GPU tiling is done after that on the reduced resulting matrix. If any of the matrices is located on a GPU device, the feature is ignored and all computation will be done only on the GPUs This feature should be used with caution because it could interfere with the CPU threads responsible of feeding the GPUs. Currently, only the routine cublasXt<t>gemm supports this feature. 6.1.3. Results reproducibility Currently all cuBLASXt API routines from a given toolkit version, generate the same bit-wise results when the following conditions are respected : ? all GPUs particating to the computation have the same compute capabilities and the same num- ber of SMs. ? the tiles size is kept the same between run. ? either the CPU hybrid computation is not used or the CPU Blas provided is also guaranteed to produce reproducible results. 6.2. cuBLASXt API Datatypes Reference 6.2.1. cublasXtHandle_t The cublasXtHandle_t type is a pointer type to an opaque structure holding the cuBLASXt API con- text. The cuBLASXt API context must be initialized using cublasXtCreate() and the returned handle must be passed to all subsequent cuBLASXt API function calls. The context should be destroyed at the end using cublasXtDestroy(). 6.2. cuBLASXt API Datatypes Reference 253 cuBLAS, Release 12.3 6.2.2. cublasXtOpType_t The cublasOpType_t enumerates the four possible types supported by BLAS routines. This enum is used as parameters of the routines cublasXtSetCpuRoutine and cublasXtSetCpuRatio to setup the hybrid configuration. Value CUBLASXT_FLOAT CUBLASXT_DOUBLE CUBLASXT_COMPLEX CUBLASXT_DOUBLECOMPLEX Meaning float or single precision type double precision type single precision complex double precision complex 6.2.3. cublasXtBlasOp_t The cublasXtBlasOp_t type enumerates the BLAS3 or BLAS-like routine supported by cuBLASXt API. This enum is used as parameters of the routines cublasXtSetCpuRoutine and cublasXtSetCpuRatio to setup the hybrid configuration. Value CUBLASXT_GEMM CUBLASXT_SYRK CUBLASXT_HERK CUBLASXT_SYMM CUBLASXT_HEMM CUBLASXT_TRSM CUBLASXT_SYR2K CUBLASXT_HER2K CUBLASXT_SPMM CUBLASXT_SYRKX CUBLASXT_HERKX Meaning GEMM routine SYRK routine HERK routine SYMM routine HEMM routine TRSM routine SYR2K routine HER2K routine SPMM routine SYRKX routine HERKX routine 254 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.2.4. cublasXtPinningMemMode_t The type is used to enable or disable the Pinning Memory mode through the routine cubasMgSet- PinningMemMode Value CUBLASXT_PINNING_DISABLED CUBLASXT_PINNING_ENABLED Meaning the Pinning Memory mode is disabled the Pinning Memory mode is enabled 6.3. cuBLASXt API Helper Function Reference 6.3.1. cublasXtCreate() cublasStatus_t cublasXtCreate(cublasXtHandle_t *handle) This function initializes the cuBLASXt API and creates a handle to an opaque structure holding the cuBLASXt API context. It allocates hardware resources on the host and device and must be called prior to making any other cuBLASXt API calls. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_NOT_SUPPORTED Meaning the initialization succeeded the resources could not be allocated cuBLASXt API is only supported on 64-bit platform 6.3.2. cublasXtDestroy() cublasStatus_t cublasXtDestroy(cublasXtHandle_t handle) This function releases hardware resources used by the cuBLASXt API context. The release of GPU re- sources may be deferred until the application exits. This function is usually the last call with a particular handle to the cuBLASXt API. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED Meaning the shut down succeeded the library was not initialized 6.3. cuBLASXt API Helper Function Reference 255 cuBLAS, Release 12.3 6.3.3. cublasXtDeviceSelect() cublasXtDeviceSelect(cublasXtHandle_t handle, int nbDevices, int deviceId[]) This function allows the user to provide the number of GPU devices and their respective Ids that will participate to the subsequent cuBLASXt API Math function calls. This function will create a cuBLAS context for every GPU provided in that list. Currently the device configuration is static and cannot be changed between Math function calls. In that regard, this function should be called only once after cublasXtCreate. To be able to run multiple configurations, multiple cuBLASXt API contexts should be created. Return Value Meaning CUBLAS_STATUS_SUCCEUSsSer call was sucessful CUBLAS_STATUS_INVALAIcDce_sVsAtLoUEat least one of the device could not be done or a cuBLAS context could not be created on at least one of the device CUBLAS_STATUS_ALLOCS_oFmAeIrLeEsDources could not be allocated. 6.3.4. cublasXtSetBlockDim() cublasXtSetBlockDim(cublasXtHandle_t handle, int blockDim) This function allows the user to set the block dimension used for the tiling of the matrices for the subsequent Math function calls. Matrices are split in square tiles of blockDim x blockDim dimension. This function can be called anytime and will take effect for the following Math function calls. The block dimension should be chosen in a way to optimize the math operation and to make sure that the PCI transfers are well overlapped with the computation. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE Meaning the call has been successful blockDim <= 0 6.3.5. cublasXtGetBlockDim() cublasXtGetBlockDim(cublasXtHandle_t handle, int *blockDim) This function allows the user to query the block dimension used for the tiling of the matrices. Return Value Meaning CUBLAS_STATUS_SUCCESS the call has been successful 256 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.3.6. cublasXtSetCpuRoutine() cublasXtSetCpuRoutine(cublasXtHandle_t handle, cublasXtBlasOp_t blasOp, ‹>cublasXtOpType_t type, void *blasFunctor) This function allows the user to provide a CPU implementation of the corresponding BLAS routine. This function can be used with the function cublasXtSetCpuRatio() to define an hybrid computation between the CPU and the GPUs. Currently the hybrid feature is only supported for the xGEMM rou- tines. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_SUPPORTED Meaning the call has been successful blasOp or type define an invalid combination CPU-GPU Hybridization for that routine is not supported 6.3.7. cublasXtSetCpuRatio() cublasXtSetCpuRatio(cublasXtHandle_t handle, cublasXtBlasOp_t blasOp, cublasXtOpType_ ‹>t type, float ratio ) This function allows the user to define the percentage of workload that should be done on a CPU in the context of an hybrid computation. This function can be used with the function cublasXtSetCpuRou- tine() to define an hybrid computation between the CPU and the GPUs. Currently the hybrid feature is only supported for the xGEMM routines. Return Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_SUPPORTED Meaning the call has been successful blasOp or type define an invalid combination CPU-GPU Hybridization for that routine is not supported 6.3.8. cublasXtSetPinningMemMode() cublasXtSetPinningMemMode(cublasXtHandle_t handle, cublasXtPinningMemMode_t mode) This function allows the user to enable or disable the Pinning Memory mode. When enabled, the matri- ces passed in subsequent cuBLASXt API calls will be pinned/unpinned using the CUDART routine cud- aHostRegister() and cudaHostUnregister() respectively if the matrices are not already pinned. If a matrix happened to be pinned partially, it will also not be pinned. Pinning the memory improve PCI transfer performace and allows to overlap PCI memory transfer with computation. However pin- ning/unpinning the memory take some time which might not be amortized. It is advised that the user pins the memory on its own using cudaMallocHost() or cudaHostRegister() and unpin it when the computation sequence is completed. By default, the Pinning Memory mode is disabled. 6.3. cuBLASXt API Helper Function Reference 257 cuBLAS, Release 12.3 Note: The Pinning Memory mode should not enabled when matrices used for different calls to cuBLASXt API overlap. cuBLASXt determines that a matrix is pinned or not if the first address of that matrix is pinned using cudaHostGetFlags(), thus cannot know if the matrix is already partially pinned or not. This is especially true in multi-threaded application where memory could be partially or totally pinned or unpinned while another thread is accessing that memory. Return Value Meaning CUBLAS_STATUS_SUCCESSthe call has been successful CUBLAS_STATUS_INVALIDt_hVeALmUoEde value is different from CUBLASXT_PINNING_DISABLED and CUBLASXT_PINNING_ENABLED 6.3.9. cublasXtGetPinningMemMode() cublasXtGetPinningMemMode(cublasXtHandle_t handle, cublasXtPinningMemMode_t *mode) This function allows the user to query the Pinning Memory mode. By default, the Pinning Memory mode is disabled. Return Value Meaning CUBLAS_STATUS_SUCCESS the call has been successful 6.4. cuBLASXt API Math Functions Reference In this chapter we describe the actual Linear Agebra routines that cuBLASXt API supports. We will use abbreviations <type> for type and <t> for the corresponding short type to make a more concise and clear presentation of the implemented functions. Unless otherwise specified <type> and <t> have the following meanings: <type> float double cuComplex cuDoubleComplex <t> ‘s’ or ‘S’ ‘d’ or ‘D’ ‘c’ or ‘C’ ‘z’ or ‘Z’ Meaning real single-precision real double-precision complex single-precision complex double-precision The abbreviation Re( ) and Im( ) will stand for the real and imaginary part of a number, respectively. Since imaginary part of a real number does not exist, we will consider it to be zero and can usually simply discard it from the equation where it is being used. Also, the ?? will denote the complex conjugate of ? . 258 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 In general throughout the documentation, the lower case Greek symbols ? and ? will denote scalars, lower case English letters in bold type x and y will denote vectors and capital English letters A , B and C will denote matrices. 6.4.1. cublasXt<t>gemm() cublasStatus_t cublasXtSgemm(cublasXtHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, size_t m, size_t n, size_t k, const float *alpha, const float *A, int lda, const float *B, int ldb, const float *beta, float *C, int ldc) cublasStatus_t cublasXtDgemm(cublasXtHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double *alpha, const double *A, int lda, const double *B, int ldb, const double *beta, double *C, int ldc) cublasStatus_t cublasXtCgemm(cublasXtHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *B, int ldb, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasXtZgemm(cublasXtHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function performs the matrix-matrix multiplication C = ?op(A)op(B) + ?C where ? and ? are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A) m ? k , op(B) k ? n and C m ? n , respectively. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C 6.4. cuBLASXt API Math Functions Reference 259 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle ory in- put handle to the cuBLASXt API context. transa transb m n k in- put in- put in- put in- put in- put operation op(A) that is non- or (conj.) transpose. operation op(B) that is non- or (conj.) transpose. number of rows of matrix op(A) and C. number of columns of matrix op(B) and C. number of columns of op(A) and rows of op(B). al- pha A lda B ldb beta host host or device host or device host in- put in- put in- put in- put in- put in- put <type> scalar used for multiplication. <type> array of dimensions lda x k with lda>=max(1,m) if transa == CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store the matrix A. <type> array of dimension ldb x n with ldb>=max(1,k) if transb == CUBLAS_OP_N and ldb x k with ldb>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication. If beta==0, C does not have to be a valid input. C host or device in/out<type> array of dimensions ldc x n with ldc>=max(1,m). ldc in- put leading dimension of a two-dimensional array used to store the matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n,k<0 the function failed to launch on the GPU For references please refer to: sgemm, dgemm, cgemm, zgemm 260 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.2. cublasXt<t>hemm() cublasStatus_t cublasXtChemm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, const cuComplex *beta, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZhemm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, size_t ldc) This function performs the Hermitian matrix-matrix multiplication C = ?AB + ?C if side == CUBLAS_SIDE_LEFT ?BA + ?C if side == CUBLAS_SIDE_RIGHT where A is a Hermitian matrix stored in lower or upper mode, B and C are m n matrices, and ? and ? are scalars. 6.4. cuBLASXt API Math Functions Reference 261 cuBLAS, Release 12.3 ParamM. em- ory In/outMeaning han- dle side uplo m n al- pha A lda B ldb beta host host or de- vice host or de- vice host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements. number of rows of matrix C and B, with matrix A sized accordingly. number of columns of matrix C and B, with matrix A sized accordingly. <type> scalar used for multiplication. <type> array of dimension lda x m with lda>=max(1,m) if side==CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) other- wise. The imaginary parts of the diagonal elements are assumed to be zero. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C host or de- vice in/out<type> array of dimensions ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n<0 the function failed to launch on the GPU 262 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 For references please refer to: chemm, zhemm 6.4.3. cublasXt<t>symm() cublasStatus_t cublasXtSsymm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const float *alpha, const float *A, size_t lda, const float *B, size_t ldb, const float *beta, float *C, size_t ldc) cublasStatus_t cublasXtDsymm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const double *alpha, const double *A, size_t lda, const double *B, size_t ldb, const double *beta, double *C, size_t ldc) cublasStatus_t cublasXtCsymm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, const cuComplex *beta, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZsymm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, size_t ldc) This function performs the symmetric matrix-matrix multiplication C = ?AB + ?C if side == CUBLAS_SIDE_LEFT ?BA + ?C if side == CUBLAS_SIDE_RIGHT where A is a symmetric matrix stored in lower or upper mode, A and A are m n matrices, and ? and ? are scalars. 6.4. cuBLASXt API Math Functions Reference 263 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle side uplo m n al- pha A lda B ldb beta ory host host or device host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows of matrix A and B, with matrix A sized accordingly. number of columns of matrix C and A, with matrix A sized accordingly. <type> scalar used for multiplication. <type> array of dimension lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta == 0 then C does not have to be a valid input. C host or device in/out<type> array of dimension ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n<0 the function failed to launch on the GPU For references please refer to: ssymm, dsymm, csymm, zsymm 264 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.4. cublasXt<t>syrk() cublasStatus_t cublasXtSsyrk(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const float *A, int lda, const float *beta, float *C, int ldc) cublasStatus_t cublasXtDsyrk(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double *alpha, const double *A, int lda, const double *beta, double *C, int ldc) cublasStatus_t cublasXtCsyrk(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex *alpha, const cuComplex *A, int lda, const cuComplex *beta, cuComplex *C, int ldc) cublasStatus_t cublasXtZsyrk(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *beta, cuDoubleComplex *C, int ldc) This function performs the symmetric rank- k update C = ?op(A)op(A)T + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ? A if transa == CUBLAS_OP_N ?AT if transa == CUBLAS_OP_T 6.4. cuBLASXt API Math Functions Reference 265 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda beta ory host host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix C lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. operation op(A) that is non- or transpose. number of rows of matrix op(A) and C. number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if trans == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C host or device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,k<0 the function failed to launch on the GPU For references please refer to: ssyrk, dsyrk, csyrk, zsyrk 266 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.5. cublasXt<t>syr2k() cublasStatus_t cublasXtSsyr2k(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const float *alpha, const float *A, size_t lda, const float *B, size_t ldb, const float *beta, float *C, size_t ldc) cublasStatus_t cublasXtDsyr2k(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const double *alpha, const double *A, size_t lda, const double *B, size_t ldb, const double *beta, double *C, size_t ldc) cublasStatus_t cublasXtCsyr2k(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, const cuComplex *beta, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZsyr2k(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, size_t ldc) This function performs the symmetric rank- 2k update C = ?(op(A)op(B)T + op(B)op(A)T ) + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N ?AT and BT if trans == CUBLAS_OP_T 6.4. cuBLASXt API Math Functions Reference 267 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host host or device host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements. operation op(A) that is non- or transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimensions ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0, then C does not have to be a valid input. C host or device in/out<type> array of dimensions ldc x n with ldc>=max(1,n). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,k<0 the function failed to launch on the GPU For references please refer to: ssyr2k, dsyr2k, csyr2k, zsyr2k 268 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.6. cublasXt<t>syrkx() cublasStatus_t cublasXtSsyrkx(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const float *alpha, const float *A, size_t lda, const float *B, size_t ldb, const float *beta, float *C, size_t ldc) cublasStatus_t cublasXtDsyrkx(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const double *alpha, const double *A, size_t lda, const double *B, size_t ldb, const double *beta, double *C, size_t ldc) cublasStatus_t cublasXtCsyrkx(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, const cuComplex *beta, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZsyrkx(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, size_t ldc) This function performs a variation of the symmetric rank- k update C = ?(op(A)op(B)T + ?C where ? and ? are scalars, C is a symmetric matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N AT and BT if trans == CUBLAS_OP_T This routine can be used when B is in such way that the result is guaranteed to be symmetric. An usual example is when the matrix B is a scaled form of the matrix A : this is equivalent to B being the product of the matrix A and a diagonal matrix. 6.4. cuBLASXt API Math Functions Reference 269 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host host or device host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements. operation op(A) that is non- or transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimensions ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0, then C does not have to be a valid input. C host or device in/out<type> array of dimensions ldc x n with ldc>=max(1,n). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,k<0 the function failed to launch on the GPU For references please refer to: ssyrk, dsyrk, csyrk, zsyrk and ssyr2k, dsyr2k, csyr2k, zsyr2k 270 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.7. cublasXt<t>herk() cublasStatus_t cublasXtCherk(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float *alpha, const cuComplex *A, int lda, const float *beta, cuComplex *C, int ldc) cublasStatus_t cublasXtZherk(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double *alpha, const cuDoubleComplex *A, int lda, const double *beta, cuDoubleComplex *C, int ldc) This function performs the Hermitian rank- k update C = ?op(A)op(A)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n ? k . Also, for matrix A op(A) = ? A if transa == CUBLAS_OP_N ?AH if transa == CUBLAS_OP_C 6.4. cuBLASXt API Math Functions Reference 271 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda beta ory host host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. operation op(A) that is non- or (conj.) transpose. number of rows of matrix op(A) and C. number of columns of matrix op(A). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C host or device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,k<0 the function failed to launch on the GPU For references please refer to: cherk, zherk 272 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.8. cublasXt<t>her2k() cublasStatus_t cublasXtCher2k(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, const float *beta, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZher2k(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, const double *beta, cuDoubleComplex *C, size_t ldc) This function performs the Hermitian rank- 2k update C = ?op(A)op(B)H + ?op(B)op(A)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N ?AH and BH if trans == CUBLAS_OP_C 6.4. cuBLASXt API Math Functions Reference 273 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host host or device host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. operation op(A) that is non- or (conj.) transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta==0 then C does not have to be a valid input. C host or device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,k<0 the function failed to launch on the GPU For references please refer to: cher2k, zher2k 274 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.9. cublasXt<t>herkx() cublasStatus_t cublasXtCherkx(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, const float *beta, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZherkx(cublasXtHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, size_t n, size_t k, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, const double *beta, cuDoubleComplex *C, size_t ldc) This function performs a variation of the Hermitian rank- k update C = ?op(A)op(B)H + ?C where ? and ? are scalars, C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n ? k and op(B) n ? k , respectively. Also, for matrix A and B op(A) and op(B) = ?? A and B if trans == CUBLAS_OP_N AH and BH if trans == CUBLAS_OP_C This routine can be used when the matrix B is in such way that the result is guaranteed to be hermitian. An usual example is when the matrix B is a scaled form of the matrix A : this is equivalent to B being the product of the matrix A and a diagonal matrix. For an efficient computation of the product of a regular matrix with a diagonal matrix, refer to the routine cublasXt<t>dgmm. 6.4. cuBLASXt API Math Functions Reference 275 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle uplo trans n k al- pha A lda B ldb beta ory host host or device host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix C lower or upper part is stored, the other Hermitian part is not referenced. operation op(A) that is non- or (conj.) transpose. number of rows of matrix op(A), op(B) and C. number of columns of matrix op(A) and op(B). <type> scalar used for multiplication. <type> array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x k with ldb>=max(1,n) if transb == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise. leading dimension of two-dimensional array used to store matrix B. real scalar used for multiplication, if beta==0 then C does not have to be a valid input. C host or device in/out<type> array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero. ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters n,k<0 the function failed to launch on the GPU For references please refer to: cherk, zherk and cher2k, zher2k 276 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.10. cublasXt<t>trsm() cublasStatus_t cublasXtStrsm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasXtDiagType_t diag, size_t m, size_t n, const float *alpha, const float *A, size_t lda, float *B, size_t ldb) cublasStatus_t cublasXtDtrsm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasXtDiagType_t diag, size_t m, size_t n, const double *alpha, const double *A, size_t lda, double *B, size_t ldb) cublasStatus_t cublasXtCtrsm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasXtDiagType_t diag, size_t m, size_t n, const cuComplex *alpha, const cuComplex *A, size_t lda, cuComplex *B, size_t ldb) cublasStatus_t cublasXtZtrsm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasXtDiagType_t diag, size_t m, size_t n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, cuDoubleComplex *B, size_t ldb) This function solves the triangular linear system with multiple right-hand-sides op(A)X = ?B if side == CUBLAS_SIDE_LEFT Xop(A) = ?B if side == CUBLAS_SIDE_RIGHT where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, X and B are m ? n matrices, and ? is a scalar. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C The solution X overwrites the right-hand-sides B on exit. No test for singularity or near-singularity is included in this function. 6.4. cuBLASXt API Math Functions Reference 277 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle side uplo trans diag m n al- pha A lda ory host host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix A is on the left or right of X. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows of matrix B, with matrix A sized accordingly. number of columns of matrix B, with matrix A is sized accordingly. <type> scalar used for multiplication, if alpha==0 then A is not referenced and B does not have to be a valid input. <type> array of dimension lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A. B host or device in/out<type> array. It has dimensions ldb x n with ldb>=max(1,m). ldb in- put leading dimension of two-dimensional array used to store matrix B. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n<0 the function failed to launch on the GPU For references please refer to: strsm, dtrsm, ctrsm, ztrsm 278 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.11. cublasXt<t>trmm() cublasStatus_t cublasXtStrmm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, size_t m, size_t n, const float *alpha, const float *A, size_t lda, const float *B, size_t ldb, float *C, size_t ldc) cublasStatus_t cublasXtDtrmm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, size_t m, size_t n, const double *alpha, const double *A, size_t lda, const double *B, size_t ldb, double *C, size_t ldc) cublasStatus_t cublasXtCtrmm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, size_t m, size_t n, const cuComplex *alpha, const cuComplex *A, size_t lda, const cuComplex *B, size_t ldb, cuComplex *C, size_t ldc) cublasStatus_t cublasXtZtrmm(cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, size_t m, size_t n, const cuDoubleComplex *alpha, const cuDoubleComplex *A, size_t lda, const cuDoubleComplex *B, size_t ldb, cuDoubleComplex *C, size_t ldc) This function performs the triangular matrix-matrix multiplication C = ?op(A)B if side == CUBLAS_SIDE_LEFT ?Bop(A) if side == CUBLAS_SIDE_RIGHT where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m ? n matrix, and ? is a scalar. Also, for matrix A op(A) = AT if transa == CUBLAS_OP_T ???AH if transa == CUBLAS_OP_C Notice that in order to achieve better parallelism, similarly to the cublas API, cuBLASXt API differs from the BLAS API for this routine. The BLAS API assumes an in-place implementation (with results written back to B), while the cuBLASXt API assumes an out-of-place implementation (with results written into C). The application can still obtain the in-place functionality of BLAS in the cuBLASXt API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported. 6.4. cuBLASXt API Math Functions Reference 279 cuBLAS, Release 12.3 ParamM. em- In/outMeaning han- dle side uplo trans diag m n al- pha A lda B ldb ory host host or device host or device in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other part is not refer- enced and is inferred from the stored elements. operation op(A) that is non- or (conj.) transpose. indicates if the elements on the main diagonal of matrix A are unity and should not be accessed. number of rows of matrix B, with matrix A sized accordingly. number of columns of matrix B, with matrix A sized accordingly. <type> scalar used for multiplication, if alpha==0 then A is not referenced and B does not have to be a valid input. <type> array of dimension lda x m with lda>=max(1,m) if side == CUBLAS_SIDE_LEFT and lda x n with lda>=max(1,n) otherwise. leading dimension of two-dimensional array used to store matrix A. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. C host or device in/out<type> array of dimension ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n<0 the function failed to launch on the GPU For references please refer to: strmm, dtrmm, ctrmm, ztrmm 280 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 6.4.12. cublasXt<t>spmm() cublasStatus_t cublasXtSspmm( cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const float *alpha, const float *AP, const float *B, size_t ldb, const float *beta, float *C, size_t ldc ); cublasStatus_t cublasXtDspmm( cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const double *alpha, const double *AP, const double *B, size_t ldb, const double *beta, double *C, size_t ldc ); cublasStatus_t cublasXtCspmm( cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const cuComplex *alpha, const cuComplex *AP, const cuComplex *B, size_t ldb, const cuComplex *beta, cuComplex *C, size_t ldc ); cublasStatus_t cublasXtZspmm( cublasXtHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, size_t m, size_t n, const cuDoubleComplex *alpha, const cuDoubleComplex *AP, const cuDoubleComplex *B, size_t ldb, const cuDoubleComplex *beta, cuDoubleComplex *C, size_t ldc ); This function performs the symmetric packed matrix-matrix multiplication 6.4. cuBLASXt API Math Functions Reference 281 cuBLAS, Release 12.3 C = ?AB + ?C if side == CUBLAS_SIDE_LEFT ?BA + ?C if side == CUBLAS_SIDE_RIGHT where A is a n n symmetric matrix stored in packed format, B and C are m n matrices, and ? and ? are scalars. If uplo == CUBLAS_FILL_MODE_LOWER then the elements in the lower triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+((2*n-j+1)*j)?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. If uplo == CUBLAS_FILL_MODE_UPPER then the elements in the upper triangular part of the sym- metric matrix A are packed together column by column without gaps, so that the element A(i, j) is stored in the memory location AP[i+(j*(j+1))?2] for j = 1, . . . , n and i ? j . Consequently, the packed format requires only ?????? elements for storage. Note: The packed matrix AP must be located on the host or managed memory whereas the other matrices can be located on the host or any GPU device ParamM. em- In/outMeaning han- dle side uplo m n al- pha AP B ldb beta ory host host host or device host in- put in- put in- put in- put in- put in- put in- put in- put in- put in- put handle to the cuBLASXt API context. indicates if matrix A is on the left or right of B. indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements. number of rows of matrix A and B, with matrix A sized accordingly. number of columns of matrix C and A, with matrix A sized accordingly. <type> scalar used for multiplication. <type> array with A stored in packed format. <type> array of dimension ldb x n with ldb>=max(1,m). leading dimension of two-dimensional array used to store matrix B. <type> scalar used for multiplication, if beta == 0 then C does not have to be a valid input. C host or device in/out<type> array of dimension ldc x n with ldc>=max(1,m). ldc in- put leading dimension of two-dimensional array used to store matrix C. 282 Chapter 6. Using the cuBLASXt API cuBLAS, Release 12.3 The possible error values returned by this function and their meanings are listed below. Error Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_NOT_SUPPORTED CUBLAS_STATUS_EXECUTION_FAILED Meaning the operation completed successfully the library was not initialized the parameters m,n<0 the matrix AP is located on a GPU device the function failed to launch on the GPU For references please refer to: ssymm, dsymm, csymm, zsymm 6.4. cuBLASXt API Math Functions Reference 283 cuBLAS, Release 12.3 284 Chapter 6. Using the cuBLASXt API Chapter 7. Using the cuBLAS Legacy API This section does not provide a full reference of each Legacy API datatype and entry point. Instead, it describes how to use the API, especially where this is different from the regular cuBLAS API. Note that in this section, all references to the “cuBLAS Library” refer to the Legacy cuBLAS API only. Warning: The legacy cuBLAS API is deprecated and will be removed in future release. 7.1. Error Status The cublasStatus type is used for function status returns. The cuBLAS Library helper functions return status directly, while the status of core functions can be retrieved using cublasGetEr- ror(). Notice that reading the error status via cublasGetError(), resets the internal error state to CUBLAS_STATUS_SUCCESS. Currently, the following values for are defined: Value CUBLAS_STATUS_SUCCESS CUBLAS_STATUS_NOT_INITIALIZED CUBLAS_STATUS_ALLOC_FAILED CUBLAS_STATUS_INVALID_VALUE CUBLAS_STATUS_ARCH_MISMATCH CUBLAS_STATUS_MAPPING_ERROR CUBLAS_STATUS_EXECUTION_FAILED CUBLAS_STATUS_INTERNAL_ERROR CUBLAS_STATUS_NOT_SUPPORTED Meaning the operation completed successfully the library was not initialized the resource allocation failed an invalid numerical value was used as an argument an absent device architectural feature is required an access to GPU memory space failed the GPU program failed to execute an internal operation failed the feature required is not supported This legacy type corresponds to type cublasStatus_t in the cuBLAS library API. 285 cuBLAS, Release 12.3 7.2. Initialization and Shutdown The functions cublasInit() and cublasShutdown() are used to initialize and shutdown the cuBLAS library. It is recommended for cublasInit() to be called before any other function is invoked. It allocates hardware resources on the GPU device that is currently bound to the host thread from which it was invoked. The legacy initialization and shutdown functions are similar to the cuBLAS library API routines cublasCreate() and cublasDestroy(). 7.3. Thread Safety The legacy API is not thread safe when used with multiple host threads and devices. It is recommended to be used only when utmost compatibility with Fortran is required and when a single host thread is used to setup the library and make all the functions calls. 7.4. Memory Management The memory used by the legacy cuBLAS library API is allocated and released using functions cublasAlloc() and cublasFree(), respectively. These functions create and destroy an object in the GPU memory space capable of holding an array of n elements, where each element requires el- emSize bytes of storage. Please see the legacy cuBLAS API header file “cublas.h” for the prototypes of these functions. The function cublasAlloc() is a wrapper around the function cudaMalloc(), therefore device pointers returned by cublasAlloc() can be passed to any CUDA™ device kernel functions. How- ever, these device pointers can not be dereferenced in the host code. The function cublasFree() is a wrapper around the function cudaFree(). 7.5. Scalar Parameters In the legacy cuBLAS API, scalar parameters are passed by value from the host. Also, the few functions that do return a scalar result, such as dot() and nrm2(), return the resulting value on the host, and hence these routines will wait for kernel execution on the device to complete before returning, which makes parallelism with streams impractical. However, the majority of functions do not return any value, in order to be more compatible with Fortran and the existing BLAS libraries. 286 Chapter 7. Using the cuBLAS Legacy API 7.6. Helper Functions cuBLAS, Release 12.3 In this section we list the helper functions provided by the legacy cuBLAS API and their functional- ity. For the exact prototypes of these functions please refer to the legacy cuBLAS API header file “cublas.h”. Helper function cublasInit() cublasShutdown() cublasGetError() cublasSetKernelStream() cublasAlloc() cublasFree() cublasSetVector() cublasGetVector() cublasSetMatrix() cublasGetMatrix() cublasSetVectorAsync() cublasGetVectorAsync() cublasSetMatrixAsync() cublasGetMatrixAsync() Meaning initialize the library shuts down the library retrieves the error status of the library sets the stream to be used by the library allocates the device memory for the library releases the device memory allocated for the library copies a vector x on the host to a vector on the GPU copies a vector x on the GPU to a vector on the host copies a m ? n tile from a matrix on the host to the GPU copies a m ? n tile from a matrix on the GPU to the host similar to cublasSetVector(), but the copy is asynchronous similar to cublasGetVector(), but the copy is asynchronous similar to cublasSetMatrix(), but the copy is asynchronous similar to cublasGetMatrix(), but the copy is asynchronous 7.7. Level-1,2,3 Functions The Level-1,2,3 cuBLAS functions (also called core functions) have the same name and behavior as the ones listed in the chapters 3, 4 and 5 in this document. Please refer to the legacy cuBLAS API header file “cublas.h” for their exact prototype. Also, the next section talks a bit more about the differences between the legacy and the cuBLAS API prototypes, more specifically how to convert the function calls from one API to another. 7.8. Converting Legacy to the cuBLAS API There are a few general rules that can be used to convert from legacy to the cuBLAS API: ? Exchange the header file “cublas.h” for “cublas_v2.h”. ? Exchange the type cublasStatus for cublasStatus_t. ? Exchange the function cublasSetKernelStream() for cublasSetStream(). 7.6. Helper Functions 287 cuBLAS, Release 12.3 ? Exchange the function cublasAlloc() and cublasFree() for cudaMalloc() and cud- aFree(), respectively. Notice that cudaMalloc() expects the size of the allocated memory to be provided in bytes (usually simply provide n x elemSize to allocate n elements, each of size elemSize bytes). ? Declare the cublasHandle_t cuBLAS library handle. ? Initialize the handle using cublasCreate(). Also, release the handle once finished using cublasDe- stroy(). ? Add the handle as the first parameter to all the cuBLAS library function calls. ? Change the scalar parameters to be passed by reference, instead of by value (usually simply adding “&” symbol in C/C++ is enough, because the parameters are passed by reference on the host by default). However, note that if the routine is running asynchronously, then the variable holding the scalar parameter cannot be changed until the kernels that the routine dispatches are completed. See the CUDA C++ Programming Guide for a detailed discussion of how to use streams. ? Change the parameter characters N or n (non-transpose operation), T or t (transpose operation) and C or c (conjugate transpose operation) to CUBLAS_OP_N, CUBLAS_OP_T and CUBLAS_OP_C, respectively. ? Change the parameter characters L or l (lower part filled) and U or u (upper part filled) to CUBLAS_FILL_MODE_LOWER and CUBLAS_FILL_MODE_UPPER, respectively. ? Change the parameter characters N or n (non-unit diagonal) and U or u (unit diagonal) to CUBLAS_DIAG_NON_UNIT and CUBLAS_DIAG_UNIT, respectively. ? Change the parameter characters L or l (left side) and R or r (right side) to CUBLAS_SIDE_LEFT and CUBLAS_SIDE_RIGHT, respectively. ? If the legacy API function returns a scalar value, add an extra scalar parameter of the same type passed by reference, as the last parameter to the same function. ? Instead of using cublasGetError(), use the return value of the function itself to check for errors. ? Finally, please use the function prototypes in the header files cublas.h and cublas_v2.h to check the code for correctness. 7.9. Examples For sample code references that use the legacy cuBLAS API please see the two examples below. They show an application written in C using the legacy cuBLAS library API with two indexing styles (Example A.1. “Application Using C and cuBLAS: 1-based indexing” and Example A.2. “Application Using C and cuBLAS: 0-based Indexing”). This application is analogous to the one using the cuBLAS library API that is shown in the Introduction chapter. Example A.1. Application Using C and cuBLAS: 1-based indexing ??----------------------------------------------------------- #include <stdio.h> #include <stdlib.h> #include <math.h> #include "cublas.h" #define M 6 (continues on next page) 288 Chapter 7. Using the cuBLAS Legacy API cuBLAS, Release 12.3 (continued from previous page) #define N 5 #define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1)) static inline void modify (float *m, int ldm, int n, int p, int q, float alpha, ‹>float beta){ cublasSscal (n-q+1, alpha, &m[IDX2F(p,q,ldm)], ldm); cublasSscal (ldm-p+1, beta, &m[IDX2F(p,q,ldm)], 1); } int main (void){ int i, j; cublasStatus stat; float* devPtrA; float* a = 0; a = (float *)malloc (M * N * sizeof (*a)); if (!a) { printf ("host memory allocation failed"); return EXIT_FAILURE; } for (j = 1; j <= N; j++) { for (i = 1; i <= M; i++) { a[IDX2F(i,j,M)] = (float)((i-1) * M + j); } } cublasInit(); stat = cublasAlloc (M*N, sizeof(*a), (void**)&devPtrA); if (stat != cuBLAS_STATUS_SUCCESS) { printf ("device memory allocation failed"); cublasShutdown(); return EXIT_FAILURE; } stat = cublasSetMatrix (M, N, sizeof(*a), a, M, devPtrA, M); if (stat != cuBLAS_STATUS_SUCCESS) { printf ("data download failed"); cublasFree (devPtrA); cublasShutdown(); return EXIT_FAILURE; } modify (devPtrA, M, N, 2, 3, 16.0f, 12.0f); stat = cublasGetMatrix (M, N, sizeof(*a), devPtrA, M, a, M); if (stat != cuBLAS_STATUS_SUCCESS) { printf ("data upload failed"); cublasFree (devPtrA); cublasShutdown(); return EXIT_FAILURE; } cublasFree (devPtrA); cublasShutdown(); for (j = 1; j <= N; j++) { for (i = 1; i <= M; i++) { printf ("%7.0f", a[IDX2F(i,j,M)]); } printf ("\n"); } free(a); return EXIT_SUCCESS; } 7.9. Examples 289 cuBLAS, Release 12.3 Example A.2. Application Using C and cuBLAS: 0-based indexing ??----------------------------------------------------------- #include <stdio.h> #include <stdlib.h> #include <math.h> #include "cublas.h" #define M 6 #define N 5 #define IDX2C(i,j,ld) (((j)*(ld))+(i)) static inline void modify (float *m, int ldm, int n, int p, int q, float alpha, ‹>float beta){ cublasSscal (n-q, alpha, &m[IDX2C(p,q,ldm)], ldm); cublasSscal (ldm-p, beta, &m[IDX2C(p,q,ldm)], 1); } int main (void){ int i, j; cublasStatus stat; float* devPtrA; float* a = 0; a = (float *)malloc (M * N * sizeof (*a)); if (!a) { printf ("host memory allocation failed"); return EXIT_FAILURE; } for (j = 0; j < N; j++) { for (i = 0; i < M; i++) { a[IDX2C(i,j,M)] = (float)(i * M + j + 1); } } cublasInit(); stat = cublasAlloc (M*N, sizeof(*a), (void**)&devPtrA); if (stat != cuBLAS_STATUS_SUCCESS) { printf ("device memory allocation failed"); cublasShutdown(); return EXIT_FAILURE; } stat = cublasSetMatrix (M, N, sizeof(*a), a, M, devPtrA, M); if (stat != cuBLAS_STATUS_SUCCESS) { printf ("data download failed"); cublasFree (devPtrA); cublasShutdown(); return EXIT_FAILURE; } modify (devPtrA, M, N, 1, 2, 16.0f, 12.0f); stat = cublasGetMatrix (M, N, sizeof(*a), devPtrA, M, a, M); if (stat != cuBLAS_STATUS_SUCCESS) { printf ("data upload failed"); cublasFree (devPtrA); cublasShutdown(); return EXIT_FAILURE; } cublasFree (devPtrA); cublasShutdown(); for (j = 0; j < N; j++) { for (i = 0; i < M; i++) { (continues on next page) 290 Chapter 7. Using the cuBLAS Legacy API cuBLAS, Release 12.3 (continued from previous page) printf ("%7.0f", a[IDX2C(i,j,M)]); } printf ("\n"); } free(a); return EXIT_SUCCESS; } 7.9. Examples 291 cuBLAS, Release 12.3 292 Chapter 7. Using the cuBLAS Legacy API Chapter 8. cuBLAS Fortran Bindings The cuBLAS library is implemented using the C-based CUDA toolchain. Thus, it provides a C-style API. This makes interfacing to applications written in C and C++ trivial, but the library can also be used by applications written in Fortran. In particular, the cuBLAS library uses 1-based indexing and Fortran-style column-major storage for multidimensional data to simplify interfacing to Fortran appli- cations. Unfortunately, Fortran-to-C calling conventions are not standardized and differ by platform and toolchain. In particular, differences may exist in the following areas: ? symbol names (capitalization, name decoration) ? argument passing (by value or reference) ? passing of string arguments (length information) ? passing of pointer arguments (size of the pointer) ? returning floating-point or compound data types (for example single-precision or complex data types) To provide maximum flexibility in addressing those differences, the cuBLAS Fortran interface is pro- vided in the form of wrapper functions and is part of the Toolkit delivery. The C source code of those wrapper functions is located in the src directory and provided in two different forms: ? the thunking wrapper interface located in the file fortran_thunking.c ? the direct wrapper interface located in the file fortran.c The code of one of those two files needs to be compiled into an application for it to call the cuBLAS API functions. Providing source code allows users to make any changes necessary for a particular platform and toolchain. The code in those two C files has been used to demonstrate interoperability with the compilers g77 3.2.3 and g95 0.91 on 32-bit Linux, g77 3.4.5 and g95 0.91 on 64-bit Linux, Intel Fortran 9.0 and Intel Fortran 10.0 on 32-bit and 64-bit Microsoft Windows XP, and g77 3.4.0 and g95 0.92 on Mac OS X. Note that for g77, use of the compiler flag -fno-second-underscore is required to use these wrap- pers as provided. Also, the use of the default calling conventions with regard to argument and return value passing is expected. Using the flag -fno-f2c changes the default calling convention with respect to these two items. The thunking wrappers allow interfacing to existing Fortran applications without any changes to the application. During each call, the wrappers allocate GPU memory, copy source data from CPU memory space to GPU memory space, call cuBLAS, and finally copy back the results to CPU memory space and deallocate the GPU memory. As this process causes very significant call overhead, these wrappers are intended for light testing, not for production code. To use the thunking wrappers, the application needs to be compiled with the file fortran_thunking.c. The direct wrappers, intended for production code, substitute device pointers for vector and matrix arguments in all BLAS functions. To use these interfaces, existing applications need to be modified 293 cuBLAS, Release 12.3 slightly to allocate and deallocate data structures in GPU memory space (using cuBLAS_ALLOC and cuBLAS_FREE) and to copy data between GPU and CPU memory spaces (using cuBLAS_SET_VECTOR, cuBLAS_GET_VECTOR, cuBLAS_SET_MATRIX, and cuBLAS_GET_MATRIX). The sample wrappers pro- vided in fortran.c map device pointers to the OS-dependent type size_t, which is 32-bit wide on 32-bit platforms and 64-bit wide on a 64-bit platforms. One approach to deal with index arithmetic on device pointers in Fortran code is to use C-style macros, and use the C preprocessor to expand these, as shown in the example below. On Linux and Mac OS X, one way of pre-processing is to use the option -E -x f77-cpp-input when using g77 compiler, or simply the option -cpp when using g95 or gfortran. On Windows platforms with Microsoft Visual C/C++, using ’cl -EP’ achieves similar results. ! Example B.1. Fortran 77 Application Executing on the Host ! subroutine modify ( m, ldm, n, p, q, alpha, beta ) implicit none integer ldm, n, p, q real*4 m (ldm, *) , alpha , beta external cublas_sscal call cublas_sscal (n-p+1, alpha , m(p,q), ldm) call cublas_sscal (ldm-p+1, beta, m(p,q), 1) return end program matrixmod implicit none integer M,N parameter (M=6, N=5) real*4 a(M,N) integer i, j external cublas_init external cublas_shutdown do j = 1, N do i = 1, M a(i, j) = (i-1)*M + j enddo enddo call cublas_init call modify ( a, M, N, 2, 3, 16.0, 12.0 ) call cublas_shutdown do j = 1 , N do i = 1 , M write(*,"(F7.0$)") a(i,j) enddo write (*,*) "" enddo stop end When traditional fixed-form Fortran 77 code is ported to use the cuBLAS library, line length often increases when the BLAS calls are exchanged for cuBLAS calls. Longer function names and possible macro expansion are contributing factors. Inadvertently exceeding the maximum line length can lead to run-time errors that are difficult to find, so care should be taken not to exceed the 72-column limit if fixed form is retained. The examples in this chapter show a small application implemented in Fortran 77 on the host and the same application with the non-thunking wrappers after it has been ported to use the cuBLAS library. 294 Chapter 8. cuBLAS Fortran Bindings cuBLAS, Release 12.3 The second example should be compiled with ARCH_64 defined as 1 on 64-bit OS system and as 0 on 32-bit OS system. For example for g95 or gfortran, this can be done directly on the command line by using the option -cpp -DARCH_64=1. ! Example B.2. Same Application Using Non-thunking cuBLAS Calls !------------------------------------------------------------- #define IDX2F (i,j,ld) ((((j)-1)*(ld))+((i)-1)) subroutine modify ( devPtrM, ldm, n, p, q, alpha, beta ) implicit none integer sizeof_real parameter (sizeof_real=4) integer ldm, n, p, q #if ARCH_64 integer*8 devPtrM #else integer*4 devPtrM #endif real*4 alpha, beta call cublas_sscal ( n-p+1, alpha, 1 devPtrM+IDX2F(p, q, ldm)*sizeof_real, 2 ldm) call cublas_sscal(ldm-p+1, beta, 1 devPtrM+IDX2F(p, q, ldm)*sizeof_real, 2 1) return end program matrixmod implicit none integer M,N,sizeof_real #if ARCH_64 integer*8 devPtrA #else integer*4 devPtrA #endif parameter(M=6,N=5,sizeof_real=4) real*4 a(M,N) integer i,j,stat external cublas_init, cublas_set_matrix, cublas_get_matrix external cublas_shutdown, cublas_alloc integer cublas_alloc, cublas_set_matrix, cublas_get_matrix do j=1,N do i=1,M a(i,j)=(i-1)*M+j enddo enddo call cublas_init stat= cublas_alloc(M*N, sizeof_real, devPtrA) if (stat.NE.0) then write(*,*) "device memory allocation failed" call cublas_shutdown stop endif stat = cublas_set_matrix(M,N,sizeof_real,a,M,devPtrA,M) if (stat.NE.0) then call cublas_free( devPtrA ) write(*,*) "data download failed" call cublas_shutdown stop (continues on next page) 295 cuBLAS, Release 12.3 (continued from previous page) endif — — Code block continues below. Space added for formatting purposes. — — call modify(devPtrA, M, N, 2, 3, 16.0, 12.0) stat = cublas_get_matrix(M, N, sizeof_real, devPtrA, M, a, M ) if (stat.NE.0) then call cublas_free ( devPtrA ) write(*,*) "data upload failed" call cublas_shutdown stop endif call cublas_free ( devPtrA ) call cublas_shutdown do j = 1 , N do i = 1 , M write (*,"(F7.0$)") a(i,j) enddo write (*,*) "" enddo stop end 296 Chapter 8. cuBLAS Fortran Bindings Chapter 9. Interaction with Other Libraries and Tools This section describes important requirements and recommendations that ensure correct use of cuBLAS with other libraries and utilities. 9.1. nvprune nvprune enables pruning relocatable host objects and static libraries to only contain device code for the specific target architectures. In case of cuBLAS, particular care must be taken if using nvprune with compute capabilities, whose minor revision number is different than 0. To reduce binary size, cuBLAS may only store major revision equivalents of CUDA binary files for kernels reused between different minor revision versions. Therefore, to ensure that a pruned library does not fail for arbitrary problems, the user must keep binaries for a selected architecture and all prior minor architectures in its major architecture. For example, the following call prunes libcublas_static.a to contain only sm_75 (Turing) and sm_70 (Volta) cubins: nvprune --generate-code code=sm_70 --generate-code code=sm_75 libcublasLt_static.a -o ‹>libcublasLt_static_sm70_sm75.a which should be used instead of: nvprune -arch=sm_75 libcublasLt_static.a -o libcublasLt_static_sm75.a 297 cuBLAS, Release 12.3 298 Chapter 9. Interaction with Other Libraries and Tools Chapter 10. Acknowledgements NVIDIA would like to thank the following individuals and institutions for their contributions: ? Portions of the SGEMM, DGEMM, CGEMM and ZGEMM library routines were written by Vasily Volkov of the University of California. ? Portions of the SGEMM, DGEMM and ZGEMM library routines were written by Davide Barbieri of the University of Rome Tor Vergata. ? Portions of the DGEMM and SGEMM library routines optimized for Fermi architecture were de- veloped by the University of Tennessee. Subsequently, several other routines that are optimized for the Fermi architecture have been derived from these initial DGEMM and SGEMM implemen- tations. ? The substantial optimizations of the STRSV, DTRSV, CTRSV and ZTRSV library routines were de- veloped by Jonathan Hogg of The Science and Technology Facilities Council (STFC). Subsequently, some optimizations of the STRSM, DTRSM, CTRSM and ZTRSM have been derived from these TRSV implementations. ? Substantial optimizations of the SYMV and HEMV library routines were developed by Ahmad Ab- delfattah, David Keyes and Hatem Ltaief of King Abdullah University of Science and Technology (KAUST). ? Substantial optimizations of the TRMM and TRSM library routines were developed by Ali Charara, David Keyes and Hatem Ltaief of King Abdullah University of Science and Technology (KAUST). ? This product includes {fmt} - A modern formatting library https://fmt.devCopyright (c) 2012 - present, Victor Zverovich. ? This product includes spdlog - Fast C++ logging library. https://github.com/gabime/spdlog The MIT License (MIT). ? This product includes SIMD Library for Evaluating Elementary Functions, vectorized libm and DFT https://sleef.orgBoost Software License - Version 1.0 - August 17th, 2003. ? This product includes Frozen - a header-only, constexpr alternative to gperf for C++14 users. https://github.com/serge-sans-paille/frozen Apache License - Version 2.0, January 2004. ? This product includes Boost C++ Libraries - free peer-reviewed portable C++ source libraries https://www.boost.org/ Boost Software License - Version 1.0 - August 17th, 2003. 299 cuBLAS, Release 12.3 300 Chapter 10. Acknowledgements Chapter 11. Notices 11.1. Notice This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no repre- sentations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality. NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice. Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete. NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document. NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk. NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information con- tained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or prob- lem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs. No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or 301 cuBLAS, Release 12.3 services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA. Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices. THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WAR- RANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CON- SEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARIS- ING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatso- ever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product. 11.2. OpenCL OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc. 11.3. Trademarks NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated. Copyright ©2012-2023, NVIDIA Corporation & affiliates. All rights reserved 302 Chapter 11. Notices